# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = ['DhcpServerArgs', 'DhcpServer']

@pulumi.input_type
class DhcpServerArgs:
    def __init__(__self__, *,
                 interface: pulumi.Input[str],
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 add_arp: Optional[pulumi.Input[bool]] = None,
                 address_pool: Optional[pulumi.Input[str]] = None,
                 allow_dual_stack_queue: Optional[pulumi.Input[bool]] = None,
                 always_broadcast: Optional[pulumi.Input[bool]] = None,
                 authoritative: Optional[pulumi.Input[str]] = None,
                 bootp_lease_time: Optional[pulumi.Input[str]] = None,
                 bootp_support: Optional[pulumi.Input[str]] = None,
                 client_mac_limit: Optional[pulumi.Input[int]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 conflict_detection: Optional[pulumi.Input[bool]] = None,
                 delay_threshold: Optional[pulumi.Input[str]] = None,
                 dhcp_option_set: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 insert_queue_before: Optional[pulumi.Input[str]] = None,
                 lease_script: Optional[pulumi.Input[str]] = None,
                 lease_time: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parent_queue: Optional[pulumi.Input[str]] = None,
                 relay: Optional[pulumi.Input[str]] = None,
                 src_address: Optional[pulumi.Input[str]] = None,
                 use_framed_as_classless: Optional[pulumi.Input[bool]] = None,
                 use_radius: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a DhcpServer resource.
        :param pulumi.Input[str] interface: Name of the interface.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[bool] add_arp: Whether to add dynamic ARP entry.
        :param pulumi.Input[str] address_pool: IP pool, from which to take IP addresses for the clients. If set to static-only, then only the clients that have a
               static lease (added in lease submenu) will be allowed.
        :param pulumi.Input[bool] allow_dual_stack_queue: Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.
               Requires IPv6 DHCP Server to have this option enabled as well to work properly.
        :param pulumi.Input[bool] always_broadcast: Always send replies as broadcasts even if destination IP is known.
        :param pulumi.Input[str] authoritative: Option changes the way how a server responds to DHCP requests.
        :param pulumi.Input[str] bootp_lease_time: Accepts two predefined options or time value: * forever - lease never expires * lease-time - use time from lease-time
               parameter
        :param pulumi.Input[str] bootp_support: Support for BOOTP clients.
        :param pulumi.Input[int] client_mac_limit: Specifies whether to limit specific number of clients per single MAC address.
        :param pulumi.Input[bool] conflict_detection: Allows to disable/enable conflict detection. If option is enabled, then whenever server tries to assign a lease it will
               send ICMP and ARP messages to detect whether such address in the network already exist. If any of above get reply
               address is considered already used. Conflict detection must be disabled when any kind of DHCP client limitation per port
               or per mac is used.
        :param pulumi.Input[str] delay_threshold: If secs field in DHCP packet is smaller than delay-threshold, then this packet is ignored. If set to none - there is no
               threshold (all DHCP packets are processed).
        :param pulumi.Input[str] dhcp_option_set: Use custom set of DHCP options defined in option sets menu.
        :param pulumi.Input[str] insert_queue_before: Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        :param pulumi.Input[str] lease_script: A script that will be executed after a lease is assigned or de-assigned.
        :param pulumi.Input[str] lease_time: The time that a client may use the assigned address. The client will try to renew this address after half of this time
               and will request a new address after the time limit expires.
        :param pulumi.Input[str] name: Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
               resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
               integrity for that resource!
        :param pulumi.Input[str] relay: The IP address of the relay this DHCP server.
        :param pulumi.Input[str] src_address: The address which the DHCP client must send requests to in order to renew an IP address lease.
        :param pulumi.Input[bool] use_framed_as_classless: Forward RADIUS Framed-Route as a DHCP Classless-Static-Route to DHCP-client.
        :param pulumi.Input[str] use_radius: Whether to use RADIUS server.
        """
        pulumi.set(__self__, "interface", interface)
        if ___id_ is not None:
            pulumi.set(__self__, "___id_", ___id_)
        if ___path_ is not None:
            pulumi.set(__self__, "___path_", ___path_)
        if add_arp is not None:
            pulumi.set(__self__, "add_arp", add_arp)
        if address_pool is not None:
            pulumi.set(__self__, "address_pool", address_pool)
        if allow_dual_stack_queue is not None:
            pulumi.set(__self__, "allow_dual_stack_queue", allow_dual_stack_queue)
        if always_broadcast is not None:
            pulumi.set(__self__, "always_broadcast", always_broadcast)
        if authoritative is not None:
            pulumi.set(__self__, "authoritative", authoritative)
        if bootp_lease_time is not None:
            pulumi.set(__self__, "bootp_lease_time", bootp_lease_time)
        if bootp_support is not None:
            pulumi.set(__self__, "bootp_support", bootp_support)
        if client_mac_limit is not None:
            pulumi.set(__self__, "client_mac_limit", client_mac_limit)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if conflict_detection is not None:
            pulumi.set(__self__, "conflict_detection", conflict_detection)
        if delay_threshold is not None:
            pulumi.set(__self__, "delay_threshold", delay_threshold)
        if dhcp_option_set is not None:
            pulumi.set(__self__, "dhcp_option_set", dhcp_option_set)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if insert_queue_before is not None:
            pulumi.set(__self__, "insert_queue_before", insert_queue_before)
        if lease_script is not None:
            pulumi.set(__self__, "lease_script", lease_script)
        if lease_time is not None:
            pulumi.set(__self__, "lease_time", lease_time)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_queue is not None:
            pulumi.set(__self__, "parent_queue", parent_queue)
        if relay is not None:
            pulumi.set(__self__, "relay", relay)
        if src_address is not None:
            pulumi.set(__self__, "src_address", src_address)
        if use_framed_as_classless is not None:
            pulumi.set(__self__, "use_framed_as_classless", use_framed_as_classless)
        if use_radius is not None:
            pulumi.set(__self__, "use_radius", use_radius)

    @property
    @pulumi.getter
    def interface(self) -> pulumi.Input[str]:
        """
        Name of the interface.
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: pulumi.Input[str]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter
    def ___id_(self) -> Optional[pulumi.Input[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @___id_.setter
    def ___id_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "___id_", value)

    @property
    @pulumi.getter
    def ___path_(self) -> Optional[pulumi.Input[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @___path_.setter
    def ___path_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "___path_", value)

    @property
    @pulumi.getter(name="addArp")
    def add_arp(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to add dynamic ARP entry.
        """
        return pulumi.get(self, "add_arp")

    @add_arp.setter
    def add_arp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "add_arp", value)

    @property
    @pulumi.getter(name="addressPool")
    def address_pool(self) -> Optional[pulumi.Input[str]]:
        """
        IP pool, from which to take IP addresses for the clients. If set to static-only, then only the clients that have a
        static lease (added in lease submenu) will be allowed.
        """
        return pulumi.get(self, "address_pool")

    @address_pool.setter
    def address_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_pool", value)

    @property
    @pulumi.getter(name="allowDualStackQueue")
    def allow_dual_stack_queue(self) -> Optional[pulumi.Input[bool]]:
        """
        Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.
        Requires IPv6 DHCP Server to have this option enabled as well to work properly.
        """
        return pulumi.get(self, "allow_dual_stack_queue")

    @allow_dual_stack_queue.setter
    def allow_dual_stack_queue(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_dual_stack_queue", value)

    @property
    @pulumi.getter(name="alwaysBroadcast")
    def always_broadcast(self) -> Optional[pulumi.Input[bool]]:
        """
        Always send replies as broadcasts even if destination IP is known.
        """
        return pulumi.get(self, "always_broadcast")

    @always_broadcast.setter
    def always_broadcast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_broadcast", value)

    @property
    @pulumi.getter
    def authoritative(self) -> Optional[pulumi.Input[str]]:
        """
        Option changes the way how a server responds to DHCP requests.
        """
        return pulumi.get(self, "authoritative")

    @authoritative.setter
    def authoritative(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authoritative", value)

    @property
    @pulumi.getter(name="bootpLeaseTime")
    def bootp_lease_time(self) -> Optional[pulumi.Input[str]]:
        """
        Accepts two predefined options or time value: * forever - lease never expires * lease-time - use time from lease-time
        parameter
        """
        return pulumi.get(self, "bootp_lease_time")

    @bootp_lease_time.setter
    def bootp_lease_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bootp_lease_time", value)

    @property
    @pulumi.getter(name="bootpSupport")
    def bootp_support(self) -> Optional[pulumi.Input[str]]:
        """
        Support for BOOTP clients.
        """
        return pulumi.get(self, "bootp_support")

    @bootp_support.setter
    def bootp_support(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bootp_support", value)

    @property
    @pulumi.getter(name="clientMacLimit")
    def client_mac_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies whether to limit specific number of clients per single MAC address.
        """
        return pulumi.get(self, "client_mac_limit")

    @client_mac_limit.setter
    def client_mac_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "client_mac_limit", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="conflictDetection")
    def conflict_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows to disable/enable conflict detection. If option is enabled, then whenever server tries to assign a lease it will
        send ICMP and ARP messages to detect whether such address in the network already exist. If any of above get reply
        address is considered already used. Conflict detection must be disabled when any kind of DHCP client limitation per port
        or per mac is used.
        """
        return pulumi.get(self, "conflict_detection")

    @conflict_detection.setter
    def conflict_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "conflict_detection", value)

    @property
    @pulumi.getter(name="delayThreshold")
    def delay_threshold(self) -> Optional[pulumi.Input[str]]:
        """
        If secs field in DHCP packet is smaller than delay-threshold, then this packet is ignored. If set to none - there is no
        threshold (all DHCP packets are processed).
        """
        return pulumi.get(self, "delay_threshold")

    @delay_threshold.setter
    def delay_threshold(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delay_threshold", value)

    @property
    @pulumi.getter(name="dhcpOptionSet")
    def dhcp_option_set(self) -> Optional[pulumi.Input[str]]:
        """
        Use custom set of DHCP options defined in option sets menu.
        """
        return pulumi.get(self, "dhcp_option_set")

    @dhcp_option_set.setter
    def dhcp_option_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dhcp_option_set", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="insertQueueBefore")
    def insert_queue_before(self) -> Optional[pulumi.Input[str]]:
        """
        Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        """
        return pulumi.get(self, "insert_queue_before")

    @insert_queue_before.setter
    def insert_queue_before(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "insert_queue_before", value)

    @property
    @pulumi.getter(name="leaseScript")
    def lease_script(self) -> Optional[pulumi.Input[str]]:
        """
        A script that will be executed after a lease is assigned or de-assigned.
        """
        return pulumi.get(self, "lease_script")

    @lease_script.setter
    def lease_script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lease_script", value)

    @property
    @pulumi.getter(name="leaseTime")
    def lease_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time that a client may use the assigned address. The client will try to renew this address after half of this time
        and will request a new address after the time limit expires.
        """
        return pulumi.get(self, "lease_time")

    @lease_time.setter
    def lease_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lease_time", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
        resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
        integrity for that resource!
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="parentQueue")
    def parent_queue(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parent_queue")

    @parent_queue.setter
    def parent_queue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_queue", value)

    @property
    @pulumi.getter
    def relay(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address of the relay this DHCP server.
        """
        return pulumi.get(self, "relay")

    @relay.setter
    def relay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relay", value)

    @property
    @pulumi.getter(name="srcAddress")
    def src_address(self) -> Optional[pulumi.Input[str]]:
        """
        The address which the DHCP client must send requests to in order to renew an IP address lease.
        """
        return pulumi.get(self, "src_address")

    @src_address.setter
    def src_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_address", value)

    @property
    @pulumi.getter(name="useFramedAsClassless")
    def use_framed_as_classless(self) -> Optional[pulumi.Input[bool]]:
        """
        Forward RADIUS Framed-Route as a DHCP Classless-Static-Route to DHCP-client.
        """
        return pulumi.get(self, "use_framed_as_classless")

    @use_framed_as_classless.setter
    def use_framed_as_classless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_framed_as_classless", value)

    @property
    @pulumi.getter(name="useRadius")
    def use_radius(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to use RADIUS server.
        """
        return pulumi.get(self, "use_radius")

    @use_radius.setter
    def use_radius(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_radius", value)


@pulumi.input_type
class _DhcpServerState:
    def __init__(__self__, *,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 add_arp: Optional[pulumi.Input[bool]] = None,
                 address_pool: Optional[pulumi.Input[str]] = None,
                 allow_dual_stack_queue: Optional[pulumi.Input[bool]] = None,
                 always_broadcast: Optional[pulumi.Input[bool]] = None,
                 authoritative: Optional[pulumi.Input[str]] = None,
                 bootp_lease_time: Optional[pulumi.Input[str]] = None,
                 bootp_support: Optional[pulumi.Input[str]] = None,
                 client_mac_limit: Optional[pulumi.Input[int]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 conflict_detection: Optional[pulumi.Input[bool]] = None,
                 delay_threshold: Optional[pulumi.Input[str]] = None,
                 dhcp_option_set: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 dynamic: Optional[pulumi.Input[bool]] = None,
                 insert_queue_before: Optional[pulumi.Input[str]] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 invalid: Optional[pulumi.Input[bool]] = None,
                 lease_script: Optional[pulumi.Input[str]] = None,
                 lease_time: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parent_queue: Optional[pulumi.Input[str]] = None,
                 relay: Optional[pulumi.Input[str]] = None,
                 src_address: Optional[pulumi.Input[str]] = None,
                 use_framed_as_classless: Optional[pulumi.Input[bool]] = None,
                 use_radius: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering DhcpServer resources.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[bool] add_arp: Whether to add dynamic ARP entry.
        :param pulumi.Input[str] address_pool: IP pool, from which to take IP addresses for the clients. If set to static-only, then only the clients that have a
               static lease (added in lease submenu) will be allowed.
        :param pulumi.Input[bool] allow_dual_stack_queue: Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.
               Requires IPv6 DHCP Server to have this option enabled as well to work properly.
        :param pulumi.Input[bool] always_broadcast: Always send replies as broadcasts even if destination IP is known.
        :param pulumi.Input[str] authoritative: Option changes the way how a server responds to DHCP requests.
        :param pulumi.Input[str] bootp_lease_time: Accepts two predefined options or time value: * forever - lease never expires * lease-time - use time from lease-time
               parameter
        :param pulumi.Input[str] bootp_support: Support for BOOTP clients.
        :param pulumi.Input[int] client_mac_limit: Specifies whether to limit specific number of clients per single MAC address.
        :param pulumi.Input[bool] conflict_detection: Allows to disable/enable conflict detection. If option is enabled, then whenever server tries to assign a lease it will
               send ICMP and ARP messages to detect whether such address in the network already exist. If any of above get reply
               address is considered already used. Conflict detection must be disabled when any kind of DHCP client limitation per port
               or per mac is used.
        :param pulumi.Input[str] delay_threshold: If secs field in DHCP packet is smaller than delay-threshold, then this packet is ignored. If set to none - there is no
               threshold (all DHCP packets are processed).
        :param pulumi.Input[str] dhcp_option_set: Use custom set of DHCP options defined in option sets menu.
        :param pulumi.Input[bool] dynamic: Configuration item created by software, not by management interface. It is not exported, and cannot be directly
               modified.
        :param pulumi.Input[str] insert_queue_before: Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        :param pulumi.Input[str] interface: Name of the interface.
        :param pulumi.Input[str] lease_script: A script that will be executed after a lease is assigned or de-assigned.
        :param pulumi.Input[str] lease_time: The time that a client may use the assigned address. The client will try to renew this address after half of this time
               and will request a new address after the time limit expires.
        :param pulumi.Input[str] name: Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
               resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
               integrity for that resource!
        :param pulumi.Input[str] relay: The IP address of the relay this DHCP server.
        :param pulumi.Input[str] src_address: The address which the DHCP client must send requests to in order to renew an IP address lease.
        :param pulumi.Input[bool] use_framed_as_classless: Forward RADIUS Framed-Route as a DHCP Classless-Static-Route to DHCP-client.
        :param pulumi.Input[str] use_radius: Whether to use RADIUS server.
        """
        if ___id_ is not None:
            pulumi.set(__self__, "___id_", ___id_)
        if ___path_ is not None:
            pulumi.set(__self__, "___path_", ___path_)
        if add_arp is not None:
            pulumi.set(__self__, "add_arp", add_arp)
        if address_pool is not None:
            pulumi.set(__self__, "address_pool", address_pool)
        if allow_dual_stack_queue is not None:
            pulumi.set(__self__, "allow_dual_stack_queue", allow_dual_stack_queue)
        if always_broadcast is not None:
            pulumi.set(__self__, "always_broadcast", always_broadcast)
        if authoritative is not None:
            pulumi.set(__self__, "authoritative", authoritative)
        if bootp_lease_time is not None:
            pulumi.set(__self__, "bootp_lease_time", bootp_lease_time)
        if bootp_support is not None:
            pulumi.set(__self__, "bootp_support", bootp_support)
        if client_mac_limit is not None:
            pulumi.set(__self__, "client_mac_limit", client_mac_limit)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if conflict_detection is not None:
            pulumi.set(__self__, "conflict_detection", conflict_detection)
        if delay_threshold is not None:
            pulumi.set(__self__, "delay_threshold", delay_threshold)
        if dhcp_option_set is not None:
            pulumi.set(__self__, "dhcp_option_set", dhcp_option_set)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if insert_queue_before is not None:
            pulumi.set(__self__, "insert_queue_before", insert_queue_before)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if invalid is not None:
            pulumi.set(__self__, "invalid", invalid)
        if lease_script is not None:
            pulumi.set(__self__, "lease_script", lease_script)
        if lease_time is not None:
            pulumi.set(__self__, "lease_time", lease_time)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_queue is not None:
            pulumi.set(__self__, "parent_queue", parent_queue)
        if relay is not None:
            pulumi.set(__self__, "relay", relay)
        if src_address is not None:
            pulumi.set(__self__, "src_address", src_address)
        if use_framed_as_classless is not None:
            pulumi.set(__self__, "use_framed_as_classless", use_framed_as_classless)
        if use_radius is not None:
            pulumi.set(__self__, "use_radius", use_radius)

    @property
    @pulumi.getter
    def ___id_(self) -> Optional[pulumi.Input[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @___id_.setter
    def ___id_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "___id_", value)

    @property
    @pulumi.getter
    def ___path_(self) -> Optional[pulumi.Input[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @___path_.setter
    def ___path_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "___path_", value)

    @property
    @pulumi.getter(name="addArp")
    def add_arp(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to add dynamic ARP entry.
        """
        return pulumi.get(self, "add_arp")

    @add_arp.setter
    def add_arp(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "add_arp", value)

    @property
    @pulumi.getter(name="addressPool")
    def address_pool(self) -> Optional[pulumi.Input[str]]:
        """
        IP pool, from which to take IP addresses for the clients. If set to static-only, then only the clients that have a
        static lease (added in lease submenu) will be allowed.
        """
        return pulumi.get(self, "address_pool")

    @address_pool.setter
    def address_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_pool", value)

    @property
    @pulumi.getter(name="allowDualStackQueue")
    def allow_dual_stack_queue(self) -> Optional[pulumi.Input[bool]]:
        """
        Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.
        Requires IPv6 DHCP Server to have this option enabled as well to work properly.
        """
        return pulumi.get(self, "allow_dual_stack_queue")

    @allow_dual_stack_queue.setter
    def allow_dual_stack_queue(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_dual_stack_queue", value)

    @property
    @pulumi.getter(name="alwaysBroadcast")
    def always_broadcast(self) -> Optional[pulumi.Input[bool]]:
        """
        Always send replies as broadcasts even if destination IP is known.
        """
        return pulumi.get(self, "always_broadcast")

    @always_broadcast.setter
    def always_broadcast(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "always_broadcast", value)

    @property
    @pulumi.getter
    def authoritative(self) -> Optional[pulumi.Input[str]]:
        """
        Option changes the way how a server responds to DHCP requests.
        """
        return pulumi.get(self, "authoritative")

    @authoritative.setter
    def authoritative(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authoritative", value)

    @property
    @pulumi.getter(name="bootpLeaseTime")
    def bootp_lease_time(self) -> Optional[pulumi.Input[str]]:
        """
        Accepts two predefined options or time value: * forever - lease never expires * lease-time - use time from lease-time
        parameter
        """
        return pulumi.get(self, "bootp_lease_time")

    @bootp_lease_time.setter
    def bootp_lease_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bootp_lease_time", value)

    @property
    @pulumi.getter(name="bootpSupport")
    def bootp_support(self) -> Optional[pulumi.Input[str]]:
        """
        Support for BOOTP clients.
        """
        return pulumi.get(self, "bootp_support")

    @bootp_support.setter
    def bootp_support(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bootp_support", value)

    @property
    @pulumi.getter(name="clientMacLimit")
    def client_mac_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies whether to limit specific number of clients per single MAC address.
        """
        return pulumi.get(self, "client_mac_limit")

    @client_mac_limit.setter
    def client_mac_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "client_mac_limit", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="conflictDetection")
    def conflict_detection(self) -> Optional[pulumi.Input[bool]]:
        """
        Allows to disable/enable conflict detection. If option is enabled, then whenever server tries to assign a lease it will
        send ICMP and ARP messages to detect whether such address in the network already exist. If any of above get reply
        address is considered already used. Conflict detection must be disabled when any kind of DHCP client limitation per port
        or per mac is used.
        """
        return pulumi.get(self, "conflict_detection")

    @conflict_detection.setter
    def conflict_detection(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "conflict_detection", value)

    @property
    @pulumi.getter(name="delayThreshold")
    def delay_threshold(self) -> Optional[pulumi.Input[str]]:
        """
        If secs field in DHCP packet is smaller than delay-threshold, then this packet is ignored. If set to none - there is no
        threshold (all DHCP packets are processed).
        """
        return pulumi.get(self, "delay_threshold")

    @delay_threshold.setter
    def delay_threshold(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delay_threshold", value)

    @property
    @pulumi.getter(name="dhcpOptionSet")
    def dhcp_option_set(self) -> Optional[pulumi.Input[str]]:
        """
        Use custom set of DHCP options defined in option sets menu.
        """
        return pulumi.get(self, "dhcp_option_set")

    @dhcp_option_set.setter
    def dhcp_option_set(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dhcp_option_set", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def dynamic(self) -> Optional[pulumi.Input[bool]]:
        """
        Configuration item created by software, not by management interface. It is not exported, and cannot be directly
        modified.
        """
        return pulumi.get(self, "dynamic")

    @dynamic.setter
    def dynamic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic", value)

    @property
    @pulumi.getter(name="insertQueueBefore")
    def insert_queue_before(self) -> Optional[pulumi.Input[str]]:
        """
        Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        """
        return pulumi.get(self, "insert_queue_before")

    @insert_queue_before.setter
    def insert_queue_before(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "insert_queue_before", value)

    @property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the interface.
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter
    def invalid(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "invalid")

    @invalid.setter
    def invalid(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invalid", value)

    @property
    @pulumi.getter(name="leaseScript")
    def lease_script(self) -> Optional[pulumi.Input[str]]:
        """
        A script that will be executed after a lease is assigned or de-assigned.
        """
        return pulumi.get(self, "lease_script")

    @lease_script.setter
    def lease_script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lease_script", value)

    @property
    @pulumi.getter(name="leaseTime")
    def lease_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time that a client may use the assigned address. The client will try to renew this address after half of this time
        and will request a new address after the time limit expires.
        """
        return pulumi.get(self, "lease_time")

    @lease_time.setter
    def lease_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "lease_time", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
        resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
        integrity for that resource!
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="parentQueue")
    def parent_queue(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parent_queue")

    @parent_queue.setter
    def parent_queue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_queue", value)

    @property
    @pulumi.getter
    def relay(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address of the relay this DHCP server.
        """
        return pulumi.get(self, "relay")

    @relay.setter
    def relay(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relay", value)

    @property
    @pulumi.getter(name="srcAddress")
    def src_address(self) -> Optional[pulumi.Input[str]]:
        """
        The address which the DHCP client must send requests to in order to renew an IP address lease.
        """
        return pulumi.get(self, "src_address")

    @src_address.setter
    def src_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_address", value)

    @property
    @pulumi.getter(name="useFramedAsClassless")
    def use_framed_as_classless(self) -> Optional[pulumi.Input[bool]]:
        """
        Forward RADIUS Framed-Route as a DHCP Classless-Static-Route to DHCP-client.
        """
        return pulumi.get(self, "use_framed_as_classless")

    @use_framed_as_classless.setter
    def use_framed_as_classless(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_framed_as_classless", value)

    @property
    @pulumi.getter(name="useRadius")
    def use_radius(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to use RADIUS server.
        """
        return pulumi.get(self, "use_radius")

    @use_radius.setter
    def use_radius(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_radius", value)


class DhcpServer(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 add_arp: Optional[pulumi.Input[bool]] = None,
                 address_pool: Optional[pulumi.Input[str]] = None,
                 allow_dual_stack_queue: Optional[pulumi.Input[bool]] = None,
                 always_broadcast: Optional[pulumi.Input[bool]] = None,
                 authoritative: Optional[pulumi.Input[str]] = None,
                 bootp_lease_time: Optional[pulumi.Input[str]] = None,
                 bootp_support: Optional[pulumi.Input[str]] = None,
                 client_mac_limit: Optional[pulumi.Input[int]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 conflict_detection: Optional[pulumi.Input[bool]] = None,
                 delay_threshold: Optional[pulumi.Input[str]] = None,
                 dhcp_option_set: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 insert_queue_before: Optional[pulumi.Input[str]] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 lease_script: Optional[pulumi.Input[str]] = None,
                 lease_time: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parent_queue: Optional[pulumi.Input[str]] = None,
                 relay: Optional[pulumi.Input[str]] = None,
                 src_address: Optional[pulumi.Input[str]] = None,
                 use_framed_as_classless: Optional[pulumi.Input[bool]] = None,
                 use_radius: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        ## # Ip.DhcpServer (Resource)

        ***

        #### This is an alias for backwards compatibility between plugin versions.
        Please see documentation for Ip.DhcpIpServer

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[bool] add_arp: Whether to add dynamic ARP entry.
        :param pulumi.Input[str] address_pool: IP pool, from which to take IP addresses for the clients. If set to static-only, then only the clients that have a
               static lease (added in lease submenu) will be allowed.
        :param pulumi.Input[bool] allow_dual_stack_queue: Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.
               Requires IPv6 DHCP Server to have this option enabled as well to work properly.
        :param pulumi.Input[bool] always_broadcast: Always send replies as broadcasts even if destination IP is known.
        :param pulumi.Input[str] authoritative: Option changes the way how a server responds to DHCP requests.
        :param pulumi.Input[str] bootp_lease_time: Accepts two predefined options or time value: * forever - lease never expires * lease-time - use time from lease-time
               parameter
        :param pulumi.Input[str] bootp_support: Support for BOOTP clients.
        :param pulumi.Input[int] client_mac_limit: Specifies whether to limit specific number of clients per single MAC address.
        :param pulumi.Input[bool] conflict_detection: Allows to disable/enable conflict detection. If option is enabled, then whenever server tries to assign a lease it will
               send ICMP and ARP messages to detect whether such address in the network already exist. If any of above get reply
               address is considered already used. Conflict detection must be disabled when any kind of DHCP client limitation per port
               or per mac is used.
        :param pulumi.Input[str] delay_threshold: If secs field in DHCP packet is smaller than delay-threshold, then this packet is ignored. If set to none - there is no
               threshold (all DHCP packets are processed).
        :param pulumi.Input[str] dhcp_option_set: Use custom set of DHCP options defined in option sets menu.
        :param pulumi.Input[str] insert_queue_before: Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        :param pulumi.Input[str] interface: Name of the interface.
        :param pulumi.Input[str] lease_script: A script that will be executed after a lease is assigned or de-assigned.
        :param pulumi.Input[str] lease_time: The time that a client may use the assigned address. The client will try to renew this address after half of this time
               and will request a new address after the time limit expires.
        :param pulumi.Input[str] name: Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
               resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
               integrity for that resource!
        :param pulumi.Input[str] relay: The IP address of the relay this DHCP server.
        :param pulumi.Input[str] src_address: The address which the DHCP client must send requests to in order to renew an IP address lease.
        :param pulumi.Input[bool] use_framed_as_classless: Forward RADIUS Framed-Route as a DHCP Classless-Static-Route to DHCP-client.
        :param pulumi.Input[str] use_radius: Whether to use RADIUS server.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: DhcpServerArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## # Ip.DhcpServer (Resource)

        ***

        #### This is an alias for backwards compatibility between plugin versions.
        Please see documentation for Ip.DhcpIpServer

        :param str resource_name: The name of the resource.
        :param DhcpServerArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(DhcpServerArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 add_arp: Optional[pulumi.Input[bool]] = None,
                 address_pool: Optional[pulumi.Input[str]] = None,
                 allow_dual_stack_queue: Optional[pulumi.Input[bool]] = None,
                 always_broadcast: Optional[pulumi.Input[bool]] = None,
                 authoritative: Optional[pulumi.Input[str]] = None,
                 bootp_lease_time: Optional[pulumi.Input[str]] = None,
                 bootp_support: Optional[pulumi.Input[str]] = None,
                 client_mac_limit: Optional[pulumi.Input[int]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 conflict_detection: Optional[pulumi.Input[bool]] = None,
                 delay_threshold: Optional[pulumi.Input[str]] = None,
                 dhcp_option_set: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 insert_queue_before: Optional[pulumi.Input[str]] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 lease_script: Optional[pulumi.Input[str]] = None,
                 lease_time: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parent_queue: Optional[pulumi.Input[str]] = None,
                 relay: Optional[pulumi.Input[str]] = None,
                 src_address: Optional[pulumi.Input[str]] = None,
                 use_framed_as_classless: Optional[pulumi.Input[bool]] = None,
                 use_radius: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = DhcpServerArgs.__new__(DhcpServerArgs)

            __props__.__dict__["___id_"] = ___id_
            __props__.__dict__["___path_"] = ___path_
            __props__.__dict__["add_arp"] = add_arp
            __props__.__dict__["address_pool"] = address_pool
            __props__.__dict__["allow_dual_stack_queue"] = allow_dual_stack_queue
            __props__.__dict__["always_broadcast"] = always_broadcast
            __props__.__dict__["authoritative"] = authoritative
            __props__.__dict__["bootp_lease_time"] = bootp_lease_time
            __props__.__dict__["bootp_support"] = bootp_support
            __props__.__dict__["client_mac_limit"] = client_mac_limit
            __props__.__dict__["comment"] = comment
            __props__.__dict__["conflict_detection"] = conflict_detection
            __props__.__dict__["delay_threshold"] = delay_threshold
            __props__.__dict__["dhcp_option_set"] = dhcp_option_set
            __props__.__dict__["disabled"] = disabled
            __props__.__dict__["insert_queue_before"] = insert_queue_before
            if interface is None and not opts.urn:
                raise TypeError("Missing required property 'interface'")
            __props__.__dict__["interface"] = interface
            __props__.__dict__["lease_script"] = lease_script
            __props__.__dict__["lease_time"] = lease_time
            __props__.__dict__["name"] = name
            __props__.__dict__["parent_queue"] = parent_queue
            __props__.__dict__["relay"] = relay
            __props__.__dict__["src_address"] = src_address
            __props__.__dict__["use_framed_as_classless"] = use_framed_as_classless
            __props__.__dict__["use_radius"] = use_radius
            __props__.__dict__["dynamic"] = None
            __props__.__dict__["invalid"] = None
        super(DhcpServer, __self__).__init__(
            'routeros:Ip/dhcpServer:DhcpServer',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            ___id_: Optional[pulumi.Input[int]] = None,
            ___path_: Optional[pulumi.Input[str]] = None,
            add_arp: Optional[pulumi.Input[bool]] = None,
            address_pool: Optional[pulumi.Input[str]] = None,
            allow_dual_stack_queue: Optional[pulumi.Input[bool]] = None,
            always_broadcast: Optional[pulumi.Input[bool]] = None,
            authoritative: Optional[pulumi.Input[str]] = None,
            bootp_lease_time: Optional[pulumi.Input[str]] = None,
            bootp_support: Optional[pulumi.Input[str]] = None,
            client_mac_limit: Optional[pulumi.Input[int]] = None,
            comment: Optional[pulumi.Input[str]] = None,
            conflict_detection: Optional[pulumi.Input[bool]] = None,
            delay_threshold: Optional[pulumi.Input[str]] = None,
            dhcp_option_set: Optional[pulumi.Input[str]] = None,
            disabled: Optional[pulumi.Input[bool]] = None,
            dynamic: Optional[pulumi.Input[bool]] = None,
            insert_queue_before: Optional[pulumi.Input[str]] = None,
            interface: Optional[pulumi.Input[str]] = None,
            invalid: Optional[pulumi.Input[bool]] = None,
            lease_script: Optional[pulumi.Input[str]] = None,
            lease_time: Optional[pulumi.Input[str]] = None,
            name: Optional[pulumi.Input[str]] = None,
            parent_queue: Optional[pulumi.Input[str]] = None,
            relay: Optional[pulumi.Input[str]] = None,
            src_address: Optional[pulumi.Input[str]] = None,
            use_framed_as_classless: Optional[pulumi.Input[bool]] = None,
            use_radius: Optional[pulumi.Input[str]] = None) -> 'DhcpServer':
        """
        Get an existing DhcpServer resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[bool] add_arp: Whether to add dynamic ARP entry.
        :param pulumi.Input[str] address_pool: IP pool, from which to take IP addresses for the clients. If set to static-only, then only the clients that have a
               static lease (added in lease submenu) will be allowed.
        :param pulumi.Input[bool] allow_dual_stack_queue: Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.
               Requires IPv6 DHCP Server to have this option enabled as well to work properly.
        :param pulumi.Input[bool] always_broadcast: Always send replies as broadcasts even if destination IP is known.
        :param pulumi.Input[str] authoritative: Option changes the way how a server responds to DHCP requests.
        :param pulumi.Input[str] bootp_lease_time: Accepts two predefined options or time value: * forever - lease never expires * lease-time - use time from lease-time
               parameter
        :param pulumi.Input[str] bootp_support: Support for BOOTP clients.
        :param pulumi.Input[int] client_mac_limit: Specifies whether to limit specific number of clients per single MAC address.
        :param pulumi.Input[bool] conflict_detection: Allows to disable/enable conflict detection. If option is enabled, then whenever server tries to assign a lease it will
               send ICMP and ARP messages to detect whether such address in the network already exist. If any of above get reply
               address is considered already used. Conflict detection must be disabled when any kind of DHCP client limitation per port
               or per mac is used.
        :param pulumi.Input[str] delay_threshold: If secs field in DHCP packet is smaller than delay-threshold, then this packet is ignored. If set to none - there is no
               threshold (all DHCP packets are processed).
        :param pulumi.Input[str] dhcp_option_set: Use custom set of DHCP options defined in option sets menu.
        :param pulumi.Input[bool] dynamic: Configuration item created by software, not by management interface. It is not exported, and cannot be directly
               modified.
        :param pulumi.Input[str] insert_queue_before: Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        :param pulumi.Input[str] interface: Name of the interface.
        :param pulumi.Input[str] lease_script: A script that will be executed after a lease is assigned or de-assigned.
        :param pulumi.Input[str] lease_time: The time that a client may use the assigned address. The client will try to renew this address after half of this time
               and will request a new address after the time limit expires.
        :param pulumi.Input[str] name: Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
               resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
               integrity for that resource!
        :param pulumi.Input[str] relay: The IP address of the relay this DHCP server.
        :param pulumi.Input[str] src_address: The address which the DHCP client must send requests to in order to renew an IP address lease.
        :param pulumi.Input[bool] use_framed_as_classless: Forward RADIUS Framed-Route as a DHCP Classless-Static-Route to DHCP-client.
        :param pulumi.Input[str] use_radius: Whether to use RADIUS server.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _DhcpServerState.__new__(_DhcpServerState)

        __props__.__dict__["___id_"] = ___id_
        __props__.__dict__["___path_"] = ___path_
        __props__.__dict__["add_arp"] = add_arp
        __props__.__dict__["address_pool"] = address_pool
        __props__.__dict__["allow_dual_stack_queue"] = allow_dual_stack_queue
        __props__.__dict__["always_broadcast"] = always_broadcast
        __props__.__dict__["authoritative"] = authoritative
        __props__.__dict__["bootp_lease_time"] = bootp_lease_time
        __props__.__dict__["bootp_support"] = bootp_support
        __props__.__dict__["client_mac_limit"] = client_mac_limit
        __props__.__dict__["comment"] = comment
        __props__.__dict__["conflict_detection"] = conflict_detection
        __props__.__dict__["delay_threshold"] = delay_threshold
        __props__.__dict__["dhcp_option_set"] = dhcp_option_set
        __props__.__dict__["disabled"] = disabled
        __props__.__dict__["dynamic"] = dynamic
        __props__.__dict__["insert_queue_before"] = insert_queue_before
        __props__.__dict__["interface"] = interface
        __props__.__dict__["invalid"] = invalid
        __props__.__dict__["lease_script"] = lease_script
        __props__.__dict__["lease_time"] = lease_time
        __props__.__dict__["name"] = name
        __props__.__dict__["parent_queue"] = parent_queue
        __props__.__dict__["relay"] = relay
        __props__.__dict__["src_address"] = src_address
        __props__.__dict__["use_framed_as_classless"] = use_framed_as_classless
        __props__.__dict__["use_radius"] = use_radius
        return DhcpServer(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def ___id_(self) -> pulumi.Output[Optional[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @property
    @pulumi.getter
    def ___path_(self) -> pulumi.Output[Optional[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @property
    @pulumi.getter(name="addArp")
    def add_arp(self) -> pulumi.Output[Optional[bool]]:
        """
        Whether to add dynamic ARP entry.
        """
        return pulumi.get(self, "add_arp")

    @property
    @pulumi.getter(name="addressPool")
    def address_pool(self) -> pulumi.Output[Optional[str]]:
        """
        IP pool, from which to take IP addresses for the clients. If set to static-only, then only the clients that have a
        static lease (added in lease submenu) will be allowed.
        """
        return pulumi.get(self, "address_pool")

    @property
    @pulumi.getter(name="allowDualStackQueue")
    def allow_dual_stack_queue(self) -> pulumi.Output[Optional[bool]]:
        """
        Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.
        Requires IPv6 DHCP Server to have this option enabled as well to work properly.
        """
        return pulumi.get(self, "allow_dual_stack_queue")

    @property
    @pulumi.getter(name="alwaysBroadcast")
    def always_broadcast(self) -> pulumi.Output[Optional[bool]]:
        """
        Always send replies as broadcasts even if destination IP is known.
        """
        return pulumi.get(self, "always_broadcast")

    @property
    @pulumi.getter
    def authoritative(self) -> pulumi.Output[Optional[str]]:
        """
        Option changes the way how a server responds to DHCP requests.
        """
        return pulumi.get(self, "authoritative")

    @property
    @pulumi.getter(name="bootpLeaseTime")
    def bootp_lease_time(self) -> pulumi.Output[Optional[str]]:
        """
        Accepts two predefined options or time value: * forever - lease never expires * lease-time - use time from lease-time
        parameter
        """
        return pulumi.get(self, "bootp_lease_time")

    @property
    @pulumi.getter(name="bootpSupport")
    def bootp_support(self) -> pulumi.Output[Optional[str]]:
        """
        Support for BOOTP clients.
        """
        return pulumi.get(self, "bootp_support")

    @property
    @pulumi.getter(name="clientMacLimit")
    def client_mac_limit(self) -> pulumi.Output[Optional[int]]:
        """
        Specifies whether to limit specific number of clients per single MAC address.
        """
        return pulumi.get(self, "client_mac_limit")

    @property
    @pulumi.getter
    def comment(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="conflictDetection")
    def conflict_detection(self) -> pulumi.Output[Optional[bool]]:
        """
        Allows to disable/enable conflict detection. If option is enabled, then whenever server tries to assign a lease it will
        send ICMP and ARP messages to detect whether such address in the network already exist. If any of above get reply
        address is considered already used. Conflict detection must be disabled when any kind of DHCP client limitation per port
        or per mac is used.
        """
        return pulumi.get(self, "conflict_detection")

    @property
    @pulumi.getter(name="delayThreshold")
    def delay_threshold(self) -> pulumi.Output[Optional[str]]:
        """
        If secs field in DHCP packet is smaller than delay-threshold, then this packet is ignored. If set to none - there is no
        threshold (all DHCP packets are processed).
        """
        return pulumi.get(self, "delay_threshold")

    @property
    @pulumi.getter(name="dhcpOptionSet")
    def dhcp_option_set(self) -> pulumi.Output[Optional[str]]:
        """
        Use custom set of DHCP options defined in option sets menu.
        """
        return pulumi.get(self, "dhcp_option_set")

    @property
    @pulumi.getter
    def disabled(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def dynamic(self) -> pulumi.Output[bool]:
        """
        Configuration item created by software, not by management interface. It is not exported, and cannot be directly
        modified.
        """
        return pulumi.get(self, "dynamic")

    @property
    @pulumi.getter(name="insertQueueBefore")
    def insert_queue_before(self) -> pulumi.Output[Optional[str]]:
        """
        Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        """
        return pulumi.get(self, "insert_queue_before")

    @property
    @pulumi.getter
    def interface(self) -> pulumi.Output[str]:
        """
        Name of the interface.
        """
        return pulumi.get(self, "interface")

    @property
    @pulumi.getter
    def invalid(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "invalid")

    @property
    @pulumi.getter(name="leaseScript")
    def lease_script(self) -> pulumi.Output[Optional[str]]:
        """
        A script that will be executed after a lease is assigned or de-assigned.
        """
        return pulumi.get(self, "lease_script")

    @property
    @pulumi.getter(name="leaseTime")
    def lease_time(self) -> pulumi.Output[Optional[str]]:
        """
        The time that a client may use the assigned address. The client will try to renew this address after half of this time
        and will request a new address after the time limit expires.
        """
        return pulumi.get(self, "lease_time")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
        resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
        integrity for that resource!
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="parentQueue")
    def parent_queue(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "parent_queue")

    @property
    @pulumi.getter
    def relay(self) -> pulumi.Output[Optional[str]]:
        """
        The IP address of the relay this DHCP server.
        """
        return pulumi.get(self, "relay")

    @property
    @pulumi.getter(name="srcAddress")
    def src_address(self) -> pulumi.Output[Optional[str]]:
        """
        The address which the DHCP client must send requests to in order to renew an IP address lease.
        """
        return pulumi.get(self, "src_address")

    @property
    @pulumi.getter(name="useFramedAsClassless")
    def use_framed_as_classless(self) -> pulumi.Output[Optional[bool]]:
        """
        Forward RADIUS Framed-Route as a DHCP Classless-Static-Route to DHCP-client.
        """
        return pulumi.get(self, "use_framed_as_classless")

    @property
    @pulumi.getter(name="useRadius")
    def use_radius(self) -> pulumi.Output[Optional[str]]:
        """
        Whether to use RADIUS server.
        """
        return pulumi.get(self, "use_radius")

