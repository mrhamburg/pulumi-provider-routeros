# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = ['IpFirewallFilterArgs', 'IpFirewallFilter']

@pulumi.input_type
class IpFirewallFilterArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 chain: pulumi.Input[str],
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 address_list_timeout: Optional[pulumi.Input[str]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 connection_bytes: Optional[pulumi.Input[str]] = None,
                 connection_limit: Optional[pulumi.Input[str]] = None,
                 connection_mark: Optional[pulumi.Input[str]] = None,
                 connection_nat_state: Optional[pulumi.Input[str]] = None,
                 connection_rate: Optional[pulumi.Input[str]] = None,
                 connection_state: Optional[pulumi.Input[str]] = None,
                 connection_type: Optional[pulumi.Input[str]] = None,
                 content: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 dscp: Optional[pulumi.Input[int]] = None,
                 dst_address: Optional[pulumi.Input[str]] = None,
                 dst_address_list: Optional[pulumi.Input[str]] = None,
                 dst_address_type: Optional[pulumi.Input[str]] = None,
                 dst_limit: Optional[pulumi.Input[str]] = None,
                 dst_port: Optional[pulumi.Input[str]] = None,
                 fragment: Optional[pulumi.Input[bool]] = None,
                 hotspot: Optional[pulumi.Input[str]] = None,
                 hw_offload: Optional[pulumi.Input[bool]] = None,
                 icmp_options: Optional[pulumi.Input[str]] = None,
                 in_bridge_port: Optional[pulumi.Input[str]] = None,
                 in_bridge_port_list: Optional[pulumi.Input[str]] = None,
                 in_interface: Optional[pulumi.Input[str]] = None,
                 in_interface_list: Optional[pulumi.Input[str]] = None,
                 ingress_priority: Optional[pulumi.Input[int]] = None,
                 ipsec_policy: Optional[pulumi.Input[str]] = None,
                 ipv4_options: Optional[pulumi.Input[str]] = None,
                 jump_target: Optional[pulumi.Input[str]] = None,
                 layer7_protocol: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[str]] = None,
                 log: Optional[pulumi.Input[bool]] = None,
                 log_prefix: Optional[pulumi.Input[str]] = None,
                 nth: Optional[pulumi.Input[str]] = None,
                 out_bridge_port: Optional[pulumi.Input[str]] = None,
                 out_bridge_port_list: Optional[pulumi.Input[str]] = None,
                 out_interface: Optional[pulumi.Input[str]] = None,
                 out_interface_list: Optional[pulumi.Input[str]] = None,
                 packet_mark: Optional[pulumi.Input[str]] = None,
                 packet_size: Optional[pulumi.Input[str]] = None,
                 per_connection_classifier: Optional[pulumi.Input[str]] = None,
                 place_before: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 psd: Optional[pulumi.Input[str]] = None,
                 random: Optional[pulumi.Input[int]] = None,
                 reject_with: Optional[pulumi.Input[str]] = None,
                 routing_mark: Optional[pulumi.Input[str]] = None,
                 routing_table: Optional[pulumi.Input[str]] = None,
                 src_address: Optional[pulumi.Input[str]] = None,
                 src_address_list: Optional[pulumi.Input[str]] = None,
                 src_address_type: Optional[pulumi.Input[str]] = None,
                 src_mac_address: Optional[pulumi.Input[str]] = None,
                 src_port: Optional[pulumi.Input[str]] = None,
                 tcp_flags: Optional[pulumi.Input[str]] = None,
                 tcp_mss: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input[str]] = None,
                 tls_host: Optional[pulumi.Input[str]] = None,
                 ttl: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a IpFirewallFilter resource.
        :param pulumi.Input[str] action: Action to take if a packet is matched by the rule
        :param pulumi.Input[str] chain: Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
               chain will be created.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] address_list_timeout: Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
               conjunction with add-dst-to-address-list or add-src-to-address-list actions.
        :param pulumi.Input[str] connection_bytes: Matches packets only if a given amount of bytes has been transfered through the particular connection.
        :param pulumi.Input[str] connection_limit: Matches connections per address or address block after given value is reached. Should be used together with
               connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
        :param pulumi.Input[str] connection_mark: Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
               unmarked connection.
        :param pulumi.Input[str] connection_nat_state: Can match connections that are srcnatted, dstnatted or both.
        :param pulumi.Input[str] connection_rate: Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
               (0..4294967295).
        :param pulumi.Input[str] connection_state: Interprets the connection tracking analysis data for a particular packet.
        :param pulumi.Input[str] connection_type: Matches packets from related connections based on information from their connection tracking helpers.
        :param pulumi.Input[str] content: Match packets that contain specified text.
        :param pulumi.Input[int] dscp: Matches DSCP IP header field.
        :param pulumi.Input[str] dst_address: Matches packets which destination is equal to specified IP or falls into specified IP range.
        :param pulumi.Input[str] dst_address_list: Matches destination address of a packet against user-defined address list.
        :param pulumi.Input[str] dst_address_type: Matches destination address type.
        :param pulumi.Input[str] dst_limit: Matches packets until a given rate is exceeded.
        :param pulumi.Input[str] dst_port: List of destination port numbers or port number ranges.
        :param pulumi.Input[bool] fragment: Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
               fragments as system automatically assembles every packet
        :param pulumi.Input[str] hotspot: Matches packets received from HotSpot clients against various HotSpot matchers.
        :param pulumi.Input[bool] hw_offload: Connection offloading for Fasttrack.
        :param pulumi.Input[str] icmp_options: Matches ICMP type: code fields.
        :param pulumi.Input[str] in_bridge_port: Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
               is enabled in bridge settings.
        :param pulumi.Input[str] in_bridge_port_list: Set of interfaces defined in interface list. Works the same as in-bridge-port.
        :param pulumi.Input[str] in_interface: Interface the packet has entered the router.
        :param pulumi.Input[str] in_interface_list: Set of interfaces defined in interface list. Works the same as in-interface.
        :param pulumi.Input[int] ingress_priority: Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
        :param pulumi.Input[str] ipsec_policy: Matches the policy used by IPsec. Value is written in the following format: direction, policy.
        :param pulumi.Input[str] ipv4_options: Matches IPv4 header options.
        :param pulumi.Input[str] jump_target: Name of the target chain to jump to. Applicable only if action=jump.
        :param pulumi.Input[str] layer7_protocol: Layer7 filter name.
        :param pulumi.Input[str] limit: Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
               reached. Parameters are written in the following format: rate[/time],burst:mode.
        :param pulumi.Input[bool] log: Add a message to the system log.
        :param pulumi.Input[str] log_prefix: Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
        :param pulumi.Input[str] nth: Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
               by the rule
        :param pulumi.Input[str] out_bridge_port: Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
               is enabled in bridge settings.
        :param pulumi.Input[str] out_bridge_port_list: Set of interfaces defined in interface list. Works the same as out-bridge-port.
        :param pulumi.Input[str] out_interface: Interface the packet is leaving the router.
        :param pulumi.Input[str] out_interface_list: Set of interfaces defined in interface list. Works the same as out-interface.
        :param pulumi.Input[str] packet_mark: Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
               unmarked packet.
        :param pulumi.Input[str] packet_size: Matches packets of specified size or size range in bytes.
        :param pulumi.Input[str] per_connection_classifier: PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
               in one particular stream.
        :param pulumi.Input[str] place_before: Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
               think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
        :param pulumi.Input[str] port: Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
               protocol is TCP or UDP
        :param pulumi.Input[int] priority: Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP
               bit, or from the priority that has been set using the set-priority action.
        :param pulumi.Input[str] protocol: Matches particular IP protocol specified by protocol name or number.
        :param pulumi.Input[str] psd: Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
               LowPortWeight, HighPortWeight.
        :param pulumi.Input[int] random: Matches packets randomly with a given probability.
        :param pulumi.Input[str] reject_with: Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.
        :param pulumi.Input[str] routing_mark: Matches packets marked by mangle facility with particular routing mark.
        :param pulumi.Input[str] routing_table: Matches packets which destination address is resolved in specific a routing table.
        :param pulumi.Input[str] src_address: Matches packets which source is equal to specified IP or falls into a specified IP range.
        :param pulumi.Input[str] src_address_list: Matches source address of a packet against user-defined address list.
        :param pulumi.Input[str] src_address_type: Matches source address type.
        :param pulumi.Input[str] src_mac_address: Matches source MAC address of the packet.
        :param pulumi.Input[str] src_port: List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
        :param pulumi.Input[str] tcp_flags: Matches specified TCP flags.
        :param pulumi.Input[str] tcp_mss: Matches TCP MSS value of an IP packet.
        :param pulumi.Input[str] time: Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
               and date.
        :param pulumi.Input[str] tls_host: Allows matching HTTPS traffic based on TLS SNI hostname.
        :param pulumi.Input[str] ttl: Matches packets TTL value.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "chain", chain)
        if ___id_ is not None:
            pulumi.set(__self__, "___id_", ___id_)
        if ___path_ is not None:
            pulumi.set(__self__, "___path_", ___path_)
        if address_list_timeout is not None:
            pulumi.set(__self__, "address_list_timeout", address_list_timeout)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if connection_bytes is not None:
            pulumi.set(__self__, "connection_bytes", connection_bytes)
        if connection_limit is not None:
            pulumi.set(__self__, "connection_limit", connection_limit)
        if connection_mark is not None:
            pulumi.set(__self__, "connection_mark", connection_mark)
        if connection_nat_state is not None:
            pulumi.set(__self__, "connection_nat_state", connection_nat_state)
        if connection_rate is not None:
            pulumi.set(__self__, "connection_rate", connection_rate)
        if connection_state is not None:
            pulumi.set(__self__, "connection_state", connection_state)
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if dst_address is not None:
            pulumi.set(__self__, "dst_address", dst_address)
        if dst_address_list is not None:
            pulumi.set(__self__, "dst_address_list", dst_address_list)
        if dst_address_type is not None:
            pulumi.set(__self__, "dst_address_type", dst_address_type)
        if dst_limit is not None:
            pulumi.set(__self__, "dst_limit", dst_limit)
        if dst_port is not None:
            pulumi.set(__self__, "dst_port", dst_port)
        if fragment is not None:
            pulumi.set(__self__, "fragment", fragment)
        if hotspot is not None:
            pulumi.set(__self__, "hotspot", hotspot)
        if hw_offload is not None:
            pulumi.set(__self__, "hw_offload", hw_offload)
        if icmp_options is not None:
            pulumi.set(__self__, "icmp_options", icmp_options)
        if in_bridge_port is not None:
            pulumi.set(__self__, "in_bridge_port", in_bridge_port)
        if in_bridge_port_list is not None:
            pulumi.set(__self__, "in_bridge_port_list", in_bridge_port_list)
        if in_interface is not None:
            pulumi.set(__self__, "in_interface", in_interface)
        if in_interface_list is not None:
            pulumi.set(__self__, "in_interface_list", in_interface_list)
        if ingress_priority is not None:
            pulumi.set(__self__, "ingress_priority", ingress_priority)
        if ipsec_policy is not None:
            pulumi.set(__self__, "ipsec_policy", ipsec_policy)
        if ipv4_options is not None:
            pulumi.set(__self__, "ipv4_options", ipv4_options)
        if jump_target is not None:
            pulumi.set(__self__, "jump_target", jump_target)
        if layer7_protocol is not None:
            pulumi.set(__self__, "layer7_protocol", layer7_protocol)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if log_prefix is not None:
            pulumi.set(__self__, "log_prefix", log_prefix)
        if nth is not None:
            pulumi.set(__self__, "nth", nth)
        if out_bridge_port is not None:
            pulumi.set(__self__, "out_bridge_port", out_bridge_port)
        if out_bridge_port_list is not None:
            pulumi.set(__self__, "out_bridge_port_list", out_bridge_port_list)
        if out_interface is not None:
            pulumi.set(__self__, "out_interface", out_interface)
        if out_interface_list is not None:
            pulumi.set(__self__, "out_interface_list", out_interface_list)
        if packet_mark is not None:
            pulumi.set(__self__, "packet_mark", packet_mark)
        if packet_size is not None:
            pulumi.set(__self__, "packet_size", packet_size)
        if per_connection_classifier is not None:
            pulumi.set(__self__, "per_connection_classifier", per_connection_classifier)
        if place_before is not None:
            pulumi.set(__self__, "place_before", place_before)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if psd is not None:
            pulumi.set(__self__, "psd", psd)
        if random is not None:
            pulumi.set(__self__, "random", random)
        if reject_with is not None:
            pulumi.set(__self__, "reject_with", reject_with)
        if routing_mark is not None:
            pulumi.set(__self__, "routing_mark", routing_mark)
        if routing_table is not None:
            pulumi.set(__self__, "routing_table", routing_table)
        if src_address is not None:
            pulumi.set(__self__, "src_address", src_address)
        if src_address_list is not None:
            pulumi.set(__self__, "src_address_list", src_address_list)
        if src_address_type is not None:
            pulumi.set(__self__, "src_address_type", src_address_type)
        if src_mac_address is not None:
            pulumi.set(__self__, "src_mac_address", src_mac_address)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if tcp_flags is not None:
            pulumi.set(__self__, "tcp_flags", tcp_flags)
        if tcp_mss is not None:
            pulumi.set(__self__, "tcp_mss", tcp_mss)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if tls_host is not None:
            pulumi.set(__self__, "tls_host", tls_host)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Action to take if a packet is matched by the rule
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def chain(self) -> pulumi.Input[str]:
        """
        Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
        chain will be created.
        """
        return pulumi.get(self, "chain")

    @chain.setter
    def chain(self, value: pulumi.Input[str]):
        pulumi.set(self, "chain", value)

    @property
    @pulumi.getter
    def ___id_(self) -> Optional[pulumi.Input[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @___id_.setter
    def ___id_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "___id_", value)

    @property
    @pulumi.getter
    def ___path_(self) -> Optional[pulumi.Input[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @___path_.setter
    def ___path_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "___path_", value)

    @property
    @pulumi.getter(name="addressListTimeout")
    def address_list_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
        conjunction with add-dst-to-address-list or add-src-to-address-list actions.
        """
        return pulumi.get(self, "address_list_timeout")

    @address_list_timeout.setter
    def address_list_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_list_timeout", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="connectionBytes")
    def connection_bytes(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets only if a given amount of bytes has been transfered through the particular connection.
        """
        return pulumi.get(self, "connection_bytes")

    @connection_bytes.setter
    def connection_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_bytes", value)

    @property
    @pulumi.getter(name="connectionLimit")
    def connection_limit(self) -> Optional[pulumi.Input[str]]:
        """
        Matches connections per address or address block after given value is reached. Should be used together with
        connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
        """
        return pulumi.get(self, "connection_limit")

    @connection_limit.setter
    def connection_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_limit", value)

    @property
    @pulumi.getter(name="connectionMark")
    def connection_mark(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
        unmarked connection.
        """
        return pulumi.get(self, "connection_mark")

    @connection_mark.setter
    def connection_mark(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_mark", value)

    @property
    @pulumi.getter(name="connectionNatState")
    def connection_nat_state(self) -> Optional[pulumi.Input[str]]:
        """
        Can match connections that are srcnatted, dstnatted or both.
        """
        return pulumi.get(self, "connection_nat_state")

    @connection_nat_state.setter
    def connection_nat_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_nat_state", value)

    @property
    @pulumi.getter(name="connectionRate")
    def connection_rate(self) -> Optional[pulumi.Input[str]]:
        """
        Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
        (0..4294967295).
        """
        return pulumi.get(self, "connection_rate")

    @connection_rate.setter
    def connection_rate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_rate", value)

    @property
    @pulumi.getter(name="connectionState")
    def connection_state(self) -> Optional[pulumi.Input[str]]:
        """
        Interprets the connection tracking analysis data for a particular packet.
        """
        return pulumi.get(self, "connection_state")

    @connection_state.setter
    def connection_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_state", value)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets from related connections based on information from their connection tracking helpers.
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_type", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Match packets that contain specified text.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def dscp(self) -> Optional[pulumi.Input[int]]:
        """
        Matches DSCP IP header field.
        """
        return pulumi.get(self, "dscp")

    @dscp.setter
    def dscp(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dscp", value)

    @property
    @pulumi.getter(name="dstAddress")
    def dst_address(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets which destination is equal to specified IP or falls into specified IP range.
        """
        return pulumi.get(self, "dst_address")

    @dst_address.setter
    def dst_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dst_address", value)

    @property
    @pulumi.getter(name="dstAddressList")
    def dst_address_list(self) -> Optional[pulumi.Input[str]]:
        """
        Matches destination address of a packet against user-defined address list.
        """
        return pulumi.get(self, "dst_address_list")

    @dst_address_list.setter
    def dst_address_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dst_address_list", value)

    @property
    @pulumi.getter(name="dstAddressType")
    def dst_address_type(self) -> Optional[pulumi.Input[str]]:
        """
        Matches destination address type.
        """
        return pulumi.get(self, "dst_address_type")

    @dst_address_type.setter
    def dst_address_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dst_address_type", value)

    @property
    @pulumi.getter(name="dstLimit")
    def dst_limit(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets until a given rate is exceeded.
        """
        return pulumi.get(self, "dst_limit")

    @dst_limit.setter
    def dst_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dst_limit", value)

    @property
    @pulumi.getter(name="dstPort")
    def dst_port(self) -> Optional[pulumi.Input[str]]:
        """
        List of destination port numbers or port number ranges.
        """
        return pulumi.get(self, "dst_port")

    @dst_port.setter
    def dst_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dst_port", value)

    @property
    @pulumi.getter
    def fragment(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
        fragments as system automatically assembles every packet
        """
        return pulumi.get(self, "fragment")

    @fragment.setter
    def fragment(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fragment", value)

    @property
    @pulumi.getter
    def hotspot(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets received from HotSpot clients against various HotSpot matchers.
        """
        return pulumi.get(self, "hotspot")

    @hotspot.setter
    def hotspot(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hotspot", value)

    @property
    @pulumi.getter(name="hwOffload")
    def hw_offload(self) -> Optional[pulumi.Input[bool]]:
        """
        Connection offloading for Fasttrack.
        """
        return pulumi.get(self, "hw_offload")

    @hw_offload.setter
    def hw_offload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hw_offload", value)

    @property
    @pulumi.getter(name="icmpOptions")
    def icmp_options(self) -> Optional[pulumi.Input[str]]:
        """
        Matches ICMP type: code fields.
        """
        return pulumi.get(self, "icmp_options")

    @icmp_options.setter
    def icmp_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icmp_options", value)

    @property
    @pulumi.getter(name="inBridgePort")
    def in_bridge_port(self) -> Optional[pulumi.Input[str]]:
        """
        Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
        is enabled in bridge settings.
        """
        return pulumi.get(self, "in_bridge_port")

    @in_bridge_port.setter
    def in_bridge_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "in_bridge_port", value)

    @property
    @pulumi.getter(name="inBridgePortList")
    def in_bridge_port_list(self) -> Optional[pulumi.Input[str]]:
        """
        Set of interfaces defined in interface list. Works the same as in-bridge-port.
        """
        return pulumi.get(self, "in_bridge_port_list")

    @in_bridge_port_list.setter
    def in_bridge_port_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "in_bridge_port_list", value)

    @property
    @pulumi.getter(name="inInterface")
    def in_interface(self) -> Optional[pulumi.Input[str]]:
        """
        Interface the packet has entered the router.
        """
        return pulumi.get(self, "in_interface")

    @in_interface.setter
    def in_interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "in_interface", value)

    @property
    @pulumi.getter(name="inInterfaceList")
    def in_interface_list(self) -> Optional[pulumi.Input[str]]:
        """
        Set of interfaces defined in interface list. Works the same as in-interface.
        """
        return pulumi.get(self, "in_interface_list")

    @in_interface_list.setter
    def in_interface_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "in_interface_list", value)

    @property
    @pulumi.getter(name="ingressPriority")
    def ingress_priority(self) -> Optional[pulumi.Input[int]]:
        """
        Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
        """
        return pulumi.get(self, "ingress_priority")

    @ingress_priority.setter
    def ingress_priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ingress_priority", value)

    @property
    @pulumi.getter(name="ipsecPolicy")
    def ipsec_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Matches the policy used by IPsec. Value is written in the following format: direction, policy.
        """
        return pulumi.get(self, "ipsec_policy")

    @ipsec_policy.setter
    def ipsec_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipsec_policy", value)

    @property
    @pulumi.getter(name="ipv4Options")
    def ipv4_options(self) -> Optional[pulumi.Input[str]]:
        """
        Matches IPv4 header options.
        """
        return pulumi.get(self, "ipv4_options")

    @ipv4_options.setter
    def ipv4_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_options", value)

    @property
    @pulumi.getter(name="jumpTarget")
    def jump_target(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the target chain to jump to. Applicable only if action=jump.
        """
        return pulumi.get(self, "jump_target")

    @jump_target.setter
    def jump_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jump_target", value)

    @property
    @pulumi.getter(name="layer7Protocol")
    def layer7_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Layer7 filter name.
        """
        return pulumi.get(self, "layer7_protocol")

    @layer7_protocol.setter
    def layer7_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "layer7_protocol", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
        reached. Parameters are written in the following format: rate[/time],burst:mode.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def log(self) -> Optional[pulumi.Input[bool]]:
        """
        Add a message to the system log.
        """
        return pulumi.get(self, "log")

    @log.setter
    def log(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "log", value)

    @property
    @pulumi.getter(name="logPrefix")
    def log_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
        """
        return pulumi.get(self, "log_prefix")

    @log_prefix.setter
    def log_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_prefix", value)

    @property
    @pulumi.getter
    def nth(self) -> Optional[pulumi.Input[str]]:
        """
        Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
        by the rule
        """
        return pulumi.get(self, "nth")

    @nth.setter
    def nth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nth", value)

    @property
    @pulumi.getter(name="outBridgePort")
    def out_bridge_port(self) -> Optional[pulumi.Input[str]]:
        """
        Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
        is enabled in bridge settings.
        """
        return pulumi.get(self, "out_bridge_port")

    @out_bridge_port.setter
    def out_bridge_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "out_bridge_port", value)

    @property
    @pulumi.getter(name="outBridgePortList")
    def out_bridge_port_list(self) -> Optional[pulumi.Input[str]]:
        """
        Set of interfaces defined in interface list. Works the same as out-bridge-port.
        """
        return pulumi.get(self, "out_bridge_port_list")

    @out_bridge_port_list.setter
    def out_bridge_port_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "out_bridge_port_list", value)

    @property
    @pulumi.getter(name="outInterface")
    def out_interface(self) -> Optional[pulumi.Input[str]]:
        """
        Interface the packet is leaving the router.
        """
        return pulumi.get(self, "out_interface")

    @out_interface.setter
    def out_interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "out_interface", value)

    @property
    @pulumi.getter(name="outInterfaceList")
    def out_interface_list(self) -> Optional[pulumi.Input[str]]:
        """
        Set of interfaces defined in interface list. Works the same as out-interface.
        """
        return pulumi.get(self, "out_interface_list")

    @out_interface_list.setter
    def out_interface_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "out_interface_list", value)

    @property
    @pulumi.getter(name="packetMark")
    def packet_mark(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
        unmarked packet.
        """
        return pulumi.get(self, "packet_mark")

    @packet_mark.setter
    def packet_mark(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "packet_mark", value)

    @property
    @pulumi.getter(name="packetSize")
    def packet_size(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets of specified size or size range in bytes.
        """
        return pulumi.get(self, "packet_size")

    @packet_size.setter
    def packet_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "packet_size", value)

    @property
    @pulumi.getter(name="perConnectionClassifier")
    def per_connection_classifier(self) -> Optional[pulumi.Input[str]]:
        """
        PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
        in one particular stream.
        """
        return pulumi.get(self, "per_connection_classifier")

    @per_connection_classifier.setter
    def per_connection_classifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "per_connection_classifier", value)

    @property
    @pulumi.getter(name="placeBefore")
    def place_before(self) -> Optional[pulumi.Input[str]]:
        """
        Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
        think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
        """
        return pulumi.get(self, "place_before")

    @place_before.setter
    def place_before(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "place_before", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
        protocol is TCP or UDP
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP
        bit, or from the priority that has been set using the set-priority action.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Matches particular IP protocol specified by protocol name or number.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def psd(self) -> Optional[pulumi.Input[str]]:
        """
        Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
        LowPortWeight, HighPortWeight.
        """
        return pulumi.get(self, "psd")

    @psd.setter
    def psd(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "psd", value)

    @property
    @pulumi.getter
    def random(self) -> Optional[pulumi.Input[int]]:
        """
        Matches packets randomly with a given probability.
        """
        return pulumi.get(self, "random")

    @random.setter
    def random(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "random", value)

    @property
    @pulumi.getter(name="rejectWith")
    def reject_with(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.
        """
        return pulumi.get(self, "reject_with")

    @reject_with.setter
    def reject_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reject_with", value)

    @property
    @pulumi.getter(name="routingMark")
    def routing_mark(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets marked by mangle facility with particular routing mark.
        """
        return pulumi.get(self, "routing_mark")

    @routing_mark.setter
    def routing_mark(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing_mark", value)

    @property
    @pulumi.getter(name="routingTable")
    def routing_table(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets which destination address is resolved in specific a routing table.
        """
        return pulumi.get(self, "routing_table")

    @routing_table.setter
    def routing_table(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing_table", value)

    @property
    @pulumi.getter(name="srcAddress")
    def src_address(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets which source is equal to specified IP or falls into a specified IP range.
        """
        return pulumi.get(self, "src_address")

    @src_address.setter
    def src_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_address", value)

    @property
    @pulumi.getter(name="srcAddressList")
    def src_address_list(self) -> Optional[pulumi.Input[str]]:
        """
        Matches source address of a packet against user-defined address list.
        """
        return pulumi.get(self, "src_address_list")

    @src_address_list.setter
    def src_address_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_address_list", value)

    @property
    @pulumi.getter(name="srcAddressType")
    def src_address_type(self) -> Optional[pulumi.Input[str]]:
        """
        Matches source address type.
        """
        return pulumi.get(self, "src_address_type")

    @src_address_type.setter
    def src_address_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_address_type", value)

    @property
    @pulumi.getter(name="srcMacAddress")
    def src_mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        Matches source MAC address of the packet.
        """
        return pulumi.get(self, "src_mac_address")

    @src_mac_address.setter
    def src_mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_mac_address", value)

    @property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[pulumi.Input[str]]:
        """
        List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
        """
        return pulumi.get(self, "src_port")

    @src_port.setter
    def src_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_port", value)

    @property
    @pulumi.getter(name="tcpFlags")
    def tcp_flags(self) -> Optional[pulumi.Input[str]]:
        """
        Matches specified TCP flags.
        """
        return pulumi.get(self, "tcp_flags")

    @tcp_flags.setter
    def tcp_flags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tcp_flags", value)

    @property
    @pulumi.getter(name="tcpMss")
    def tcp_mss(self) -> Optional[pulumi.Input[str]]:
        """
        Matches TCP MSS value of an IP packet.
        """
        return pulumi.get(self, "tcp_mss")

    @tcp_mss.setter
    def tcp_mss(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tcp_mss", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[str]]:
        """
        Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
        and date.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter(name="tlsHost")
    def tls_host(self) -> Optional[pulumi.Input[str]]:
        """
        Allows matching HTTPS traffic based on TLS SNI hostname.
        """
        return pulumi.get(self, "tls_host")

    @tls_host.setter
    def tls_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_host", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets TTL value.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ttl", value)


@pulumi.input_type
class _IpFirewallFilterState:
    def __init__(__self__, *,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 action: Optional[pulumi.Input[str]] = None,
                 address_list_timeout: Optional[pulumi.Input[str]] = None,
                 bytes: Optional[pulumi.Input[int]] = None,
                 chain: Optional[pulumi.Input[str]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 connection_bytes: Optional[pulumi.Input[str]] = None,
                 connection_limit: Optional[pulumi.Input[str]] = None,
                 connection_mark: Optional[pulumi.Input[str]] = None,
                 connection_nat_state: Optional[pulumi.Input[str]] = None,
                 connection_rate: Optional[pulumi.Input[str]] = None,
                 connection_state: Optional[pulumi.Input[str]] = None,
                 connection_type: Optional[pulumi.Input[str]] = None,
                 content: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 dscp: Optional[pulumi.Input[int]] = None,
                 dst_address: Optional[pulumi.Input[str]] = None,
                 dst_address_list: Optional[pulumi.Input[str]] = None,
                 dst_address_type: Optional[pulumi.Input[str]] = None,
                 dst_limit: Optional[pulumi.Input[str]] = None,
                 dst_port: Optional[pulumi.Input[str]] = None,
                 dynamic: Optional[pulumi.Input[bool]] = None,
                 fragment: Optional[pulumi.Input[bool]] = None,
                 hotspot: Optional[pulumi.Input[str]] = None,
                 hw_offload: Optional[pulumi.Input[bool]] = None,
                 icmp_options: Optional[pulumi.Input[str]] = None,
                 in_bridge_port: Optional[pulumi.Input[str]] = None,
                 in_bridge_port_list: Optional[pulumi.Input[str]] = None,
                 in_interface: Optional[pulumi.Input[str]] = None,
                 in_interface_list: Optional[pulumi.Input[str]] = None,
                 ingress_priority: Optional[pulumi.Input[int]] = None,
                 invalid: Optional[pulumi.Input[bool]] = None,
                 ipsec_policy: Optional[pulumi.Input[str]] = None,
                 ipv4_options: Optional[pulumi.Input[str]] = None,
                 jump_target: Optional[pulumi.Input[str]] = None,
                 layer7_protocol: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[str]] = None,
                 log: Optional[pulumi.Input[bool]] = None,
                 log_prefix: Optional[pulumi.Input[str]] = None,
                 nth: Optional[pulumi.Input[str]] = None,
                 out_bridge_port: Optional[pulumi.Input[str]] = None,
                 out_bridge_port_list: Optional[pulumi.Input[str]] = None,
                 out_interface: Optional[pulumi.Input[str]] = None,
                 out_interface_list: Optional[pulumi.Input[str]] = None,
                 packet_mark: Optional[pulumi.Input[str]] = None,
                 packet_size: Optional[pulumi.Input[str]] = None,
                 packets: Optional[pulumi.Input[int]] = None,
                 per_connection_classifier: Optional[pulumi.Input[str]] = None,
                 place_before: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 psd: Optional[pulumi.Input[str]] = None,
                 random: Optional[pulumi.Input[int]] = None,
                 reject_with: Optional[pulumi.Input[str]] = None,
                 routing_mark: Optional[pulumi.Input[str]] = None,
                 routing_table: Optional[pulumi.Input[str]] = None,
                 src_address: Optional[pulumi.Input[str]] = None,
                 src_address_list: Optional[pulumi.Input[str]] = None,
                 src_address_type: Optional[pulumi.Input[str]] = None,
                 src_mac_address: Optional[pulumi.Input[str]] = None,
                 src_port: Optional[pulumi.Input[str]] = None,
                 tcp_flags: Optional[pulumi.Input[str]] = None,
                 tcp_mss: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input[str]] = None,
                 tls_host: Optional[pulumi.Input[str]] = None,
                 ttl: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering IpFirewallFilter resources.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] action: Action to take if a packet is matched by the rule
        :param pulumi.Input[str] address_list_timeout: Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
               conjunction with add-dst-to-address-list or add-src-to-address-list actions.
        :param pulumi.Input[int] bytes: The total amount of bytes matched by the rule.
        :param pulumi.Input[str] chain: Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
               chain will be created.
        :param pulumi.Input[str] connection_bytes: Matches packets only if a given amount of bytes has been transfered through the particular connection.
        :param pulumi.Input[str] connection_limit: Matches connections per address or address block after given value is reached. Should be used together with
               connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
        :param pulumi.Input[str] connection_mark: Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
               unmarked connection.
        :param pulumi.Input[str] connection_nat_state: Can match connections that are srcnatted, dstnatted or both.
        :param pulumi.Input[str] connection_rate: Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
               (0..4294967295).
        :param pulumi.Input[str] connection_state: Interprets the connection tracking analysis data for a particular packet.
        :param pulumi.Input[str] connection_type: Matches packets from related connections based on information from their connection tracking helpers.
        :param pulumi.Input[str] content: Match packets that contain specified text.
        :param pulumi.Input[int] dscp: Matches DSCP IP header field.
        :param pulumi.Input[str] dst_address: Matches packets which destination is equal to specified IP or falls into specified IP range.
        :param pulumi.Input[str] dst_address_list: Matches destination address of a packet against user-defined address list.
        :param pulumi.Input[str] dst_address_type: Matches destination address type.
        :param pulumi.Input[str] dst_limit: Matches packets until a given rate is exceeded.
        :param pulumi.Input[str] dst_port: List of destination port numbers or port number ranges.
        :param pulumi.Input[bool] dynamic: Configuration item created by software, not by management interface. It is not exported, and cannot be directly
               modified.
        :param pulumi.Input[bool] fragment: Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
               fragments as system automatically assembles every packet
        :param pulumi.Input[str] hotspot: Matches packets received from HotSpot clients against various HotSpot matchers.
        :param pulumi.Input[bool] hw_offload: Connection offloading for Fasttrack.
        :param pulumi.Input[str] icmp_options: Matches ICMP type: code fields.
        :param pulumi.Input[str] in_bridge_port: Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
               is enabled in bridge settings.
        :param pulumi.Input[str] in_bridge_port_list: Set of interfaces defined in interface list. Works the same as in-bridge-port.
        :param pulumi.Input[str] in_interface: Interface the packet has entered the router.
        :param pulumi.Input[str] in_interface_list: Set of interfaces defined in interface list. Works the same as in-interface.
        :param pulumi.Input[int] ingress_priority: Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
        :param pulumi.Input[str] ipsec_policy: Matches the policy used by IPsec. Value is written in the following format: direction, policy.
        :param pulumi.Input[str] ipv4_options: Matches IPv4 header options.
        :param pulumi.Input[str] jump_target: Name of the target chain to jump to. Applicable only if action=jump.
        :param pulumi.Input[str] layer7_protocol: Layer7 filter name.
        :param pulumi.Input[str] limit: Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
               reached. Parameters are written in the following format: rate[/time],burst:mode.
        :param pulumi.Input[bool] log: Add a message to the system log.
        :param pulumi.Input[str] log_prefix: Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
        :param pulumi.Input[str] nth: Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
               by the rule
        :param pulumi.Input[str] out_bridge_port: Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
               is enabled in bridge settings.
        :param pulumi.Input[str] out_bridge_port_list: Set of interfaces defined in interface list. Works the same as out-bridge-port.
        :param pulumi.Input[str] out_interface: Interface the packet is leaving the router.
        :param pulumi.Input[str] out_interface_list: Set of interfaces defined in interface list. Works the same as out-interface.
        :param pulumi.Input[str] packet_mark: Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
               unmarked packet.
        :param pulumi.Input[str] packet_size: Matches packets of specified size or size range in bytes.
        :param pulumi.Input[int] packets: The total amount of packets matched by the rule.
        :param pulumi.Input[str] per_connection_classifier: PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
               in one particular stream.
        :param pulumi.Input[str] place_before: Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
               think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
        :param pulumi.Input[str] port: Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
               protocol is TCP or UDP
        :param pulumi.Input[int] priority: Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP
               bit, or from the priority that has been set using the set-priority action.
        :param pulumi.Input[str] protocol: Matches particular IP protocol specified by protocol name or number.
        :param pulumi.Input[str] psd: Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
               LowPortWeight, HighPortWeight.
        :param pulumi.Input[int] random: Matches packets randomly with a given probability.
        :param pulumi.Input[str] reject_with: Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.
        :param pulumi.Input[str] routing_mark: Matches packets marked by mangle facility with particular routing mark.
        :param pulumi.Input[str] routing_table: Matches packets which destination address is resolved in specific a routing table.
        :param pulumi.Input[str] src_address: Matches packets which source is equal to specified IP or falls into a specified IP range.
        :param pulumi.Input[str] src_address_list: Matches source address of a packet against user-defined address list.
        :param pulumi.Input[str] src_address_type: Matches source address type.
        :param pulumi.Input[str] src_mac_address: Matches source MAC address of the packet.
        :param pulumi.Input[str] src_port: List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
        :param pulumi.Input[str] tcp_flags: Matches specified TCP flags.
        :param pulumi.Input[str] tcp_mss: Matches TCP MSS value of an IP packet.
        :param pulumi.Input[str] time: Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
               and date.
        :param pulumi.Input[str] tls_host: Allows matching HTTPS traffic based on TLS SNI hostname.
        :param pulumi.Input[str] ttl: Matches packets TTL value.
        """
        if ___id_ is not None:
            pulumi.set(__self__, "___id_", ___id_)
        if ___path_ is not None:
            pulumi.set(__self__, "___path_", ___path_)
        if action is not None:
            pulumi.set(__self__, "action", action)
        if address_list_timeout is not None:
            pulumi.set(__self__, "address_list_timeout", address_list_timeout)
        if bytes is not None:
            pulumi.set(__self__, "bytes", bytes)
        if chain is not None:
            pulumi.set(__self__, "chain", chain)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if connection_bytes is not None:
            pulumi.set(__self__, "connection_bytes", connection_bytes)
        if connection_limit is not None:
            pulumi.set(__self__, "connection_limit", connection_limit)
        if connection_mark is not None:
            pulumi.set(__self__, "connection_mark", connection_mark)
        if connection_nat_state is not None:
            pulumi.set(__self__, "connection_nat_state", connection_nat_state)
        if connection_rate is not None:
            pulumi.set(__self__, "connection_rate", connection_rate)
        if connection_state is not None:
            pulumi.set(__self__, "connection_state", connection_state)
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if dst_address is not None:
            pulumi.set(__self__, "dst_address", dst_address)
        if dst_address_list is not None:
            pulumi.set(__self__, "dst_address_list", dst_address_list)
        if dst_address_type is not None:
            pulumi.set(__self__, "dst_address_type", dst_address_type)
        if dst_limit is not None:
            pulumi.set(__self__, "dst_limit", dst_limit)
        if dst_port is not None:
            pulumi.set(__self__, "dst_port", dst_port)
        if dynamic is not None:
            pulumi.set(__self__, "dynamic", dynamic)
        if fragment is not None:
            pulumi.set(__self__, "fragment", fragment)
        if hotspot is not None:
            pulumi.set(__self__, "hotspot", hotspot)
        if hw_offload is not None:
            pulumi.set(__self__, "hw_offload", hw_offload)
        if icmp_options is not None:
            pulumi.set(__self__, "icmp_options", icmp_options)
        if in_bridge_port is not None:
            pulumi.set(__self__, "in_bridge_port", in_bridge_port)
        if in_bridge_port_list is not None:
            pulumi.set(__self__, "in_bridge_port_list", in_bridge_port_list)
        if in_interface is not None:
            pulumi.set(__self__, "in_interface", in_interface)
        if in_interface_list is not None:
            pulumi.set(__self__, "in_interface_list", in_interface_list)
        if ingress_priority is not None:
            pulumi.set(__self__, "ingress_priority", ingress_priority)
        if invalid is not None:
            pulumi.set(__self__, "invalid", invalid)
        if ipsec_policy is not None:
            pulumi.set(__self__, "ipsec_policy", ipsec_policy)
        if ipv4_options is not None:
            pulumi.set(__self__, "ipv4_options", ipv4_options)
        if jump_target is not None:
            pulumi.set(__self__, "jump_target", jump_target)
        if layer7_protocol is not None:
            pulumi.set(__self__, "layer7_protocol", layer7_protocol)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if log_prefix is not None:
            pulumi.set(__self__, "log_prefix", log_prefix)
        if nth is not None:
            pulumi.set(__self__, "nth", nth)
        if out_bridge_port is not None:
            pulumi.set(__self__, "out_bridge_port", out_bridge_port)
        if out_bridge_port_list is not None:
            pulumi.set(__self__, "out_bridge_port_list", out_bridge_port_list)
        if out_interface is not None:
            pulumi.set(__self__, "out_interface", out_interface)
        if out_interface_list is not None:
            pulumi.set(__self__, "out_interface_list", out_interface_list)
        if packet_mark is not None:
            pulumi.set(__self__, "packet_mark", packet_mark)
        if packet_size is not None:
            pulumi.set(__self__, "packet_size", packet_size)
        if packets is not None:
            pulumi.set(__self__, "packets", packets)
        if per_connection_classifier is not None:
            pulumi.set(__self__, "per_connection_classifier", per_connection_classifier)
        if place_before is not None:
            pulumi.set(__self__, "place_before", place_before)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if psd is not None:
            pulumi.set(__self__, "psd", psd)
        if random is not None:
            pulumi.set(__self__, "random", random)
        if reject_with is not None:
            pulumi.set(__self__, "reject_with", reject_with)
        if routing_mark is not None:
            pulumi.set(__self__, "routing_mark", routing_mark)
        if routing_table is not None:
            pulumi.set(__self__, "routing_table", routing_table)
        if src_address is not None:
            pulumi.set(__self__, "src_address", src_address)
        if src_address_list is not None:
            pulumi.set(__self__, "src_address_list", src_address_list)
        if src_address_type is not None:
            pulumi.set(__self__, "src_address_type", src_address_type)
        if src_mac_address is not None:
            pulumi.set(__self__, "src_mac_address", src_mac_address)
        if src_port is not None:
            pulumi.set(__self__, "src_port", src_port)
        if tcp_flags is not None:
            pulumi.set(__self__, "tcp_flags", tcp_flags)
        if tcp_mss is not None:
            pulumi.set(__self__, "tcp_mss", tcp_mss)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if tls_host is not None:
            pulumi.set(__self__, "tls_host", tls_host)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def ___id_(self) -> Optional[pulumi.Input[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @___id_.setter
    def ___id_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "___id_", value)

    @property
    @pulumi.getter
    def ___path_(self) -> Optional[pulumi.Input[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @___path_.setter
    def ___path_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "___path_", value)

    @property
    @pulumi.getter
    def action(self) -> Optional[pulumi.Input[str]]:
        """
        Action to take if a packet is matched by the rule
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="addressListTimeout")
    def address_list_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
        conjunction with add-dst-to-address-list or add-src-to-address-list actions.
        """
        return pulumi.get(self, "address_list_timeout")

    @address_list_timeout.setter
    def address_list_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_list_timeout", value)

    @property
    @pulumi.getter
    def bytes(self) -> Optional[pulumi.Input[int]]:
        """
        The total amount of bytes matched by the rule.
        """
        return pulumi.get(self, "bytes")

    @bytes.setter
    def bytes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bytes", value)

    @property
    @pulumi.getter
    def chain(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
        chain will be created.
        """
        return pulumi.get(self, "chain")

    @chain.setter
    def chain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chain", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="connectionBytes")
    def connection_bytes(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets only if a given amount of bytes has been transfered through the particular connection.
        """
        return pulumi.get(self, "connection_bytes")

    @connection_bytes.setter
    def connection_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_bytes", value)

    @property
    @pulumi.getter(name="connectionLimit")
    def connection_limit(self) -> Optional[pulumi.Input[str]]:
        """
        Matches connections per address or address block after given value is reached. Should be used together with
        connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
        """
        return pulumi.get(self, "connection_limit")

    @connection_limit.setter
    def connection_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_limit", value)

    @property
    @pulumi.getter(name="connectionMark")
    def connection_mark(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
        unmarked connection.
        """
        return pulumi.get(self, "connection_mark")

    @connection_mark.setter
    def connection_mark(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_mark", value)

    @property
    @pulumi.getter(name="connectionNatState")
    def connection_nat_state(self) -> Optional[pulumi.Input[str]]:
        """
        Can match connections that are srcnatted, dstnatted or both.
        """
        return pulumi.get(self, "connection_nat_state")

    @connection_nat_state.setter
    def connection_nat_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_nat_state", value)

    @property
    @pulumi.getter(name="connectionRate")
    def connection_rate(self) -> Optional[pulumi.Input[str]]:
        """
        Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
        (0..4294967295).
        """
        return pulumi.get(self, "connection_rate")

    @connection_rate.setter
    def connection_rate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_rate", value)

    @property
    @pulumi.getter(name="connectionState")
    def connection_state(self) -> Optional[pulumi.Input[str]]:
        """
        Interprets the connection tracking analysis data for a particular packet.
        """
        return pulumi.get(self, "connection_state")

    @connection_state.setter
    def connection_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_state", value)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets from related connections based on information from their connection tracking helpers.
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_type", value)

    @property
    @pulumi.getter
    def content(self) -> Optional[pulumi.Input[str]]:
        """
        Match packets that contain specified text.
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def dscp(self) -> Optional[pulumi.Input[int]]:
        """
        Matches DSCP IP header field.
        """
        return pulumi.get(self, "dscp")

    @dscp.setter
    def dscp(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "dscp", value)

    @property
    @pulumi.getter(name="dstAddress")
    def dst_address(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets which destination is equal to specified IP or falls into specified IP range.
        """
        return pulumi.get(self, "dst_address")

    @dst_address.setter
    def dst_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dst_address", value)

    @property
    @pulumi.getter(name="dstAddressList")
    def dst_address_list(self) -> Optional[pulumi.Input[str]]:
        """
        Matches destination address of a packet against user-defined address list.
        """
        return pulumi.get(self, "dst_address_list")

    @dst_address_list.setter
    def dst_address_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dst_address_list", value)

    @property
    @pulumi.getter(name="dstAddressType")
    def dst_address_type(self) -> Optional[pulumi.Input[str]]:
        """
        Matches destination address type.
        """
        return pulumi.get(self, "dst_address_type")

    @dst_address_type.setter
    def dst_address_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dst_address_type", value)

    @property
    @pulumi.getter(name="dstLimit")
    def dst_limit(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets until a given rate is exceeded.
        """
        return pulumi.get(self, "dst_limit")

    @dst_limit.setter
    def dst_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dst_limit", value)

    @property
    @pulumi.getter(name="dstPort")
    def dst_port(self) -> Optional[pulumi.Input[str]]:
        """
        List of destination port numbers or port number ranges.
        """
        return pulumi.get(self, "dst_port")

    @dst_port.setter
    def dst_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dst_port", value)

    @property
    @pulumi.getter
    def dynamic(self) -> Optional[pulumi.Input[bool]]:
        """
        Configuration item created by software, not by management interface. It is not exported, and cannot be directly
        modified.
        """
        return pulumi.get(self, "dynamic")

    @dynamic.setter
    def dynamic(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dynamic", value)

    @property
    @pulumi.getter
    def fragment(self) -> Optional[pulumi.Input[bool]]:
        """
        Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
        fragments as system automatically assembles every packet
        """
        return pulumi.get(self, "fragment")

    @fragment.setter
    def fragment(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "fragment", value)

    @property
    @pulumi.getter
    def hotspot(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets received from HotSpot clients against various HotSpot matchers.
        """
        return pulumi.get(self, "hotspot")

    @hotspot.setter
    def hotspot(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hotspot", value)

    @property
    @pulumi.getter(name="hwOffload")
    def hw_offload(self) -> Optional[pulumi.Input[bool]]:
        """
        Connection offloading for Fasttrack.
        """
        return pulumi.get(self, "hw_offload")

    @hw_offload.setter
    def hw_offload(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hw_offload", value)

    @property
    @pulumi.getter(name="icmpOptions")
    def icmp_options(self) -> Optional[pulumi.Input[str]]:
        """
        Matches ICMP type: code fields.
        """
        return pulumi.get(self, "icmp_options")

    @icmp_options.setter
    def icmp_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "icmp_options", value)

    @property
    @pulumi.getter(name="inBridgePort")
    def in_bridge_port(self) -> Optional[pulumi.Input[str]]:
        """
        Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
        is enabled in bridge settings.
        """
        return pulumi.get(self, "in_bridge_port")

    @in_bridge_port.setter
    def in_bridge_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "in_bridge_port", value)

    @property
    @pulumi.getter(name="inBridgePortList")
    def in_bridge_port_list(self) -> Optional[pulumi.Input[str]]:
        """
        Set of interfaces defined in interface list. Works the same as in-bridge-port.
        """
        return pulumi.get(self, "in_bridge_port_list")

    @in_bridge_port_list.setter
    def in_bridge_port_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "in_bridge_port_list", value)

    @property
    @pulumi.getter(name="inInterface")
    def in_interface(self) -> Optional[pulumi.Input[str]]:
        """
        Interface the packet has entered the router.
        """
        return pulumi.get(self, "in_interface")

    @in_interface.setter
    def in_interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "in_interface", value)

    @property
    @pulumi.getter(name="inInterfaceList")
    def in_interface_list(self) -> Optional[pulumi.Input[str]]:
        """
        Set of interfaces defined in interface list. Works the same as in-interface.
        """
        return pulumi.get(self, "in_interface_list")

    @in_interface_list.setter
    def in_interface_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "in_interface_list", value)

    @property
    @pulumi.getter(name="ingressPriority")
    def ingress_priority(self) -> Optional[pulumi.Input[int]]:
        """
        Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
        """
        return pulumi.get(self, "ingress_priority")

    @ingress_priority.setter
    def ingress_priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ingress_priority", value)

    @property
    @pulumi.getter
    def invalid(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "invalid")

    @invalid.setter
    def invalid(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "invalid", value)

    @property
    @pulumi.getter(name="ipsecPolicy")
    def ipsec_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Matches the policy used by IPsec. Value is written in the following format: direction, policy.
        """
        return pulumi.get(self, "ipsec_policy")

    @ipsec_policy.setter
    def ipsec_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipsec_policy", value)

    @property
    @pulumi.getter(name="ipv4Options")
    def ipv4_options(self) -> Optional[pulumi.Input[str]]:
        """
        Matches IPv4 header options.
        """
        return pulumi.get(self, "ipv4_options")

    @ipv4_options.setter
    def ipv4_options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4_options", value)

    @property
    @pulumi.getter(name="jumpTarget")
    def jump_target(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the target chain to jump to. Applicable only if action=jump.
        """
        return pulumi.get(self, "jump_target")

    @jump_target.setter
    def jump_target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "jump_target", value)

    @property
    @pulumi.getter(name="layer7Protocol")
    def layer7_protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Layer7 filter name.
        """
        return pulumi.get(self, "layer7_protocol")

    @layer7_protocol.setter
    def layer7_protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "layer7_protocol", value)

    @property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
        reached. Parameters are written in the following format: rate[/time],burst:mode.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "limit", value)

    @property
    @pulumi.getter
    def log(self) -> Optional[pulumi.Input[bool]]:
        """
        Add a message to the system log.
        """
        return pulumi.get(self, "log")

    @log.setter
    def log(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "log", value)

    @property
    @pulumi.getter(name="logPrefix")
    def log_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
        """
        return pulumi.get(self, "log_prefix")

    @log_prefix.setter
    def log_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_prefix", value)

    @property
    @pulumi.getter
    def nth(self) -> Optional[pulumi.Input[str]]:
        """
        Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
        by the rule
        """
        return pulumi.get(self, "nth")

    @nth.setter
    def nth(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "nth", value)

    @property
    @pulumi.getter(name="outBridgePort")
    def out_bridge_port(self) -> Optional[pulumi.Input[str]]:
        """
        Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
        is enabled in bridge settings.
        """
        return pulumi.get(self, "out_bridge_port")

    @out_bridge_port.setter
    def out_bridge_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "out_bridge_port", value)

    @property
    @pulumi.getter(name="outBridgePortList")
    def out_bridge_port_list(self) -> Optional[pulumi.Input[str]]:
        """
        Set of interfaces defined in interface list. Works the same as out-bridge-port.
        """
        return pulumi.get(self, "out_bridge_port_list")

    @out_bridge_port_list.setter
    def out_bridge_port_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "out_bridge_port_list", value)

    @property
    @pulumi.getter(name="outInterface")
    def out_interface(self) -> Optional[pulumi.Input[str]]:
        """
        Interface the packet is leaving the router.
        """
        return pulumi.get(self, "out_interface")

    @out_interface.setter
    def out_interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "out_interface", value)

    @property
    @pulumi.getter(name="outInterfaceList")
    def out_interface_list(self) -> Optional[pulumi.Input[str]]:
        """
        Set of interfaces defined in interface list. Works the same as out-interface.
        """
        return pulumi.get(self, "out_interface_list")

    @out_interface_list.setter
    def out_interface_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "out_interface_list", value)

    @property
    @pulumi.getter(name="packetMark")
    def packet_mark(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
        unmarked packet.
        """
        return pulumi.get(self, "packet_mark")

    @packet_mark.setter
    def packet_mark(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "packet_mark", value)

    @property
    @pulumi.getter(name="packetSize")
    def packet_size(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets of specified size or size range in bytes.
        """
        return pulumi.get(self, "packet_size")

    @packet_size.setter
    def packet_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "packet_size", value)

    @property
    @pulumi.getter
    def packets(self) -> Optional[pulumi.Input[int]]:
        """
        The total amount of packets matched by the rule.
        """
        return pulumi.get(self, "packets")

    @packets.setter
    def packets(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "packets", value)

    @property
    @pulumi.getter(name="perConnectionClassifier")
    def per_connection_classifier(self) -> Optional[pulumi.Input[str]]:
        """
        PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
        in one particular stream.
        """
        return pulumi.get(self, "per_connection_classifier")

    @per_connection_classifier.setter
    def per_connection_classifier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "per_connection_classifier", value)

    @property
    @pulumi.getter(name="placeBefore")
    def place_before(self) -> Optional[pulumi.Input[str]]:
        """
        Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
        think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
        """
        return pulumi.get(self, "place_before")

    @place_before.setter
    def place_before(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "place_before", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
        protocol is TCP or UDP
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP
        bit, or from the priority that has been set using the set-priority action.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Matches particular IP protocol specified by protocol name or number.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def psd(self) -> Optional[pulumi.Input[str]]:
        """
        Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
        LowPortWeight, HighPortWeight.
        """
        return pulumi.get(self, "psd")

    @psd.setter
    def psd(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "psd", value)

    @property
    @pulumi.getter
    def random(self) -> Optional[pulumi.Input[int]]:
        """
        Matches packets randomly with a given probability.
        """
        return pulumi.get(self, "random")

    @random.setter
    def random(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "random", value)

    @property
    @pulumi.getter(name="rejectWith")
    def reject_with(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.
        """
        return pulumi.get(self, "reject_with")

    @reject_with.setter
    def reject_with(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reject_with", value)

    @property
    @pulumi.getter(name="routingMark")
    def routing_mark(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets marked by mangle facility with particular routing mark.
        """
        return pulumi.get(self, "routing_mark")

    @routing_mark.setter
    def routing_mark(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing_mark", value)

    @property
    @pulumi.getter(name="routingTable")
    def routing_table(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets which destination address is resolved in specific a routing table.
        """
        return pulumi.get(self, "routing_table")

    @routing_table.setter
    def routing_table(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing_table", value)

    @property
    @pulumi.getter(name="srcAddress")
    def src_address(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets which source is equal to specified IP or falls into a specified IP range.
        """
        return pulumi.get(self, "src_address")

    @src_address.setter
    def src_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_address", value)

    @property
    @pulumi.getter(name="srcAddressList")
    def src_address_list(self) -> Optional[pulumi.Input[str]]:
        """
        Matches source address of a packet against user-defined address list.
        """
        return pulumi.get(self, "src_address_list")

    @src_address_list.setter
    def src_address_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_address_list", value)

    @property
    @pulumi.getter(name="srcAddressType")
    def src_address_type(self) -> Optional[pulumi.Input[str]]:
        """
        Matches source address type.
        """
        return pulumi.get(self, "src_address_type")

    @src_address_type.setter
    def src_address_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_address_type", value)

    @property
    @pulumi.getter(name="srcMacAddress")
    def src_mac_address(self) -> Optional[pulumi.Input[str]]:
        """
        Matches source MAC address of the packet.
        """
        return pulumi.get(self, "src_mac_address")

    @src_mac_address.setter
    def src_mac_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_mac_address", value)

    @property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> Optional[pulumi.Input[str]]:
        """
        List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
        """
        return pulumi.get(self, "src_port")

    @src_port.setter
    def src_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "src_port", value)

    @property
    @pulumi.getter(name="tcpFlags")
    def tcp_flags(self) -> Optional[pulumi.Input[str]]:
        """
        Matches specified TCP flags.
        """
        return pulumi.get(self, "tcp_flags")

    @tcp_flags.setter
    def tcp_flags(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tcp_flags", value)

    @property
    @pulumi.getter(name="tcpMss")
    def tcp_mss(self) -> Optional[pulumi.Input[str]]:
        """
        Matches TCP MSS value of an IP packet.
        """
        return pulumi.get(self, "tcp_mss")

    @tcp_mss.setter
    def tcp_mss(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tcp_mss", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[str]]:
        """
        Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
        and date.
        """
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time", value)

    @property
    @pulumi.getter(name="tlsHost")
    def tls_host(self) -> Optional[pulumi.Input[str]]:
        """
        Allows matching HTTPS traffic based on TLS SNI hostname.
        """
        return pulumi.get(self, "tls_host")

    @tls_host.setter
    def tls_host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tls_host", value)

    @property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[str]]:
        """
        Matches packets TTL value.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ttl", value)


class IpFirewallFilter(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 action: Optional[pulumi.Input[str]] = None,
                 address_list_timeout: Optional[pulumi.Input[str]] = None,
                 chain: Optional[pulumi.Input[str]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 connection_bytes: Optional[pulumi.Input[str]] = None,
                 connection_limit: Optional[pulumi.Input[str]] = None,
                 connection_mark: Optional[pulumi.Input[str]] = None,
                 connection_nat_state: Optional[pulumi.Input[str]] = None,
                 connection_rate: Optional[pulumi.Input[str]] = None,
                 connection_state: Optional[pulumi.Input[str]] = None,
                 connection_type: Optional[pulumi.Input[str]] = None,
                 content: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 dscp: Optional[pulumi.Input[int]] = None,
                 dst_address: Optional[pulumi.Input[str]] = None,
                 dst_address_list: Optional[pulumi.Input[str]] = None,
                 dst_address_type: Optional[pulumi.Input[str]] = None,
                 dst_limit: Optional[pulumi.Input[str]] = None,
                 dst_port: Optional[pulumi.Input[str]] = None,
                 fragment: Optional[pulumi.Input[bool]] = None,
                 hotspot: Optional[pulumi.Input[str]] = None,
                 hw_offload: Optional[pulumi.Input[bool]] = None,
                 icmp_options: Optional[pulumi.Input[str]] = None,
                 in_bridge_port: Optional[pulumi.Input[str]] = None,
                 in_bridge_port_list: Optional[pulumi.Input[str]] = None,
                 in_interface: Optional[pulumi.Input[str]] = None,
                 in_interface_list: Optional[pulumi.Input[str]] = None,
                 ingress_priority: Optional[pulumi.Input[int]] = None,
                 ipsec_policy: Optional[pulumi.Input[str]] = None,
                 ipv4_options: Optional[pulumi.Input[str]] = None,
                 jump_target: Optional[pulumi.Input[str]] = None,
                 layer7_protocol: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[str]] = None,
                 log: Optional[pulumi.Input[bool]] = None,
                 log_prefix: Optional[pulumi.Input[str]] = None,
                 nth: Optional[pulumi.Input[str]] = None,
                 out_bridge_port: Optional[pulumi.Input[str]] = None,
                 out_bridge_port_list: Optional[pulumi.Input[str]] = None,
                 out_interface: Optional[pulumi.Input[str]] = None,
                 out_interface_list: Optional[pulumi.Input[str]] = None,
                 packet_mark: Optional[pulumi.Input[str]] = None,
                 packet_size: Optional[pulumi.Input[str]] = None,
                 per_connection_classifier: Optional[pulumi.Input[str]] = None,
                 place_before: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 psd: Optional[pulumi.Input[str]] = None,
                 random: Optional[pulumi.Input[int]] = None,
                 reject_with: Optional[pulumi.Input[str]] = None,
                 routing_mark: Optional[pulumi.Input[str]] = None,
                 routing_table: Optional[pulumi.Input[str]] = None,
                 src_address: Optional[pulumi.Input[str]] = None,
                 src_address_list: Optional[pulumi.Input[str]] = None,
                 src_address_type: Optional[pulumi.Input[str]] = None,
                 src_mac_address: Optional[pulumi.Input[str]] = None,
                 src_port: Optional[pulumi.Input[str]] = None,
                 tcp_flags: Optional[pulumi.Input[str]] = None,
                 tcp_mss: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input[str]] = None,
                 tls_host: Optional[pulumi.Input[str]] = None,
                 ttl: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        ## Example Usage

        ```python
        import pulumi
        import pulumi_routeros as routeros

        rule = routeros.ip.IpFirewallFilter("rule",
            action="accept",
            chain="forward",
            dst_address="10.0.1.1",
            dst_port="443",
            protocol="tcp",
            src_address="10.0.0.1")
        ```

        ## Import

        #The ID can be found via API or the terminal #The command for the terminal is -> :put [/ip/firewall/filter get [print show-ids]]

        ```sh
         $ pulumi import routeros:Ip/ipFirewallFilter:IpFirewallFilter rule "*0"
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] action: Action to take if a packet is matched by the rule
        :param pulumi.Input[str] address_list_timeout: Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
               conjunction with add-dst-to-address-list or add-src-to-address-list actions.
        :param pulumi.Input[str] chain: Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
               chain will be created.
        :param pulumi.Input[str] connection_bytes: Matches packets only if a given amount of bytes has been transfered through the particular connection.
        :param pulumi.Input[str] connection_limit: Matches connections per address or address block after given value is reached. Should be used together with
               connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
        :param pulumi.Input[str] connection_mark: Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
               unmarked connection.
        :param pulumi.Input[str] connection_nat_state: Can match connections that are srcnatted, dstnatted or both.
        :param pulumi.Input[str] connection_rate: Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
               (0..4294967295).
        :param pulumi.Input[str] connection_state: Interprets the connection tracking analysis data for a particular packet.
        :param pulumi.Input[str] connection_type: Matches packets from related connections based on information from their connection tracking helpers.
        :param pulumi.Input[str] content: Match packets that contain specified text.
        :param pulumi.Input[int] dscp: Matches DSCP IP header field.
        :param pulumi.Input[str] dst_address: Matches packets which destination is equal to specified IP or falls into specified IP range.
        :param pulumi.Input[str] dst_address_list: Matches destination address of a packet against user-defined address list.
        :param pulumi.Input[str] dst_address_type: Matches destination address type.
        :param pulumi.Input[str] dst_limit: Matches packets until a given rate is exceeded.
        :param pulumi.Input[str] dst_port: List of destination port numbers or port number ranges.
        :param pulumi.Input[bool] fragment: Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
               fragments as system automatically assembles every packet
        :param pulumi.Input[str] hotspot: Matches packets received from HotSpot clients against various HotSpot matchers.
        :param pulumi.Input[bool] hw_offload: Connection offloading for Fasttrack.
        :param pulumi.Input[str] icmp_options: Matches ICMP type: code fields.
        :param pulumi.Input[str] in_bridge_port: Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
               is enabled in bridge settings.
        :param pulumi.Input[str] in_bridge_port_list: Set of interfaces defined in interface list. Works the same as in-bridge-port.
        :param pulumi.Input[str] in_interface: Interface the packet has entered the router.
        :param pulumi.Input[str] in_interface_list: Set of interfaces defined in interface list. Works the same as in-interface.
        :param pulumi.Input[int] ingress_priority: Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
        :param pulumi.Input[str] ipsec_policy: Matches the policy used by IPsec. Value is written in the following format: direction, policy.
        :param pulumi.Input[str] ipv4_options: Matches IPv4 header options.
        :param pulumi.Input[str] jump_target: Name of the target chain to jump to. Applicable only if action=jump.
        :param pulumi.Input[str] layer7_protocol: Layer7 filter name.
        :param pulumi.Input[str] limit: Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
               reached. Parameters are written in the following format: rate[/time],burst:mode.
        :param pulumi.Input[bool] log: Add a message to the system log.
        :param pulumi.Input[str] log_prefix: Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
        :param pulumi.Input[str] nth: Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
               by the rule
        :param pulumi.Input[str] out_bridge_port: Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
               is enabled in bridge settings.
        :param pulumi.Input[str] out_bridge_port_list: Set of interfaces defined in interface list. Works the same as out-bridge-port.
        :param pulumi.Input[str] out_interface: Interface the packet is leaving the router.
        :param pulumi.Input[str] out_interface_list: Set of interfaces defined in interface list. Works the same as out-interface.
        :param pulumi.Input[str] packet_mark: Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
               unmarked packet.
        :param pulumi.Input[str] packet_size: Matches packets of specified size or size range in bytes.
        :param pulumi.Input[str] per_connection_classifier: PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
               in one particular stream.
        :param pulumi.Input[str] place_before: Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
               think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
        :param pulumi.Input[str] port: Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
               protocol is TCP or UDP
        :param pulumi.Input[int] priority: Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP
               bit, or from the priority that has been set using the set-priority action.
        :param pulumi.Input[str] protocol: Matches particular IP protocol specified by protocol name or number.
        :param pulumi.Input[str] psd: Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
               LowPortWeight, HighPortWeight.
        :param pulumi.Input[int] random: Matches packets randomly with a given probability.
        :param pulumi.Input[str] reject_with: Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.
        :param pulumi.Input[str] routing_mark: Matches packets marked by mangle facility with particular routing mark.
        :param pulumi.Input[str] routing_table: Matches packets which destination address is resolved in specific a routing table.
        :param pulumi.Input[str] src_address: Matches packets which source is equal to specified IP or falls into a specified IP range.
        :param pulumi.Input[str] src_address_list: Matches source address of a packet against user-defined address list.
        :param pulumi.Input[str] src_address_type: Matches source address type.
        :param pulumi.Input[str] src_mac_address: Matches source MAC address of the packet.
        :param pulumi.Input[str] src_port: List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
        :param pulumi.Input[str] tcp_flags: Matches specified TCP flags.
        :param pulumi.Input[str] tcp_mss: Matches TCP MSS value of an IP packet.
        :param pulumi.Input[str] time: Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
               and date.
        :param pulumi.Input[str] tls_host: Allows matching HTTPS traffic based on TLS SNI hostname.
        :param pulumi.Input[str] ttl: Matches packets TTL value.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: IpFirewallFilterArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## Example Usage

        ```python
        import pulumi
        import pulumi_routeros as routeros

        rule = routeros.ip.IpFirewallFilter("rule",
            action="accept",
            chain="forward",
            dst_address="10.0.1.1",
            dst_port="443",
            protocol="tcp",
            src_address="10.0.0.1")
        ```

        ## Import

        #The ID can be found via API or the terminal #The command for the terminal is -> :put [/ip/firewall/filter get [print show-ids]]

        ```sh
         $ pulumi import routeros:Ip/ipFirewallFilter:IpFirewallFilter rule "*0"
        ```

        :param str resource_name: The name of the resource.
        :param IpFirewallFilterArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(IpFirewallFilterArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 action: Optional[pulumi.Input[str]] = None,
                 address_list_timeout: Optional[pulumi.Input[str]] = None,
                 chain: Optional[pulumi.Input[str]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 connection_bytes: Optional[pulumi.Input[str]] = None,
                 connection_limit: Optional[pulumi.Input[str]] = None,
                 connection_mark: Optional[pulumi.Input[str]] = None,
                 connection_nat_state: Optional[pulumi.Input[str]] = None,
                 connection_rate: Optional[pulumi.Input[str]] = None,
                 connection_state: Optional[pulumi.Input[str]] = None,
                 connection_type: Optional[pulumi.Input[str]] = None,
                 content: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 dscp: Optional[pulumi.Input[int]] = None,
                 dst_address: Optional[pulumi.Input[str]] = None,
                 dst_address_list: Optional[pulumi.Input[str]] = None,
                 dst_address_type: Optional[pulumi.Input[str]] = None,
                 dst_limit: Optional[pulumi.Input[str]] = None,
                 dst_port: Optional[pulumi.Input[str]] = None,
                 fragment: Optional[pulumi.Input[bool]] = None,
                 hotspot: Optional[pulumi.Input[str]] = None,
                 hw_offload: Optional[pulumi.Input[bool]] = None,
                 icmp_options: Optional[pulumi.Input[str]] = None,
                 in_bridge_port: Optional[pulumi.Input[str]] = None,
                 in_bridge_port_list: Optional[pulumi.Input[str]] = None,
                 in_interface: Optional[pulumi.Input[str]] = None,
                 in_interface_list: Optional[pulumi.Input[str]] = None,
                 ingress_priority: Optional[pulumi.Input[int]] = None,
                 ipsec_policy: Optional[pulumi.Input[str]] = None,
                 ipv4_options: Optional[pulumi.Input[str]] = None,
                 jump_target: Optional[pulumi.Input[str]] = None,
                 layer7_protocol: Optional[pulumi.Input[str]] = None,
                 limit: Optional[pulumi.Input[str]] = None,
                 log: Optional[pulumi.Input[bool]] = None,
                 log_prefix: Optional[pulumi.Input[str]] = None,
                 nth: Optional[pulumi.Input[str]] = None,
                 out_bridge_port: Optional[pulumi.Input[str]] = None,
                 out_bridge_port_list: Optional[pulumi.Input[str]] = None,
                 out_interface: Optional[pulumi.Input[str]] = None,
                 out_interface_list: Optional[pulumi.Input[str]] = None,
                 packet_mark: Optional[pulumi.Input[str]] = None,
                 packet_size: Optional[pulumi.Input[str]] = None,
                 per_connection_classifier: Optional[pulumi.Input[str]] = None,
                 place_before: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 psd: Optional[pulumi.Input[str]] = None,
                 random: Optional[pulumi.Input[int]] = None,
                 reject_with: Optional[pulumi.Input[str]] = None,
                 routing_mark: Optional[pulumi.Input[str]] = None,
                 routing_table: Optional[pulumi.Input[str]] = None,
                 src_address: Optional[pulumi.Input[str]] = None,
                 src_address_list: Optional[pulumi.Input[str]] = None,
                 src_address_type: Optional[pulumi.Input[str]] = None,
                 src_mac_address: Optional[pulumi.Input[str]] = None,
                 src_port: Optional[pulumi.Input[str]] = None,
                 tcp_flags: Optional[pulumi.Input[str]] = None,
                 tcp_mss: Optional[pulumi.Input[str]] = None,
                 time: Optional[pulumi.Input[str]] = None,
                 tls_host: Optional[pulumi.Input[str]] = None,
                 ttl: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = IpFirewallFilterArgs.__new__(IpFirewallFilterArgs)

            __props__.__dict__["___id_"] = ___id_
            __props__.__dict__["___path_"] = ___path_
            if action is None and not opts.urn:
                raise TypeError("Missing required property 'action'")
            __props__.__dict__["action"] = action
            __props__.__dict__["address_list_timeout"] = address_list_timeout
            if chain is None and not opts.urn:
                raise TypeError("Missing required property 'chain'")
            __props__.__dict__["chain"] = chain
            __props__.__dict__["comment"] = comment
            __props__.__dict__["connection_bytes"] = connection_bytes
            __props__.__dict__["connection_limit"] = connection_limit
            __props__.__dict__["connection_mark"] = connection_mark
            __props__.__dict__["connection_nat_state"] = connection_nat_state
            __props__.__dict__["connection_rate"] = connection_rate
            __props__.__dict__["connection_state"] = connection_state
            __props__.__dict__["connection_type"] = connection_type
            __props__.__dict__["content"] = content
            __props__.__dict__["disabled"] = disabled
            __props__.__dict__["dscp"] = dscp
            __props__.__dict__["dst_address"] = dst_address
            __props__.__dict__["dst_address_list"] = dst_address_list
            __props__.__dict__["dst_address_type"] = dst_address_type
            __props__.__dict__["dst_limit"] = dst_limit
            __props__.__dict__["dst_port"] = dst_port
            __props__.__dict__["fragment"] = fragment
            __props__.__dict__["hotspot"] = hotspot
            __props__.__dict__["hw_offload"] = hw_offload
            __props__.__dict__["icmp_options"] = icmp_options
            __props__.__dict__["in_bridge_port"] = in_bridge_port
            __props__.__dict__["in_bridge_port_list"] = in_bridge_port_list
            __props__.__dict__["in_interface"] = in_interface
            __props__.__dict__["in_interface_list"] = in_interface_list
            __props__.__dict__["ingress_priority"] = ingress_priority
            __props__.__dict__["ipsec_policy"] = ipsec_policy
            __props__.__dict__["ipv4_options"] = ipv4_options
            __props__.__dict__["jump_target"] = jump_target
            __props__.__dict__["layer7_protocol"] = layer7_protocol
            __props__.__dict__["limit"] = limit
            __props__.__dict__["log"] = log
            __props__.__dict__["log_prefix"] = log_prefix
            __props__.__dict__["nth"] = nth
            __props__.__dict__["out_bridge_port"] = out_bridge_port
            __props__.__dict__["out_bridge_port_list"] = out_bridge_port_list
            __props__.__dict__["out_interface"] = out_interface
            __props__.__dict__["out_interface_list"] = out_interface_list
            __props__.__dict__["packet_mark"] = packet_mark
            __props__.__dict__["packet_size"] = packet_size
            __props__.__dict__["per_connection_classifier"] = per_connection_classifier
            __props__.__dict__["place_before"] = place_before
            __props__.__dict__["port"] = port
            __props__.__dict__["priority"] = priority
            __props__.__dict__["protocol"] = protocol
            __props__.__dict__["psd"] = psd
            __props__.__dict__["random"] = random
            __props__.__dict__["reject_with"] = reject_with
            __props__.__dict__["routing_mark"] = routing_mark
            __props__.__dict__["routing_table"] = routing_table
            __props__.__dict__["src_address"] = src_address
            __props__.__dict__["src_address_list"] = src_address_list
            __props__.__dict__["src_address_type"] = src_address_type
            __props__.__dict__["src_mac_address"] = src_mac_address
            __props__.__dict__["src_port"] = src_port
            __props__.__dict__["tcp_flags"] = tcp_flags
            __props__.__dict__["tcp_mss"] = tcp_mss
            __props__.__dict__["time"] = time
            __props__.__dict__["tls_host"] = tls_host
            __props__.__dict__["ttl"] = ttl
            __props__.__dict__["bytes"] = None
            __props__.__dict__["dynamic"] = None
            __props__.__dict__["invalid"] = None
            __props__.__dict__["packets"] = None
        super(IpFirewallFilter, __self__).__init__(
            'routeros:Ip/ipFirewallFilter:IpFirewallFilter',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            ___id_: Optional[pulumi.Input[int]] = None,
            ___path_: Optional[pulumi.Input[str]] = None,
            action: Optional[pulumi.Input[str]] = None,
            address_list_timeout: Optional[pulumi.Input[str]] = None,
            bytes: Optional[pulumi.Input[int]] = None,
            chain: Optional[pulumi.Input[str]] = None,
            comment: Optional[pulumi.Input[str]] = None,
            connection_bytes: Optional[pulumi.Input[str]] = None,
            connection_limit: Optional[pulumi.Input[str]] = None,
            connection_mark: Optional[pulumi.Input[str]] = None,
            connection_nat_state: Optional[pulumi.Input[str]] = None,
            connection_rate: Optional[pulumi.Input[str]] = None,
            connection_state: Optional[pulumi.Input[str]] = None,
            connection_type: Optional[pulumi.Input[str]] = None,
            content: Optional[pulumi.Input[str]] = None,
            disabled: Optional[pulumi.Input[bool]] = None,
            dscp: Optional[pulumi.Input[int]] = None,
            dst_address: Optional[pulumi.Input[str]] = None,
            dst_address_list: Optional[pulumi.Input[str]] = None,
            dst_address_type: Optional[pulumi.Input[str]] = None,
            dst_limit: Optional[pulumi.Input[str]] = None,
            dst_port: Optional[pulumi.Input[str]] = None,
            dynamic: Optional[pulumi.Input[bool]] = None,
            fragment: Optional[pulumi.Input[bool]] = None,
            hotspot: Optional[pulumi.Input[str]] = None,
            hw_offload: Optional[pulumi.Input[bool]] = None,
            icmp_options: Optional[pulumi.Input[str]] = None,
            in_bridge_port: Optional[pulumi.Input[str]] = None,
            in_bridge_port_list: Optional[pulumi.Input[str]] = None,
            in_interface: Optional[pulumi.Input[str]] = None,
            in_interface_list: Optional[pulumi.Input[str]] = None,
            ingress_priority: Optional[pulumi.Input[int]] = None,
            invalid: Optional[pulumi.Input[bool]] = None,
            ipsec_policy: Optional[pulumi.Input[str]] = None,
            ipv4_options: Optional[pulumi.Input[str]] = None,
            jump_target: Optional[pulumi.Input[str]] = None,
            layer7_protocol: Optional[pulumi.Input[str]] = None,
            limit: Optional[pulumi.Input[str]] = None,
            log: Optional[pulumi.Input[bool]] = None,
            log_prefix: Optional[pulumi.Input[str]] = None,
            nth: Optional[pulumi.Input[str]] = None,
            out_bridge_port: Optional[pulumi.Input[str]] = None,
            out_bridge_port_list: Optional[pulumi.Input[str]] = None,
            out_interface: Optional[pulumi.Input[str]] = None,
            out_interface_list: Optional[pulumi.Input[str]] = None,
            packet_mark: Optional[pulumi.Input[str]] = None,
            packet_size: Optional[pulumi.Input[str]] = None,
            packets: Optional[pulumi.Input[int]] = None,
            per_connection_classifier: Optional[pulumi.Input[str]] = None,
            place_before: Optional[pulumi.Input[str]] = None,
            port: Optional[pulumi.Input[str]] = None,
            priority: Optional[pulumi.Input[int]] = None,
            protocol: Optional[pulumi.Input[str]] = None,
            psd: Optional[pulumi.Input[str]] = None,
            random: Optional[pulumi.Input[int]] = None,
            reject_with: Optional[pulumi.Input[str]] = None,
            routing_mark: Optional[pulumi.Input[str]] = None,
            routing_table: Optional[pulumi.Input[str]] = None,
            src_address: Optional[pulumi.Input[str]] = None,
            src_address_list: Optional[pulumi.Input[str]] = None,
            src_address_type: Optional[pulumi.Input[str]] = None,
            src_mac_address: Optional[pulumi.Input[str]] = None,
            src_port: Optional[pulumi.Input[str]] = None,
            tcp_flags: Optional[pulumi.Input[str]] = None,
            tcp_mss: Optional[pulumi.Input[str]] = None,
            time: Optional[pulumi.Input[str]] = None,
            tls_host: Optional[pulumi.Input[str]] = None,
            ttl: Optional[pulumi.Input[str]] = None) -> 'IpFirewallFilter':
        """
        Get an existing IpFirewallFilter resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] action: Action to take if a packet is matched by the rule
        :param pulumi.Input[str] address_list_timeout: Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
               conjunction with add-dst-to-address-list or add-src-to-address-list actions.
        :param pulumi.Input[int] bytes: The total amount of bytes matched by the rule.
        :param pulumi.Input[str] chain: Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
               chain will be created.
        :param pulumi.Input[str] connection_bytes: Matches packets only if a given amount of bytes has been transfered through the particular connection.
        :param pulumi.Input[str] connection_limit: Matches connections per address or address block after given value is reached. Should be used together with
               connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
        :param pulumi.Input[str] connection_mark: Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
               unmarked connection.
        :param pulumi.Input[str] connection_nat_state: Can match connections that are srcnatted, dstnatted or both.
        :param pulumi.Input[str] connection_rate: Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
               (0..4294967295).
        :param pulumi.Input[str] connection_state: Interprets the connection tracking analysis data for a particular packet.
        :param pulumi.Input[str] connection_type: Matches packets from related connections based on information from their connection tracking helpers.
        :param pulumi.Input[str] content: Match packets that contain specified text.
        :param pulumi.Input[int] dscp: Matches DSCP IP header field.
        :param pulumi.Input[str] dst_address: Matches packets which destination is equal to specified IP or falls into specified IP range.
        :param pulumi.Input[str] dst_address_list: Matches destination address of a packet against user-defined address list.
        :param pulumi.Input[str] dst_address_type: Matches destination address type.
        :param pulumi.Input[str] dst_limit: Matches packets until a given rate is exceeded.
        :param pulumi.Input[str] dst_port: List of destination port numbers or port number ranges.
        :param pulumi.Input[bool] dynamic: Configuration item created by software, not by management interface. It is not exported, and cannot be directly
               modified.
        :param pulumi.Input[bool] fragment: Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
               fragments as system automatically assembles every packet
        :param pulumi.Input[str] hotspot: Matches packets received from HotSpot clients against various HotSpot matchers.
        :param pulumi.Input[bool] hw_offload: Connection offloading for Fasttrack.
        :param pulumi.Input[str] icmp_options: Matches ICMP type: code fields.
        :param pulumi.Input[str] in_bridge_port: Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
               is enabled in bridge settings.
        :param pulumi.Input[str] in_bridge_port_list: Set of interfaces defined in interface list. Works the same as in-bridge-port.
        :param pulumi.Input[str] in_interface: Interface the packet has entered the router.
        :param pulumi.Input[str] in_interface_list: Set of interfaces defined in interface list. Works the same as in-interface.
        :param pulumi.Input[int] ingress_priority: Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
        :param pulumi.Input[str] ipsec_policy: Matches the policy used by IPsec. Value is written in the following format: direction, policy.
        :param pulumi.Input[str] ipv4_options: Matches IPv4 header options.
        :param pulumi.Input[str] jump_target: Name of the target chain to jump to. Applicable only if action=jump.
        :param pulumi.Input[str] layer7_protocol: Layer7 filter name.
        :param pulumi.Input[str] limit: Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
               reached. Parameters are written in the following format: rate[/time],burst:mode.
        :param pulumi.Input[bool] log: Add a message to the system log.
        :param pulumi.Input[str] log_prefix: Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
        :param pulumi.Input[str] nth: Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
               by the rule
        :param pulumi.Input[str] out_bridge_port: Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
               is enabled in bridge settings.
        :param pulumi.Input[str] out_bridge_port_list: Set of interfaces defined in interface list. Works the same as out-bridge-port.
        :param pulumi.Input[str] out_interface: Interface the packet is leaving the router.
        :param pulumi.Input[str] out_interface_list: Set of interfaces defined in interface list. Works the same as out-interface.
        :param pulumi.Input[str] packet_mark: Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
               unmarked packet.
        :param pulumi.Input[str] packet_size: Matches packets of specified size or size range in bytes.
        :param pulumi.Input[int] packets: The total amount of packets matched by the rule.
        :param pulumi.Input[str] per_connection_classifier: PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
               in one particular stream.
        :param pulumi.Input[str] place_before: Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
               think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
        :param pulumi.Input[str] port: Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
               protocol is TCP or UDP
        :param pulumi.Input[int] priority: Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP
               bit, or from the priority that has been set using the set-priority action.
        :param pulumi.Input[str] protocol: Matches particular IP protocol specified by protocol name or number.
        :param pulumi.Input[str] psd: Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
               LowPortWeight, HighPortWeight.
        :param pulumi.Input[int] random: Matches packets randomly with a given probability.
        :param pulumi.Input[str] reject_with: Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.
        :param pulumi.Input[str] routing_mark: Matches packets marked by mangle facility with particular routing mark.
        :param pulumi.Input[str] routing_table: Matches packets which destination address is resolved in specific a routing table.
        :param pulumi.Input[str] src_address: Matches packets which source is equal to specified IP or falls into a specified IP range.
        :param pulumi.Input[str] src_address_list: Matches source address of a packet against user-defined address list.
        :param pulumi.Input[str] src_address_type: Matches source address type.
        :param pulumi.Input[str] src_mac_address: Matches source MAC address of the packet.
        :param pulumi.Input[str] src_port: List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
        :param pulumi.Input[str] tcp_flags: Matches specified TCP flags.
        :param pulumi.Input[str] tcp_mss: Matches TCP MSS value of an IP packet.
        :param pulumi.Input[str] time: Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
               and date.
        :param pulumi.Input[str] tls_host: Allows matching HTTPS traffic based on TLS SNI hostname.
        :param pulumi.Input[str] ttl: Matches packets TTL value.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _IpFirewallFilterState.__new__(_IpFirewallFilterState)

        __props__.__dict__["___id_"] = ___id_
        __props__.__dict__["___path_"] = ___path_
        __props__.__dict__["action"] = action
        __props__.__dict__["address_list_timeout"] = address_list_timeout
        __props__.__dict__["bytes"] = bytes
        __props__.__dict__["chain"] = chain
        __props__.__dict__["comment"] = comment
        __props__.__dict__["connection_bytes"] = connection_bytes
        __props__.__dict__["connection_limit"] = connection_limit
        __props__.__dict__["connection_mark"] = connection_mark
        __props__.__dict__["connection_nat_state"] = connection_nat_state
        __props__.__dict__["connection_rate"] = connection_rate
        __props__.__dict__["connection_state"] = connection_state
        __props__.__dict__["connection_type"] = connection_type
        __props__.__dict__["content"] = content
        __props__.__dict__["disabled"] = disabled
        __props__.__dict__["dscp"] = dscp
        __props__.__dict__["dst_address"] = dst_address
        __props__.__dict__["dst_address_list"] = dst_address_list
        __props__.__dict__["dst_address_type"] = dst_address_type
        __props__.__dict__["dst_limit"] = dst_limit
        __props__.__dict__["dst_port"] = dst_port
        __props__.__dict__["dynamic"] = dynamic
        __props__.__dict__["fragment"] = fragment
        __props__.__dict__["hotspot"] = hotspot
        __props__.__dict__["hw_offload"] = hw_offload
        __props__.__dict__["icmp_options"] = icmp_options
        __props__.__dict__["in_bridge_port"] = in_bridge_port
        __props__.__dict__["in_bridge_port_list"] = in_bridge_port_list
        __props__.__dict__["in_interface"] = in_interface
        __props__.__dict__["in_interface_list"] = in_interface_list
        __props__.__dict__["ingress_priority"] = ingress_priority
        __props__.__dict__["invalid"] = invalid
        __props__.__dict__["ipsec_policy"] = ipsec_policy
        __props__.__dict__["ipv4_options"] = ipv4_options
        __props__.__dict__["jump_target"] = jump_target
        __props__.__dict__["layer7_protocol"] = layer7_protocol
        __props__.__dict__["limit"] = limit
        __props__.__dict__["log"] = log
        __props__.__dict__["log_prefix"] = log_prefix
        __props__.__dict__["nth"] = nth
        __props__.__dict__["out_bridge_port"] = out_bridge_port
        __props__.__dict__["out_bridge_port_list"] = out_bridge_port_list
        __props__.__dict__["out_interface"] = out_interface
        __props__.__dict__["out_interface_list"] = out_interface_list
        __props__.__dict__["packet_mark"] = packet_mark
        __props__.__dict__["packet_size"] = packet_size
        __props__.__dict__["packets"] = packets
        __props__.__dict__["per_connection_classifier"] = per_connection_classifier
        __props__.__dict__["place_before"] = place_before
        __props__.__dict__["port"] = port
        __props__.__dict__["priority"] = priority
        __props__.__dict__["protocol"] = protocol
        __props__.__dict__["psd"] = psd
        __props__.__dict__["random"] = random
        __props__.__dict__["reject_with"] = reject_with
        __props__.__dict__["routing_mark"] = routing_mark
        __props__.__dict__["routing_table"] = routing_table
        __props__.__dict__["src_address"] = src_address
        __props__.__dict__["src_address_list"] = src_address_list
        __props__.__dict__["src_address_type"] = src_address_type
        __props__.__dict__["src_mac_address"] = src_mac_address
        __props__.__dict__["src_port"] = src_port
        __props__.__dict__["tcp_flags"] = tcp_flags
        __props__.__dict__["tcp_mss"] = tcp_mss
        __props__.__dict__["time"] = time
        __props__.__dict__["tls_host"] = tls_host
        __props__.__dict__["ttl"] = ttl
        return IpFirewallFilter(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def ___id_(self) -> pulumi.Output[Optional[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @property
    @pulumi.getter
    def ___path_(self) -> pulumi.Output[Optional[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @property
    @pulumi.getter
    def action(self) -> pulumi.Output[str]:
        """
        Action to take if a packet is matched by the rule
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="addressListTimeout")
    def address_list_timeout(self) -> pulumi.Output[Optional[str]]:
        """
        Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
        conjunction with add-dst-to-address-list or add-src-to-address-list actions.
        """
        return pulumi.get(self, "address_list_timeout")

    @property
    @pulumi.getter
    def bytes(self) -> pulumi.Output[int]:
        """
        The total amount of bytes matched by the rule.
        """
        return pulumi.get(self, "bytes")

    @property
    @pulumi.getter
    def chain(self) -> pulumi.Output[str]:
        """
        Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
        chain will be created.
        """
        return pulumi.get(self, "chain")

    @property
    @pulumi.getter
    def comment(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="connectionBytes")
    def connection_bytes(self) -> pulumi.Output[Optional[str]]:
        """
        Matches packets only if a given amount of bytes has been transfered through the particular connection.
        """
        return pulumi.get(self, "connection_bytes")

    @property
    @pulumi.getter(name="connectionLimit")
    def connection_limit(self) -> pulumi.Output[Optional[str]]:
        """
        Matches connections per address or address block after given value is reached. Should be used together with
        connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
        """
        return pulumi.get(self, "connection_limit")

    @property
    @pulumi.getter(name="connectionMark")
    def connection_mark(self) -> pulumi.Output[Optional[str]]:
        """
        Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
        unmarked connection.
        """
        return pulumi.get(self, "connection_mark")

    @property
    @pulumi.getter(name="connectionNatState")
    def connection_nat_state(self) -> pulumi.Output[Optional[str]]:
        """
        Can match connections that are srcnatted, dstnatted or both.
        """
        return pulumi.get(self, "connection_nat_state")

    @property
    @pulumi.getter(name="connectionRate")
    def connection_rate(self) -> pulumi.Output[Optional[str]]:
        """
        Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
        (0..4294967295).
        """
        return pulumi.get(self, "connection_rate")

    @property
    @pulumi.getter(name="connectionState")
    def connection_state(self) -> pulumi.Output[Optional[str]]:
        """
        Interprets the connection tracking analysis data for a particular packet.
        """
        return pulumi.get(self, "connection_state")

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> pulumi.Output[Optional[str]]:
        """
        Matches packets from related connections based on information from their connection tracking helpers.
        """
        return pulumi.get(self, "connection_type")

    @property
    @pulumi.getter
    def content(self) -> pulumi.Output[Optional[str]]:
        """
        Match packets that contain specified text.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def disabled(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def dscp(self) -> pulumi.Output[Optional[int]]:
        """
        Matches DSCP IP header field.
        """
        return pulumi.get(self, "dscp")

    @property
    @pulumi.getter(name="dstAddress")
    def dst_address(self) -> pulumi.Output[Optional[str]]:
        """
        Matches packets which destination is equal to specified IP or falls into specified IP range.
        """
        return pulumi.get(self, "dst_address")

    @property
    @pulumi.getter(name="dstAddressList")
    def dst_address_list(self) -> pulumi.Output[Optional[str]]:
        """
        Matches destination address of a packet against user-defined address list.
        """
        return pulumi.get(self, "dst_address_list")

    @property
    @pulumi.getter(name="dstAddressType")
    def dst_address_type(self) -> pulumi.Output[Optional[str]]:
        """
        Matches destination address type.
        """
        return pulumi.get(self, "dst_address_type")

    @property
    @pulumi.getter(name="dstLimit")
    def dst_limit(self) -> pulumi.Output[Optional[str]]:
        """
        Matches packets until a given rate is exceeded.
        """
        return pulumi.get(self, "dst_limit")

    @property
    @pulumi.getter(name="dstPort")
    def dst_port(self) -> pulumi.Output[Optional[str]]:
        """
        List of destination port numbers or port number ranges.
        """
        return pulumi.get(self, "dst_port")

    @property
    @pulumi.getter
    def dynamic(self) -> pulumi.Output[bool]:
        """
        Configuration item created by software, not by management interface. It is not exported, and cannot be directly
        modified.
        """
        return pulumi.get(self, "dynamic")

    @property
    @pulumi.getter
    def fragment(self) -> pulumi.Output[Optional[bool]]:
        """
        Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
        fragments as system automatically assembles every packet
        """
        return pulumi.get(self, "fragment")

    @property
    @pulumi.getter
    def hotspot(self) -> pulumi.Output[Optional[str]]:
        """
        Matches packets received from HotSpot clients against various HotSpot matchers.
        """
        return pulumi.get(self, "hotspot")

    @property
    @pulumi.getter(name="hwOffload")
    def hw_offload(self) -> pulumi.Output[Optional[bool]]:
        """
        Connection offloading for Fasttrack.
        """
        return pulumi.get(self, "hw_offload")

    @property
    @pulumi.getter(name="icmpOptions")
    def icmp_options(self) -> pulumi.Output[Optional[str]]:
        """
        Matches ICMP type: code fields.
        """
        return pulumi.get(self, "icmp_options")

    @property
    @pulumi.getter(name="inBridgePort")
    def in_bridge_port(self) -> pulumi.Output[Optional[str]]:
        """
        Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
        is enabled in bridge settings.
        """
        return pulumi.get(self, "in_bridge_port")

    @property
    @pulumi.getter(name="inBridgePortList")
    def in_bridge_port_list(self) -> pulumi.Output[Optional[str]]:
        """
        Set of interfaces defined in interface list. Works the same as in-bridge-port.
        """
        return pulumi.get(self, "in_bridge_port_list")

    @property
    @pulumi.getter(name="inInterface")
    def in_interface(self) -> pulumi.Output[Optional[str]]:
        """
        Interface the packet has entered the router.
        """
        return pulumi.get(self, "in_interface")

    @property
    @pulumi.getter(name="inInterfaceList")
    def in_interface_list(self) -> pulumi.Output[Optional[str]]:
        """
        Set of interfaces defined in interface list. Works the same as in-interface.
        """
        return pulumi.get(self, "in_interface_list")

    @property
    @pulumi.getter(name="ingressPriority")
    def ingress_priority(self) -> pulumi.Output[Optional[int]]:
        """
        Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
        """
        return pulumi.get(self, "ingress_priority")

    @property
    @pulumi.getter
    def invalid(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "invalid")

    @property
    @pulumi.getter(name="ipsecPolicy")
    def ipsec_policy(self) -> pulumi.Output[Optional[str]]:
        """
        Matches the policy used by IPsec. Value is written in the following format: direction, policy.
        """
        return pulumi.get(self, "ipsec_policy")

    @property
    @pulumi.getter(name="ipv4Options")
    def ipv4_options(self) -> pulumi.Output[Optional[str]]:
        """
        Matches IPv4 header options.
        """
        return pulumi.get(self, "ipv4_options")

    @property
    @pulumi.getter(name="jumpTarget")
    def jump_target(self) -> pulumi.Output[Optional[str]]:
        """
        Name of the target chain to jump to. Applicable only if action=jump.
        """
        return pulumi.get(self, "jump_target")

    @property
    @pulumi.getter(name="layer7Protocol")
    def layer7_protocol(self) -> pulumi.Output[Optional[str]]:
        """
        Layer7 filter name.
        """
        return pulumi.get(self, "layer7_protocol")

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Output[Optional[str]]:
        """
        Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
        reached. Parameters are written in the following format: rate[/time],burst:mode.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def log(self) -> pulumi.Output[Optional[bool]]:
        """
        Add a message to the system log.
        """
        return pulumi.get(self, "log")

    @property
    @pulumi.getter(name="logPrefix")
    def log_prefix(self) -> pulumi.Output[Optional[str]]:
        """
        Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
        """
        return pulumi.get(self, "log_prefix")

    @property
    @pulumi.getter
    def nth(self) -> pulumi.Output[Optional[str]]:
        """
        Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
        by the rule
        """
        return pulumi.get(self, "nth")

    @property
    @pulumi.getter(name="outBridgePort")
    def out_bridge_port(self) -> pulumi.Output[Optional[str]]:
        """
        Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
        is enabled in bridge settings.
        """
        return pulumi.get(self, "out_bridge_port")

    @property
    @pulumi.getter(name="outBridgePortList")
    def out_bridge_port_list(self) -> pulumi.Output[Optional[str]]:
        """
        Set of interfaces defined in interface list. Works the same as out-bridge-port.
        """
        return pulumi.get(self, "out_bridge_port_list")

    @property
    @pulumi.getter(name="outInterface")
    def out_interface(self) -> pulumi.Output[Optional[str]]:
        """
        Interface the packet is leaving the router.
        """
        return pulumi.get(self, "out_interface")

    @property
    @pulumi.getter(name="outInterfaceList")
    def out_interface_list(self) -> pulumi.Output[Optional[str]]:
        """
        Set of interfaces defined in interface list. Works the same as out-interface.
        """
        return pulumi.get(self, "out_interface_list")

    @property
    @pulumi.getter(name="packetMark")
    def packet_mark(self) -> pulumi.Output[Optional[str]]:
        """
        Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
        unmarked packet.
        """
        return pulumi.get(self, "packet_mark")

    @property
    @pulumi.getter(name="packetSize")
    def packet_size(self) -> pulumi.Output[Optional[str]]:
        """
        Matches packets of specified size or size range in bytes.
        """
        return pulumi.get(self, "packet_size")

    @property
    @pulumi.getter
    def packets(self) -> pulumi.Output[int]:
        """
        The total amount of packets matched by the rule.
        """
        return pulumi.get(self, "packets")

    @property
    @pulumi.getter(name="perConnectionClassifier")
    def per_connection_classifier(self) -> pulumi.Output[Optional[str]]:
        """
        PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
        in one particular stream.
        """
        return pulumi.get(self, "per_connection_classifier")

    @property
    @pulumi.getter(name="placeBefore")
    def place_before(self) -> pulumi.Output[Optional[str]]:
        """
        Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
        think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
        """
        return pulumi.get(self, "place_before")

    @property
    @pulumi.getter
    def port(self) -> pulumi.Output[Optional[str]]:
        """
        Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
        protocol is TCP or UDP
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Output[Optional[int]]:
        """
        Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP
        bit, or from the priority that has been set using the set-priority action.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Output[Optional[str]]:
        """
        Matches particular IP protocol specified by protocol name or number.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter
    def psd(self) -> pulumi.Output[Optional[str]]:
        """
        Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
        LowPortWeight, HighPortWeight.
        """
        return pulumi.get(self, "psd")

    @property
    @pulumi.getter
    def random(self) -> pulumi.Output[Optional[int]]:
        """
        Matches packets randomly with a given probability.
        """
        return pulumi.get(self, "random")

    @property
    @pulumi.getter(name="rejectWith")
    def reject_with(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.
        """
        return pulumi.get(self, "reject_with")

    @property
    @pulumi.getter(name="routingMark")
    def routing_mark(self) -> pulumi.Output[Optional[str]]:
        """
        Matches packets marked by mangle facility with particular routing mark.
        """
        return pulumi.get(self, "routing_mark")

    @property
    @pulumi.getter(name="routingTable")
    def routing_table(self) -> pulumi.Output[Optional[str]]:
        """
        Matches packets which destination address is resolved in specific a routing table.
        """
        return pulumi.get(self, "routing_table")

    @property
    @pulumi.getter(name="srcAddress")
    def src_address(self) -> pulumi.Output[Optional[str]]:
        """
        Matches packets which source is equal to specified IP or falls into a specified IP range.
        """
        return pulumi.get(self, "src_address")

    @property
    @pulumi.getter(name="srcAddressList")
    def src_address_list(self) -> pulumi.Output[Optional[str]]:
        """
        Matches source address of a packet against user-defined address list.
        """
        return pulumi.get(self, "src_address_list")

    @property
    @pulumi.getter(name="srcAddressType")
    def src_address_type(self) -> pulumi.Output[Optional[str]]:
        """
        Matches source address type.
        """
        return pulumi.get(self, "src_address_type")

    @property
    @pulumi.getter(name="srcMacAddress")
    def src_mac_address(self) -> pulumi.Output[Optional[str]]:
        """
        Matches source MAC address of the packet.
        """
        return pulumi.get(self, "src_mac_address")

    @property
    @pulumi.getter(name="srcPort")
    def src_port(self) -> pulumi.Output[Optional[str]]:
        """
        List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
        """
        return pulumi.get(self, "src_port")

    @property
    @pulumi.getter(name="tcpFlags")
    def tcp_flags(self) -> pulumi.Output[Optional[str]]:
        """
        Matches specified TCP flags.
        """
        return pulumi.get(self, "tcp_flags")

    @property
    @pulumi.getter(name="tcpMss")
    def tcp_mss(self) -> pulumi.Output[Optional[str]]:
        """
        Matches TCP MSS value of an IP packet.
        """
        return pulumi.get(self, "tcp_mss")

    @property
    @pulumi.getter
    def time(self) -> pulumi.Output[Optional[str]]:
        """
        Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
        and date.
        """
        return pulumi.get(self, "time")

    @property
    @pulumi.getter(name="tlsHost")
    def tls_host(self) -> pulumi.Output[Optional[str]]:
        """
        Allows matching HTTPS traffic based on TLS SNI hostname.
        """
        return pulumi.get(self, "tls_host")

    @property
    @pulumi.getter
    def ttl(self) -> pulumi.Output[Optional[str]]:
        """
        Matches packets TTL value.
        """
        return pulumi.get(self, "ttl")

