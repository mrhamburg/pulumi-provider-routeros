# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = ['WireguardPeerArgs', 'WireguardPeer']

@pulumi.input_type
class WireguardPeerArgs:
    def __init__(__self__, *,
                 interface: pulumi.Input[str],
                 public_key: pulumi.Input[str],
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 allowed_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 endpoint_address: Optional[pulumi.Input[str]] = None,
                 endpoint_port: Optional[pulumi.Input[str]] = None,
                 persistent_keepalive: Optional[pulumi.Input[str]] = None,
                 preshared_key: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a WireguardPeer resource.
        :param pulumi.Input[str] interface: Name of the interface.
        :param pulumi.Input[str] public_key: The remote peer's calculated public key.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_addresses: List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which
               outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
               and ::/0 may be specified for matching all IPv6 addresses.
        :param pulumi.Input[str] endpoint_address: An endpoint IP or hostname can be left blank to allow remote connection from any address.
        :param pulumi.Input[str] endpoint_port: An endpoint port can be left blank to allow remote connection from any port.
        :param pulumi.Input[str] persistent_keepalive: A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for
               the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely
               sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit
               from having a persistent keepalive interval of 25 seconds.
        :param pulumi.Input[str] preshared_key: A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key
               cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
        """
        pulumi.set(__self__, "interface", interface)
        pulumi.set(__self__, "public_key", public_key)
        if ___id_ is not None:
            pulumi.set(__self__, "___id_", ___id_)
        if ___path_ is not None:
            pulumi.set(__self__, "___path_", ___path_)
        if allowed_addresses is not None:
            pulumi.set(__self__, "allowed_addresses", allowed_addresses)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if endpoint_address is not None:
            pulumi.set(__self__, "endpoint_address", endpoint_address)
        if endpoint_port is not None:
            pulumi.set(__self__, "endpoint_port", endpoint_port)
        if persistent_keepalive is not None:
            pulumi.set(__self__, "persistent_keepalive", persistent_keepalive)
        if preshared_key is not None:
            pulumi.set(__self__, "preshared_key", preshared_key)

    @property
    @pulumi.getter
    def interface(self) -> pulumi.Input[str]:
        """
        Name of the interface.
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: pulumi.Input[str]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[str]:
        """
        The remote peer's calculated public key.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "public_key", value)

    @property
    @pulumi.getter
    def ___id_(self) -> Optional[pulumi.Input[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @___id_.setter
    def ___id_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "___id_", value)

    @property
    @pulumi.getter
    def ___path_(self) -> Optional[pulumi.Input[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @___path_.setter
    def ___path_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "___path_", value)

    @property
    @pulumi.getter(name="allowedAddresses")
    def allowed_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which
        outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
        and ::/0 may be specified for matching all IPv6 addresses.
        """
        return pulumi.get(self, "allowed_addresses")

    @allowed_addresses.setter
    def allowed_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_addresses", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="endpointAddress")
    def endpoint_address(self) -> Optional[pulumi.Input[str]]:
        """
        An endpoint IP or hostname can be left blank to allow remote connection from any address.
        """
        return pulumi.get(self, "endpoint_address")

    @endpoint_address.setter
    def endpoint_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_address", value)

    @property
    @pulumi.getter(name="endpointPort")
    def endpoint_port(self) -> Optional[pulumi.Input[str]]:
        """
        An endpoint port can be left blank to allow remote connection from any port.
        """
        return pulumi.get(self, "endpoint_port")

    @endpoint_port.setter
    def endpoint_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_port", value)

    @property
    @pulumi.getter(name="persistentKeepalive")
    def persistent_keepalive(self) -> Optional[pulumi.Input[str]]:
        """
        A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for
        the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely
        sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit
        from having a persistent keepalive interval of 25 seconds.
        """
        return pulumi.get(self, "persistent_keepalive")

    @persistent_keepalive.setter
    def persistent_keepalive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "persistent_keepalive", value)

    @property
    @pulumi.getter(name="presharedKey")
    def preshared_key(self) -> Optional[pulumi.Input[str]]:
        """
        A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key
        cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
        """
        return pulumi.get(self, "preshared_key")

    @preshared_key.setter
    def preshared_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preshared_key", value)


@pulumi.input_type
class _WireguardPeerState:
    def __init__(__self__, *,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 allowed_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 current_endpoint_address: Optional[pulumi.Input[str]] = None,
                 current_endpoint_port: Optional[pulumi.Input[int]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 endpoint_address: Optional[pulumi.Input[str]] = None,
                 endpoint_port: Optional[pulumi.Input[str]] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 last_handshake: Optional[pulumi.Input[str]] = None,
                 persistent_keepalive: Optional[pulumi.Input[str]] = None,
                 preshared_key: Optional[pulumi.Input[str]] = None,
                 public_key: Optional[pulumi.Input[str]] = None,
                 rx: Optional[pulumi.Input[str]] = None,
                 tx: Optional[pulumi.Input[str]] = None):
        """
        Input properties used for looking up and filtering WireguardPeer resources.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_addresses: List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which
               outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
               and ::/0 may be specified for matching all IPv6 addresses.
        :param pulumi.Input[str] current_endpoint_address: The most recent source IP address of correctly authenticated packets from the peer.
        :param pulumi.Input[int] current_endpoint_port: The most recent source IP port of correctly authenticated packets from the peer.
        :param pulumi.Input[str] endpoint_address: An endpoint IP or hostname can be left blank to allow remote connection from any address.
        :param pulumi.Input[str] endpoint_port: An endpoint port can be left blank to allow remote connection from any port.
        :param pulumi.Input[str] interface: Name of the interface.
        :param pulumi.Input[str] last_handshake: Time in seconds after the last successful handshake.
        :param pulumi.Input[str] persistent_keepalive: A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for
               the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely
               sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit
               from having a persistent keepalive interval of 25 seconds.
        :param pulumi.Input[str] preshared_key: A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key
               cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
        :param pulumi.Input[str] public_key: The remote peer's calculated public key.
        :param pulumi.Input[str] rx: The total amount of bytes received from the peer.
        :param pulumi.Input[str] tx: The total amount of bytes transmitted to the peer.
        """
        if ___id_ is not None:
            pulumi.set(__self__, "___id_", ___id_)
        if ___path_ is not None:
            pulumi.set(__self__, "___path_", ___path_)
        if allowed_addresses is not None:
            pulumi.set(__self__, "allowed_addresses", allowed_addresses)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if current_endpoint_address is not None:
            pulumi.set(__self__, "current_endpoint_address", current_endpoint_address)
        if current_endpoint_port is not None:
            pulumi.set(__self__, "current_endpoint_port", current_endpoint_port)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if endpoint_address is not None:
            pulumi.set(__self__, "endpoint_address", endpoint_address)
        if endpoint_port is not None:
            pulumi.set(__self__, "endpoint_port", endpoint_port)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if last_handshake is not None:
            pulumi.set(__self__, "last_handshake", last_handshake)
        if persistent_keepalive is not None:
            pulumi.set(__self__, "persistent_keepalive", persistent_keepalive)
        if preshared_key is not None:
            pulumi.set(__self__, "preshared_key", preshared_key)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if rx is not None:
            pulumi.set(__self__, "rx", rx)
        if tx is not None:
            pulumi.set(__self__, "tx", tx)

    @property
    @pulumi.getter
    def ___id_(self) -> Optional[pulumi.Input[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @___id_.setter
    def ___id_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "___id_", value)

    @property
    @pulumi.getter
    def ___path_(self) -> Optional[pulumi.Input[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @___path_.setter
    def ___path_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "___path_", value)

    @property
    @pulumi.getter(name="allowedAddresses")
    def allowed_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which
        outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
        and ::/0 may be specified for matching all IPv6 addresses.
        """
        return pulumi.get(self, "allowed_addresses")

    @allowed_addresses.setter
    def allowed_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_addresses", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="currentEndpointAddress")
    def current_endpoint_address(self) -> Optional[pulumi.Input[str]]:
        """
        The most recent source IP address of correctly authenticated packets from the peer.
        """
        return pulumi.get(self, "current_endpoint_address")

    @current_endpoint_address.setter
    def current_endpoint_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "current_endpoint_address", value)

    @property
    @pulumi.getter(name="currentEndpointPort")
    def current_endpoint_port(self) -> Optional[pulumi.Input[int]]:
        """
        The most recent source IP port of correctly authenticated packets from the peer.
        """
        return pulumi.get(self, "current_endpoint_port")

    @current_endpoint_port.setter
    def current_endpoint_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "current_endpoint_port", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="endpointAddress")
    def endpoint_address(self) -> Optional[pulumi.Input[str]]:
        """
        An endpoint IP or hostname can be left blank to allow remote connection from any address.
        """
        return pulumi.get(self, "endpoint_address")

    @endpoint_address.setter
    def endpoint_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_address", value)

    @property
    @pulumi.getter(name="endpointPort")
    def endpoint_port(self) -> Optional[pulumi.Input[str]]:
        """
        An endpoint port can be left blank to allow remote connection from any port.
        """
        return pulumi.get(self, "endpoint_port")

    @endpoint_port.setter
    def endpoint_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint_port", value)

    @property
    @pulumi.getter
    def interface(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the interface.
        """
        return pulumi.get(self, "interface")

    @interface.setter
    def interface(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface", value)

    @property
    @pulumi.getter(name="lastHandshake")
    def last_handshake(self) -> Optional[pulumi.Input[str]]:
        """
        Time in seconds after the last successful handshake.
        """
        return pulumi.get(self, "last_handshake")

    @last_handshake.setter
    def last_handshake(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_handshake", value)

    @property
    @pulumi.getter(name="persistentKeepalive")
    def persistent_keepalive(self) -> Optional[pulumi.Input[str]]:
        """
        A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for
        the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely
        sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit
        from having a persistent keepalive interval of 25 seconds.
        """
        return pulumi.get(self, "persistent_keepalive")

    @persistent_keepalive.setter
    def persistent_keepalive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "persistent_keepalive", value)

    @property
    @pulumi.getter(name="presharedKey")
    def preshared_key(self) -> Optional[pulumi.Input[str]]:
        """
        A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key
        cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
        """
        return pulumi.get(self, "preshared_key")

    @preshared_key.setter
    def preshared_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "preshared_key", value)

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[str]]:
        """
        The remote peer's calculated public key.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "public_key", value)

    @property
    @pulumi.getter
    def rx(self) -> Optional[pulumi.Input[str]]:
        """
        The total amount of bytes received from the peer.
        """
        return pulumi.get(self, "rx")

    @rx.setter
    def rx(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rx", value)

    @property
    @pulumi.getter
    def tx(self) -> Optional[pulumi.Input[str]]:
        """
        The total amount of bytes transmitted to the peer.
        """
        return pulumi.get(self, "tx")

    @tx.setter
    def tx(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tx", value)


class WireguardPeer(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 allowed_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 endpoint_address: Optional[pulumi.Input[str]] = None,
                 endpoint_port: Optional[pulumi.Input[str]] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 persistent_keepalive: Optional[pulumi.Input[str]] = None,
                 preshared_key: Optional[pulumi.Input[str]] = None,
                 public_key: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        ## # Iface.WireguardPeer (Resource)

        ***

        #### This is an alias for backwards compatibility between plugin versions.
        Please see documentation for Iface.InterfaceWireguardPeer

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_addresses: List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which
               outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
               and ::/0 may be specified for matching all IPv6 addresses.
        :param pulumi.Input[str] endpoint_address: An endpoint IP or hostname can be left blank to allow remote connection from any address.
        :param pulumi.Input[str] endpoint_port: An endpoint port can be left blank to allow remote connection from any port.
        :param pulumi.Input[str] interface: Name of the interface.
        :param pulumi.Input[str] persistent_keepalive: A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for
               the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely
               sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit
               from having a persistent keepalive interval of 25 seconds.
        :param pulumi.Input[str] preshared_key: A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key
               cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
        :param pulumi.Input[str] public_key: The remote peer's calculated public key.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: WireguardPeerArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## # Iface.WireguardPeer (Resource)

        ***

        #### This is an alias for backwards compatibility between plugin versions.
        Please see documentation for Iface.InterfaceWireguardPeer

        :param str resource_name: The name of the resource.
        :param WireguardPeerArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(WireguardPeerArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 allowed_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 endpoint_address: Optional[pulumi.Input[str]] = None,
                 endpoint_port: Optional[pulumi.Input[str]] = None,
                 interface: Optional[pulumi.Input[str]] = None,
                 persistent_keepalive: Optional[pulumi.Input[str]] = None,
                 preshared_key: Optional[pulumi.Input[str]] = None,
                 public_key: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = WireguardPeerArgs.__new__(WireguardPeerArgs)

            __props__.__dict__["___id_"] = ___id_
            __props__.__dict__["___path_"] = ___path_
            __props__.__dict__["allowed_addresses"] = allowed_addresses
            __props__.__dict__["comment"] = comment
            __props__.__dict__["disabled"] = disabled
            __props__.__dict__["endpoint_address"] = endpoint_address
            __props__.__dict__["endpoint_port"] = endpoint_port
            if interface is None and not opts.urn:
                raise TypeError("Missing required property 'interface'")
            __props__.__dict__["interface"] = interface
            __props__.__dict__["persistent_keepalive"] = persistent_keepalive
            __props__.__dict__["preshared_key"] = None if preshared_key is None else pulumi.Output.secret(preshared_key)
            if public_key is None and not opts.urn:
                raise TypeError("Missing required property 'public_key'")
            __props__.__dict__["public_key"] = public_key
            __props__.__dict__["current_endpoint_address"] = None
            __props__.__dict__["current_endpoint_port"] = None
            __props__.__dict__["last_handshake"] = None
            __props__.__dict__["rx"] = None
            __props__.__dict__["tx"] = None
        secret_opts = pulumi.ResourceOptions(additional_secret_outputs=["presharedKey"])
        opts = pulumi.ResourceOptions.merge(opts, secret_opts)
        super(WireguardPeer, __self__).__init__(
            'routeros:Iface/wireguardPeer:WireguardPeer',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            ___id_: Optional[pulumi.Input[int]] = None,
            ___path_: Optional[pulumi.Input[str]] = None,
            allowed_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            comment: Optional[pulumi.Input[str]] = None,
            current_endpoint_address: Optional[pulumi.Input[str]] = None,
            current_endpoint_port: Optional[pulumi.Input[int]] = None,
            disabled: Optional[pulumi.Input[bool]] = None,
            endpoint_address: Optional[pulumi.Input[str]] = None,
            endpoint_port: Optional[pulumi.Input[str]] = None,
            interface: Optional[pulumi.Input[str]] = None,
            last_handshake: Optional[pulumi.Input[str]] = None,
            persistent_keepalive: Optional[pulumi.Input[str]] = None,
            preshared_key: Optional[pulumi.Input[str]] = None,
            public_key: Optional[pulumi.Input[str]] = None,
            rx: Optional[pulumi.Input[str]] = None,
            tx: Optional[pulumi.Input[str]] = None) -> 'WireguardPeer':
        """
        Get an existing WireguardPeer resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_addresses: List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which
               outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
               and ::/0 may be specified for matching all IPv6 addresses.
        :param pulumi.Input[str] current_endpoint_address: The most recent source IP address of correctly authenticated packets from the peer.
        :param pulumi.Input[int] current_endpoint_port: The most recent source IP port of correctly authenticated packets from the peer.
        :param pulumi.Input[str] endpoint_address: An endpoint IP or hostname can be left blank to allow remote connection from any address.
        :param pulumi.Input[str] endpoint_port: An endpoint port can be left blank to allow remote connection from any port.
        :param pulumi.Input[str] interface: Name of the interface.
        :param pulumi.Input[str] last_handshake: Time in seconds after the last successful handshake.
        :param pulumi.Input[str] persistent_keepalive: A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for
               the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely
               sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit
               from having a persistent keepalive interval of 25 seconds.
        :param pulumi.Input[str] preshared_key: A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key
               cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
        :param pulumi.Input[str] public_key: The remote peer's calculated public key.
        :param pulumi.Input[str] rx: The total amount of bytes received from the peer.
        :param pulumi.Input[str] tx: The total amount of bytes transmitted to the peer.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _WireguardPeerState.__new__(_WireguardPeerState)

        __props__.__dict__["___id_"] = ___id_
        __props__.__dict__["___path_"] = ___path_
        __props__.__dict__["allowed_addresses"] = allowed_addresses
        __props__.__dict__["comment"] = comment
        __props__.__dict__["current_endpoint_address"] = current_endpoint_address
        __props__.__dict__["current_endpoint_port"] = current_endpoint_port
        __props__.__dict__["disabled"] = disabled
        __props__.__dict__["endpoint_address"] = endpoint_address
        __props__.__dict__["endpoint_port"] = endpoint_port
        __props__.__dict__["interface"] = interface
        __props__.__dict__["last_handshake"] = last_handshake
        __props__.__dict__["persistent_keepalive"] = persistent_keepalive
        __props__.__dict__["preshared_key"] = preshared_key
        __props__.__dict__["public_key"] = public_key
        __props__.__dict__["rx"] = rx
        __props__.__dict__["tx"] = tx
        return WireguardPeer(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def ___id_(self) -> pulumi.Output[Optional[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @property
    @pulumi.getter
    def ___path_(self) -> pulumi.Output[Optional[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @property
    @pulumi.getter(name="allowedAddresses")
    def allowed_addresses(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which
        outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
        and ::/0 may be specified for matching all IPv6 addresses.
        """
        return pulumi.get(self, "allowed_addresses")

    @property
    @pulumi.getter
    def comment(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="currentEndpointAddress")
    def current_endpoint_address(self) -> pulumi.Output[str]:
        """
        The most recent source IP address of correctly authenticated packets from the peer.
        """
        return pulumi.get(self, "current_endpoint_address")

    @property
    @pulumi.getter(name="currentEndpointPort")
    def current_endpoint_port(self) -> pulumi.Output[int]:
        """
        The most recent source IP port of correctly authenticated packets from the peer.
        """
        return pulumi.get(self, "current_endpoint_port")

    @property
    @pulumi.getter
    def disabled(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="endpointAddress")
    def endpoint_address(self) -> pulumi.Output[str]:
        """
        An endpoint IP or hostname can be left blank to allow remote connection from any address.
        """
        return pulumi.get(self, "endpoint_address")

    @property
    @pulumi.getter(name="endpointPort")
    def endpoint_port(self) -> pulumi.Output[str]:
        """
        An endpoint port can be left blank to allow remote connection from any port.
        """
        return pulumi.get(self, "endpoint_port")

    @property
    @pulumi.getter
    def interface(self) -> pulumi.Output[str]:
        """
        Name of the interface.
        """
        return pulumi.get(self, "interface")

    @property
    @pulumi.getter(name="lastHandshake")
    def last_handshake(self) -> pulumi.Output[str]:
        """
        Time in seconds after the last successful handshake.
        """
        return pulumi.get(self, "last_handshake")

    @property
    @pulumi.getter(name="persistentKeepalive")
    def persistent_keepalive(self) -> pulumi.Output[Optional[str]]:
        """
        A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for
        the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely
        sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit
        from having a persistent keepalive interval of 25 seconds.
        """
        return pulumi.get(self, "persistent_keepalive")

    @property
    @pulumi.getter(name="presharedKey")
    def preshared_key(self) -> pulumi.Output[Optional[str]]:
        """
        A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key
        cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
        """
        return pulumi.get(self, "preshared_key")

    @property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Output[str]:
        """
        The remote peer's calculated public key.
        """
        return pulumi.get(self, "public_key")

    @property
    @pulumi.getter
    def rx(self) -> pulumi.Output[str]:
        """
        The total amount of bytes received from the peer.
        """
        return pulumi.get(self, "rx")

    @property
    @pulumi.getter
    def tx(self) -> pulumi.Output[str]:
        """
        The total amount of bytes transmitted to the peer.
        """
        return pulumi.get(self, "tx")

