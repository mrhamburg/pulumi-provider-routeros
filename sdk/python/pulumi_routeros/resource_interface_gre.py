# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = ['ResourceInterfaceGreArgs', 'ResourceInterfaceGre']

@pulumi.input_type
class ResourceInterfaceGreArgs:
    def __init__(__self__, *,
                 remote_address: pulumi.Input[str],
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 allow_fast_path: Optional[pulumi.Input[bool]] = None,
                 clamp_tcp_mss: Optional[pulumi.Input[bool]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 dont_fragment: Optional[pulumi.Input[str]] = None,
                 dscp: Optional[pulumi.Input[str]] = None,
                 ipsec_secret: Optional[pulumi.Input[str]] = None,
                 keepalive: Optional[pulumi.Input[str]] = None,
                 local_address: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a ResourceInterfaceGre resource.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[bool] allow_fast_path: Whether to allow FastPath processing. Must be disabled if IPsec tunneling is used.
        :param pulumi.Input[bool] clamp_tcp_mss: Controls whether to change MSS size for received TCP SYN packets. When enabled, a router will change the MSS size for received TCP SYN packets if the current MSS size exceeds the tunnel interface MTU (taking into account the TCP/IP overhead). The received encapsulated packet will still contain the original MSS, and only after decapsulation the MSS is changed.
        :param pulumi.Input[str] dscp: Set dscp value in GRE header to a fixed value '0..63' or 'inherit' from dscp value taken from tunnelled traffic.
        :param pulumi.Input[str] ipsec_secret: When secret is specified, router adds dynamic IPsec peer to remote-address with pre-shared key and policy (by default phase2 uses sha1/aes128cbc).
        :param pulumi.Input[str] keepalive: Tunnel keepalive parameter sets the time interval in which the tunnel running flag will remain even if the remote end of tunnel goes down. If configured time,retries fail, interface running flag is removed. Parameters are written in following format: KeepaliveInterval,KeepaliveRetries where KeepaliveInterval is time interval and KeepaliveRetries - number of retry attempts. KeepaliveInterval is integer 0..4294967295
        :param pulumi.Input[str] mtu: Layer3 Maximum transmission unit ('auto', 0 .. 65535)
        :param pulumi.Input[str] name: Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
               resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
               integrity for that resource!
        """
        pulumi.set(__self__, "remote_address", remote_address)
        if ___id_ is not None:
            pulumi.set(__self__, "___id_", ___id_)
        if ___path_ is not None:
            pulumi.set(__self__, "___path_", ___path_)
        if allow_fast_path is not None:
            pulumi.set(__self__, "allow_fast_path", allow_fast_path)
        if clamp_tcp_mss is not None:
            pulumi.set(__self__, "clamp_tcp_mss", clamp_tcp_mss)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dont_fragment is not None:
            pulumi.set(__self__, "dont_fragment", dont_fragment)
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if ipsec_secret is not None:
            pulumi.set(__self__, "ipsec_secret", ipsec_secret)
        if keepalive is not None:
            pulumi.set(__self__, "keepalive", keepalive)
        if local_address is not None:
            pulumi.set(__self__, "local_address", local_address)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> pulumi.Input[str]:
        return pulumi.get(self, "remote_address")

    @remote_address.setter
    def remote_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "remote_address", value)

    @property
    @pulumi.getter
    def ___id_(self) -> Optional[pulumi.Input[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @___id_.setter
    def ___id_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "___id_", value)

    @property
    @pulumi.getter
    def ___path_(self) -> Optional[pulumi.Input[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @___path_.setter
    def ___path_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "___path_", value)

    @property
    @pulumi.getter(name="allowFastPath")
    def allow_fast_path(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow FastPath processing. Must be disabled if IPsec tunneling is used.
        """
        return pulumi.get(self, "allow_fast_path")

    @allow_fast_path.setter
    def allow_fast_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_fast_path", value)

    @property
    @pulumi.getter(name="clampTcpMss")
    def clamp_tcp_mss(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether to change MSS size for received TCP SYN packets. When enabled, a router will change the MSS size for received TCP SYN packets if the current MSS size exceeds the tunnel interface MTU (taking into account the TCP/IP overhead). The received encapsulated packet will still contain the original MSS, and only after decapsulation the MSS is changed.
        """
        return pulumi.get(self, "clamp_tcp_mss")

    @clamp_tcp_mss.setter
    def clamp_tcp_mss(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clamp_tcp_mss", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="dontFragment")
    def dont_fragment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dont_fragment")

    @dont_fragment.setter
    def dont_fragment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dont_fragment", value)

    @property
    @pulumi.getter
    def dscp(self) -> Optional[pulumi.Input[str]]:
        """
        Set dscp value in GRE header to a fixed value '0..63' or 'inherit' from dscp value taken from tunnelled traffic.
        """
        return pulumi.get(self, "dscp")

    @dscp.setter
    def dscp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dscp", value)

    @property
    @pulumi.getter(name="ipsecSecret")
    def ipsec_secret(self) -> Optional[pulumi.Input[str]]:
        """
        When secret is specified, router adds dynamic IPsec peer to remote-address with pre-shared key and policy (by default phase2 uses sha1/aes128cbc).
        """
        return pulumi.get(self, "ipsec_secret")

    @ipsec_secret.setter
    def ipsec_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipsec_secret", value)

    @property
    @pulumi.getter
    def keepalive(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel keepalive parameter sets the time interval in which the tunnel running flag will remain even if the remote end of tunnel goes down. If configured time,retries fail, interface running flag is removed. Parameters are written in following format: KeepaliveInterval,KeepaliveRetries where KeepaliveInterval is time interval and KeepaliveRetries - number of retry attempts. KeepaliveInterval is integer 0..4294967295
        """
        return pulumi.get(self, "keepalive")

    @keepalive.setter
    def keepalive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keepalive", value)

    @property
    @pulumi.getter(name="localAddress")
    def local_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "local_address")

    @local_address.setter
    def local_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_address", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[str]]:
        """
        Layer3 Maximum transmission unit ('auto', 0 .. 65535)
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
        resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
        integrity for that resource!
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class _ResourceInterfaceGreState:
    def __init__(__self__, *,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 actual_mtu: Optional[pulumi.Input[int]] = None,
                 allow_fast_path: Optional[pulumi.Input[bool]] = None,
                 clamp_tcp_mss: Optional[pulumi.Input[bool]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 dont_fragment: Optional[pulumi.Input[str]] = None,
                 dscp: Optional[pulumi.Input[str]] = None,
                 ipsec_secret: Optional[pulumi.Input[str]] = None,
                 keepalive: Optional[pulumi.Input[str]] = None,
                 l2mtu: Optional[pulumi.Input[int]] = None,
                 local_address: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 remote_address: Optional[pulumi.Input[str]] = None,
                 running: Optional[pulumi.Input[bool]] = None):
        """
        Input properties used for looking up and filtering ResourceInterfaceGre resources.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[bool] allow_fast_path: Whether to allow FastPath processing. Must be disabled if IPsec tunneling is used.
        :param pulumi.Input[bool] clamp_tcp_mss: Controls whether to change MSS size for received TCP SYN packets. When enabled, a router will change the MSS size for received TCP SYN packets if the current MSS size exceeds the tunnel interface MTU (taking into account the TCP/IP overhead). The received encapsulated packet will still contain the original MSS, and only after decapsulation the MSS is changed.
        :param pulumi.Input[str] dscp: Set dscp value in GRE header to a fixed value '0..63' or 'inherit' from dscp value taken from tunnelled traffic.
        :param pulumi.Input[str] ipsec_secret: When secret is specified, router adds dynamic IPsec peer to remote-address with pre-shared key and policy (by default phase2 uses sha1/aes128cbc).
        :param pulumi.Input[str] keepalive: Tunnel keepalive parameter sets the time interval in which the tunnel running flag will remain even if the remote end of tunnel goes down. If configured time,retries fail, interface running flag is removed. Parameters are written in following format: KeepaliveInterval,KeepaliveRetries where KeepaliveInterval is time interval and KeepaliveRetries - number of retry attempts. KeepaliveInterval is integer 0..4294967295
        :param pulumi.Input[int] l2mtu: Layer2 Maximum transmission unit.
        :param pulumi.Input[str] mtu: Layer3 Maximum transmission unit ('auto', 0 .. 65535)
        :param pulumi.Input[str] name: Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
               resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
               integrity for that resource!
        """
        if ___id_ is not None:
            pulumi.set(__self__, "___id_", ___id_)
        if ___path_ is not None:
            pulumi.set(__self__, "___path_", ___path_)
        if actual_mtu is not None:
            pulumi.set(__self__, "actual_mtu", actual_mtu)
        if allow_fast_path is not None:
            pulumi.set(__self__, "allow_fast_path", allow_fast_path)
        if clamp_tcp_mss is not None:
            pulumi.set(__self__, "clamp_tcp_mss", clamp_tcp_mss)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if dont_fragment is not None:
            pulumi.set(__self__, "dont_fragment", dont_fragment)
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if ipsec_secret is not None:
            pulumi.set(__self__, "ipsec_secret", ipsec_secret)
        if keepalive is not None:
            pulumi.set(__self__, "keepalive", keepalive)
        if l2mtu is not None:
            pulumi.set(__self__, "l2mtu", l2mtu)
        if local_address is not None:
            pulumi.set(__self__, "local_address", local_address)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if remote_address is not None:
            pulumi.set(__self__, "remote_address", remote_address)
        if running is not None:
            pulumi.set(__self__, "running", running)

    @property
    @pulumi.getter
    def ___id_(self) -> Optional[pulumi.Input[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @___id_.setter
    def ___id_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "___id_", value)

    @property
    @pulumi.getter
    def ___path_(self) -> Optional[pulumi.Input[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @___path_.setter
    def ___path_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "___path_", value)

    @property
    @pulumi.getter(name="actualMtu")
    def actual_mtu(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "actual_mtu")

    @actual_mtu.setter
    def actual_mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "actual_mtu", value)

    @property
    @pulumi.getter(name="allowFastPath")
    def allow_fast_path(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow FastPath processing. Must be disabled if IPsec tunneling is used.
        """
        return pulumi.get(self, "allow_fast_path")

    @allow_fast_path.setter
    def allow_fast_path(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_fast_path", value)

    @property
    @pulumi.getter(name="clampTcpMss")
    def clamp_tcp_mss(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether to change MSS size for received TCP SYN packets. When enabled, a router will change the MSS size for received TCP SYN packets if the current MSS size exceeds the tunnel interface MTU (taking into account the TCP/IP overhead). The received encapsulated packet will still contain the original MSS, and only after decapsulation the MSS is changed.
        """
        return pulumi.get(self, "clamp_tcp_mss")

    @clamp_tcp_mss.setter
    def clamp_tcp_mss(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "clamp_tcp_mss", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="dontFragment")
    def dont_fragment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "dont_fragment")

    @dont_fragment.setter
    def dont_fragment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dont_fragment", value)

    @property
    @pulumi.getter
    def dscp(self) -> Optional[pulumi.Input[str]]:
        """
        Set dscp value in GRE header to a fixed value '0..63' or 'inherit' from dscp value taken from tunnelled traffic.
        """
        return pulumi.get(self, "dscp")

    @dscp.setter
    def dscp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dscp", value)

    @property
    @pulumi.getter(name="ipsecSecret")
    def ipsec_secret(self) -> Optional[pulumi.Input[str]]:
        """
        When secret is specified, router adds dynamic IPsec peer to remote-address with pre-shared key and policy (by default phase2 uses sha1/aes128cbc).
        """
        return pulumi.get(self, "ipsec_secret")

    @ipsec_secret.setter
    def ipsec_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipsec_secret", value)

    @property
    @pulumi.getter
    def keepalive(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel keepalive parameter sets the time interval in which the tunnel running flag will remain even if the remote end of tunnel goes down. If configured time,retries fail, interface running flag is removed. Parameters are written in following format: KeepaliveInterval,KeepaliveRetries where KeepaliveInterval is time interval and KeepaliveRetries - number of retry attempts. KeepaliveInterval is integer 0..4294967295
        """
        return pulumi.get(self, "keepalive")

    @keepalive.setter
    def keepalive(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "keepalive", value)

    @property
    @pulumi.getter
    def l2mtu(self) -> Optional[pulumi.Input[int]]:
        """
        Layer2 Maximum transmission unit.
        """
        return pulumi.get(self, "l2mtu")

    @l2mtu.setter
    def l2mtu(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "l2mtu", value)

    @property
    @pulumi.getter(name="localAddress")
    def local_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "local_address")

    @local_address.setter
    def local_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_address", value)

    @property
    @pulumi.getter
    def mtu(self) -> Optional[pulumi.Input[str]]:
        """
        Layer3 Maximum transmission unit ('auto', 0 .. 65535)
        """
        return pulumi.get(self, "mtu")

    @mtu.setter
    def mtu(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mtu", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
        resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
        integrity for that resource!
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "remote_address")

    @remote_address.setter
    def remote_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_address", value)

    @property
    @pulumi.getter
    def running(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "running")

    @running.setter
    def running(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "running", value)


class ResourceInterfaceGre(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 allow_fast_path: Optional[pulumi.Input[bool]] = None,
                 clamp_tcp_mss: Optional[pulumi.Input[bool]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 dont_fragment: Optional[pulumi.Input[str]] = None,
                 dscp: Optional[pulumi.Input[str]] = None,
                 ipsec_secret: Optional[pulumi.Input[str]] = None,
                 keepalive: Optional[pulumi.Input[str]] = None,
                 local_address: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 remote_address: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        ## Example Usage

        ```python
        import pulumi
        import pulumi_routeros as routeros

        gre_hq = routeros.ResourceInterfaceGre("greHq",
            disabled=True,
            remote_address="10.77.3.26")
        ```

        ## Import

        Import with the name of the gre interface in case of the example use gre-hq-1

        ```sh
         $ pulumi import routeros:index/resourceInterfaceGre:ResourceInterfaceGre gre_hq gre-hq-1
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[bool] allow_fast_path: Whether to allow FastPath processing. Must be disabled if IPsec tunneling is used.
        :param pulumi.Input[bool] clamp_tcp_mss: Controls whether to change MSS size for received TCP SYN packets. When enabled, a router will change the MSS size for received TCP SYN packets if the current MSS size exceeds the tunnel interface MTU (taking into account the TCP/IP overhead). The received encapsulated packet will still contain the original MSS, and only after decapsulation the MSS is changed.
        :param pulumi.Input[str] dscp: Set dscp value in GRE header to a fixed value '0..63' or 'inherit' from dscp value taken from tunnelled traffic.
        :param pulumi.Input[str] ipsec_secret: When secret is specified, router adds dynamic IPsec peer to remote-address with pre-shared key and policy (by default phase2 uses sha1/aes128cbc).
        :param pulumi.Input[str] keepalive: Tunnel keepalive parameter sets the time interval in which the tunnel running flag will remain even if the remote end of tunnel goes down. If configured time,retries fail, interface running flag is removed. Parameters are written in following format: KeepaliveInterval,KeepaliveRetries where KeepaliveInterval is time interval and KeepaliveRetries - number of retry attempts. KeepaliveInterval is integer 0..4294967295
        :param pulumi.Input[str] mtu: Layer3 Maximum transmission unit ('auto', 0 .. 65535)
        :param pulumi.Input[str] name: Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
               resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
               integrity for that resource!
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ResourceInterfaceGreArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## Example Usage

        ```python
        import pulumi
        import pulumi_routeros as routeros

        gre_hq = routeros.ResourceInterfaceGre("greHq",
            disabled=True,
            remote_address="10.77.3.26")
        ```

        ## Import

        Import with the name of the gre interface in case of the example use gre-hq-1

        ```sh
         $ pulumi import routeros:index/resourceInterfaceGre:ResourceInterfaceGre gre_hq gre-hq-1
        ```

        :param str resource_name: The name of the resource.
        :param ResourceInterfaceGreArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ResourceInterfaceGreArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 allow_fast_path: Optional[pulumi.Input[bool]] = None,
                 clamp_tcp_mss: Optional[pulumi.Input[bool]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 dont_fragment: Optional[pulumi.Input[str]] = None,
                 dscp: Optional[pulumi.Input[str]] = None,
                 ipsec_secret: Optional[pulumi.Input[str]] = None,
                 keepalive: Optional[pulumi.Input[str]] = None,
                 local_address: Optional[pulumi.Input[str]] = None,
                 mtu: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 remote_address: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ResourceInterfaceGreArgs.__new__(ResourceInterfaceGreArgs)

            __props__.__dict__["___id_"] = ___id_
            __props__.__dict__["___path_"] = ___path_
            __props__.__dict__["allow_fast_path"] = allow_fast_path
            __props__.__dict__["clamp_tcp_mss"] = clamp_tcp_mss
            __props__.__dict__["comment"] = comment
            __props__.__dict__["disabled"] = disabled
            __props__.__dict__["dont_fragment"] = dont_fragment
            __props__.__dict__["dscp"] = dscp
            __props__.__dict__["ipsec_secret"] = None if ipsec_secret is None else pulumi.Output.secret(ipsec_secret)
            __props__.__dict__["keepalive"] = keepalive
            __props__.__dict__["local_address"] = local_address
            __props__.__dict__["mtu"] = mtu
            __props__.__dict__["name"] = name
            if remote_address is None and not opts.urn:
                raise TypeError("Missing required property 'remote_address'")
            __props__.__dict__["remote_address"] = remote_address
            __props__.__dict__["actual_mtu"] = None
            __props__.__dict__["l2mtu"] = None
            __props__.__dict__["running"] = None
        secret_opts = pulumi.ResourceOptions(additional_secret_outputs=["ipsecSecret"])
        opts = pulumi.ResourceOptions.merge(opts, secret_opts)
        super(ResourceInterfaceGre, __self__).__init__(
            'routeros:index/resourceInterfaceGre:ResourceInterfaceGre',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            ___id_: Optional[pulumi.Input[int]] = None,
            ___path_: Optional[pulumi.Input[str]] = None,
            actual_mtu: Optional[pulumi.Input[int]] = None,
            allow_fast_path: Optional[pulumi.Input[bool]] = None,
            clamp_tcp_mss: Optional[pulumi.Input[bool]] = None,
            comment: Optional[pulumi.Input[str]] = None,
            disabled: Optional[pulumi.Input[bool]] = None,
            dont_fragment: Optional[pulumi.Input[str]] = None,
            dscp: Optional[pulumi.Input[str]] = None,
            ipsec_secret: Optional[pulumi.Input[str]] = None,
            keepalive: Optional[pulumi.Input[str]] = None,
            l2mtu: Optional[pulumi.Input[int]] = None,
            local_address: Optional[pulumi.Input[str]] = None,
            mtu: Optional[pulumi.Input[str]] = None,
            name: Optional[pulumi.Input[str]] = None,
            remote_address: Optional[pulumi.Input[str]] = None,
            running: Optional[pulumi.Input[bool]] = None) -> 'ResourceInterfaceGre':
        """
        Get an existing ResourceInterfaceGre resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[bool] allow_fast_path: Whether to allow FastPath processing. Must be disabled if IPsec tunneling is used.
        :param pulumi.Input[bool] clamp_tcp_mss: Controls whether to change MSS size for received TCP SYN packets. When enabled, a router will change the MSS size for received TCP SYN packets if the current MSS size exceeds the tunnel interface MTU (taking into account the TCP/IP overhead). The received encapsulated packet will still contain the original MSS, and only after decapsulation the MSS is changed.
        :param pulumi.Input[str] dscp: Set dscp value in GRE header to a fixed value '0..63' or 'inherit' from dscp value taken from tunnelled traffic.
        :param pulumi.Input[str] ipsec_secret: When secret is specified, router adds dynamic IPsec peer to remote-address with pre-shared key and policy (by default phase2 uses sha1/aes128cbc).
        :param pulumi.Input[str] keepalive: Tunnel keepalive parameter sets the time interval in which the tunnel running flag will remain even if the remote end of tunnel goes down. If configured time,retries fail, interface running flag is removed. Parameters are written in following format: KeepaliveInterval,KeepaliveRetries where KeepaliveInterval is time interval and KeepaliveRetries - number of retry attempts. KeepaliveInterval is integer 0..4294967295
        :param pulumi.Input[int] l2mtu: Layer2 Maximum transmission unit.
        :param pulumi.Input[str] mtu: Layer3 Maximum transmission unit ('auto', 0 .. 65535)
        :param pulumi.Input[str] name: Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
               resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
               integrity for that resource!
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ResourceInterfaceGreState.__new__(_ResourceInterfaceGreState)

        __props__.__dict__["___id_"] = ___id_
        __props__.__dict__["___path_"] = ___path_
        __props__.__dict__["actual_mtu"] = actual_mtu
        __props__.__dict__["allow_fast_path"] = allow_fast_path
        __props__.__dict__["clamp_tcp_mss"] = clamp_tcp_mss
        __props__.__dict__["comment"] = comment
        __props__.__dict__["disabled"] = disabled
        __props__.__dict__["dont_fragment"] = dont_fragment
        __props__.__dict__["dscp"] = dscp
        __props__.__dict__["ipsec_secret"] = ipsec_secret
        __props__.__dict__["keepalive"] = keepalive
        __props__.__dict__["l2mtu"] = l2mtu
        __props__.__dict__["local_address"] = local_address
        __props__.__dict__["mtu"] = mtu
        __props__.__dict__["name"] = name
        __props__.__dict__["remote_address"] = remote_address
        __props__.__dict__["running"] = running
        return ResourceInterfaceGre(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def ___id_(self) -> pulumi.Output[Optional[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @property
    @pulumi.getter
    def ___path_(self) -> pulumi.Output[Optional[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @property
    @pulumi.getter(name="actualMtu")
    def actual_mtu(self) -> pulumi.Output[int]:
        return pulumi.get(self, "actual_mtu")

    @property
    @pulumi.getter(name="allowFastPath")
    def allow_fast_path(self) -> pulumi.Output[Optional[bool]]:
        """
        Whether to allow FastPath processing. Must be disabled if IPsec tunneling is used.
        """
        return pulumi.get(self, "allow_fast_path")

    @property
    @pulumi.getter(name="clampTcpMss")
    def clamp_tcp_mss(self) -> pulumi.Output[Optional[bool]]:
        """
        Controls whether to change MSS size for received TCP SYN packets. When enabled, a router will change the MSS size for received TCP SYN packets if the current MSS size exceeds the tunnel interface MTU (taking into account the TCP/IP overhead). The received encapsulated packet will still contain the original MSS, and only after decapsulation the MSS is changed.
        """
        return pulumi.get(self, "clamp_tcp_mss")

    @property
    @pulumi.getter
    def comment(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def disabled(self) -> pulumi.Output[Optional[bool]]:
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter(name="dontFragment")
    def dont_fragment(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "dont_fragment")

    @property
    @pulumi.getter
    def dscp(self) -> pulumi.Output[Optional[str]]:
        """
        Set dscp value in GRE header to a fixed value '0..63' or 'inherit' from dscp value taken from tunnelled traffic.
        """
        return pulumi.get(self, "dscp")

    @property
    @pulumi.getter(name="ipsecSecret")
    def ipsec_secret(self) -> pulumi.Output[Optional[str]]:
        """
        When secret is specified, router adds dynamic IPsec peer to remote-address with pre-shared key and policy (by default phase2 uses sha1/aes128cbc).
        """
        return pulumi.get(self, "ipsec_secret")

    @property
    @pulumi.getter
    def keepalive(self) -> pulumi.Output[Optional[str]]:
        """
        Tunnel keepalive parameter sets the time interval in which the tunnel running flag will remain even if the remote end of tunnel goes down. If configured time,retries fail, interface running flag is removed. Parameters are written in following format: KeepaliveInterval,KeepaliveRetries where KeepaliveInterval is time interval and KeepaliveRetries - number of retry attempts. KeepaliveInterval is integer 0..4294967295
        """
        return pulumi.get(self, "keepalive")

    @property
    @pulumi.getter
    def l2mtu(self) -> pulumi.Output[int]:
        """
        Layer2 Maximum transmission unit.
        """
        return pulumi.get(self, "l2mtu")

    @property
    @pulumi.getter(name="localAddress")
    def local_address(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "local_address")

    @property
    @pulumi.getter
    def mtu(self) -> pulumi.Output[str]:
        """
        Layer3 Maximum transmission unit ('auto', 0 .. 65535)
        """
        return pulumi.get(self, "mtu")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        Changing the name of this resource will force it to be recreated. > The links of other configuration properties to this
        resource may be lost! > Changing the name of the resource outside of a Terraform will result in a loss of control
        integrity for that resource!
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> pulumi.Output[str]:
        return pulumi.get(self, "remote_address")

    @property
    @pulumi.getter
    def running(self) -> pulumi.Output[bool]:
        return pulumi.get(self, "running")

