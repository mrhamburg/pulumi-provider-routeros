# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = ['ProfileArgs', 'Profile']

@pulumi.input_type
class ProfileArgs:
    def __init__(__self__, *,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 address_list: Optional[pulumi.Input[str]] = None,
                 bridge: Optional[pulumi.Input[str]] = None,
                 bridge_horizon: Optional[pulumi.Input[int]] = None,
                 bridge_learning: Optional[pulumi.Input[str]] = None,
                 bridge_path_cost: Optional[pulumi.Input[int]] = None,
                 bridge_port_priority: Optional[pulumi.Input[int]] = None,
                 change_tcp_mss: Optional[pulumi.Input[str]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 dhcpv6_pd_pool: Optional[pulumi.Input[str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 idle_timeout: Optional[pulumi.Input[str]] = None,
                 incoming_filter: Optional[pulumi.Input[str]] = None,
                 insert_queue_before: Optional[pulumi.Input[str]] = None,
                 interface_list: Optional[pulumi.Input[str]] = None,
                 local_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 on_down: Optional[pulumi.Input[str]] = None,
                 on_up: Optional[pulumi.Input[str]] = None,
                 only_one: Optional[pulumi.Input[str]] = None,
                 outgoing_filter: Optional[pulumi.Input[str]] = None,
                 parent_queue: Optional[pulumi.Input[str]] = None,
                 queue_type: Optional[pulumi.Input[str]] = None,
                 rate_limit: Optional[pulumi.Input[str]] = None,
                 remote_address: Optional[pulumi.Input[str]] = None,
                 remote_ipv6_prefix_pool: Optional[pulumi.Input[str]] = None,
                 session_timeout: Optional[pulumi.Input[str]] = None,
                 use_compression: Optional[pulumi.Input[str]] = None,
                 use_encryption: Optional[pulumi.Input[str]] = None,
                 use_ipv6: Optional[pulumi.Input[str]] = None,
                 use_mpls: Optional[pulumi.Input[str]] = None,
                 use_upnp: Optional[pulumi.Input[str]] = None,
                 wins_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        The set of arguments for constructing a Profile resource.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] address_list: Address list name to which ppp assigned (on server) or received (on client) address will be added.
        :param pulumi.Input[str] bridge: Name of the bridge interface to which ppp interface will be added as a slave port. Both  tunnel endpoints (server and client) must be in bridge in order to make  this work, see more details on the BCP bridging manual.
        :param pulumi.Input[int] bridge_horizon: Used  split-horizon value for the dynamically created bridge port. Can be  used to prevent bridging loops and isolate traffic. Set the same value  for a group of ports, to prevent them from sending data to ports with  the same horizon value.
        :param pulumi.Input[str] bridge_learning: Changes MAC learning behavior on the dynamically created bridge port: yes - enables MAC learning no - disables MAC learning default - derive this value from the interface default profile; same as yes if this is the interface default profile.
        :param pulumi.Input[int] bridge_path_cost: Used  path cost for the dynamically created bridge port, used by STP/RSTP to  determine the best path, used by MSTP to determine the best path between  regions. This property has no effect when a bridge protocol-mode is set to none.
        :param pulumi.Input[int] bridge_port_priority: Used  priority for the dynamically created bridge port, used by STP/RSTP to  determine the root port, used by MSTP to determine root port between  regions. This property has no effect when a bridge protocol-mode is set  to none.
        :param pulumi.Input[str] change_tcp_mss: Modifies connection MSS settings (applies only for IPv4): yes - adjust connection MSS value no - do not adjust connection MSS value default - derive this value from the interface default profile; same as no if this is the interface default profile.
        :param pulumi.Input[str] dhcpv6_pd_pool: Name of the IPv6 pool which will be used by dynamically created DHCPv6-PD server when client connects. [Read more >>](https://wiki.mikrotik.com/wiki/Manual:IPv6_PD_over_PPP)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: IP address of the DNS server that is supplied to ppp clients.
        :param pulumi.Input[str] idle_timeout: Specifies  the amount of time after which the link will be terminated if there are  no activity present. Timeout is not set by default.
        :param pulumi.Input[str] incoming_filter: Firewall  chain name for incoming packets. Specified chain gets control for each  packet coming from the client. The ppp chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the examples section.
        :param pulumi.Input[str] insert_queue_before: Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        :param pulumi.Input[str] interface_list: Interface list name.
        :param pulumi.Input[str] local_address: Tunnel address or name of the pool from which address is assigned to ppp interface locally.
        :param pulumi.Input[str] name: PPP profile name.
        :param pulumi.Input[str] on_down: Execute script on user logging off. See on-up for more details.
        :param pulumi.Input[str] on_up: Execute script on user login-event. These are available variables that are accessible for the event script: *user *local-address *remote-address *caller-id *called-id *interface.
        :param pulumi.Input[str] only_one: Defines whether a user is allowed to have more than one ppp session at a time yes - a user is not allowed to have more than one ppp session at a time no - the user is allowed to have more than one ppp session at a time default - derive this value from the interface default profile; same as no if this is the interface default profile.
        :param pulumi.Input[str] outgoing_filter: Firewall  chain name for outgoing packets. The specified chain gets control for  each packet going to the client. The PPP chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the Examples section.
        :param pulumi.Input[str] parent_queue: Name of parent simple queue.
        :param pulumi.Input[str] queue_type: Queue types.
        :param pulumi.Input[str] rate_limit: Rate limitation in form of rx-rate[/tx-rate]  [rx-burst-rate[/tx-burst-rate] [rx-burst-threshold[/tx-burst-threshold]  [rx-burst-time[/tx-burst-time] [priority] [rx-rate-min[/tx-rate-min]]]] from the point of view of the router (so 'rx' is client upload, and  'tx' is client download). All rates are measured in bits per second,  unless followed by optional 'k' suffix (kilobits per second) or 'M'  suffix (megabits per second). If tx-rate is not specified, rx-rate  serves as tx-rate too. The same applies for tx-burst-rate,  tx-burst-threshold and tx-burst-time. If both rx-burst-threshold and  tx-burst-threshold are not specified (but burst-rate is specified),  rx-rate and tx-rate are used as burst thresholds. If both rx-burst-time  and tx-burst-time are not specified, 1s is used as default. Priority  takes values 1..8, where 1 implies the highest priority, but 8 - the  lowest. If rx-rate-min and tx-rate-min are not specified rx-rate and  tx-rate values are used. The rx-rate-min and tx-rate-min values can not  exceed rx-rate and tx-rate values.
        :param pulumi.Input[str] remote_address: Tunnel address or name of the pool from which address is assigned to remote ppp interface.
        :param pulumi.Input[str] remote_ipv6_prefix_pool: Assign prefix from IPv6 pool to the client and install corresponding IPv6 route.
        :param pulumi.Input[str] session_timeout: Maximum time the connection can stay up. By default no time limit is set.
        :param pulumi.Input[str] use_compression: Specifies whether to use data compression or not. yes - enable data compression no - disable data compression default - derive this value from the interface default profile; same as no if this is the interface default profile This setting does not affect OVPN tunnels.
        :param pulumi.Input[str] use_encryption: Specifies whether to use data encryption or not. yes - enable data encryption no - disable data encryption default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires encryption This setting does not work on OVPN and SSTP tunnels.
        :param pulumi.Input[str] use_ipv6: Specifies whether to allow IPv6. By default is enabled if IPv6 package is installed. yes - enable IPv6 support no - disable IPv6 support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires IPv6 support.
        :param pulumi.Input[str] use_mpls: Specifies whether to allow MPLS over PPP. yes - enable MPLS support no - disable MPLS support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires MPLS support
        :param pulumi.Input[str] use_upnp: Specifies whether to allow UPnP.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] wins_servers: IP address of the WINS server to supply to Windows clients.
        """
        if ___id_ is not None:
            pulumi.set(__self__, "___id_", ___id_)
        if ___path_ is not None:
            pulumi.set(__self__, "___path_", ___path_)
        if address_list is not None:
            pulumi.set(__self__, "address_list", address_list)
        if bridge is not None:
            pulumi.set(__self__, "bridge", bridge)
        if bridge_horizon is not None:
            pulumi.set(__self__, "bridge_horizon", bridge_horizon)
        if bridge_learning is not None:
            pulumi.set(__self__, "bridge_learning", bridge_learning)
        if bridge_path_cost is not None:
            pulumi.set(__self__, "bridge_path_cost", bridge_path_cost)
        if bridge_port_priority is not None:
            pulumi.set(__self__, "bridge_port_priority", bridge_port_priority)
        if change_tcp_mss is not None:
            pulumi.set(__self__, "change_tcp_mss", change_tcp_mss)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dhcpv6_pd_pool is not None:
            pulumi.set(__self__, "dhcpv6_pd_pool", dhcpv6_pd_pool)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if incoming_filter is not None:
            pulumi.set(__self__, "incoming_filter", incoming_filter)
        if insert_queue_before is not None:
            pulumi.set(__self__, "insert_queue_before", insert_queue_before)
        if interface_list is not None:
            pulumi.set(__self__, "interface_list", interface_list)
        if local_address is not None:
            pulumi.set(__self__, "local_address", local_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if on_down is not None:
            pulumi.set(__self__, "on_down", on_down)
        if on_up is not None:
            pulumi.set(__self__, "on_up", on_up)
        if only_one is not None:
            pulumi.set(__self__, "only_one", only_one)
        if outgoing_filter is not None:
            pulumi.set(__self__, "outgoing_filter", outgoing_filter)
        if parent_queue is not None:
            pulumi.set(__self__, "parent_queue", parent_queue)
        if queue_type is not None:
            pulumi.set(__self__, "queue_type", queue_type)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)
        if remote_address is not None:
            pulumi.set(__self__, "remote_address", remote_address)
        if remote_ipv6_prefix_pool is not None:
            pulumi.set(__self__, "remote_ipv6_prefix_pool", remote_ipv6_prefix_pool)
        if session_timeout is not None:
            pulumi.set(__self__, "session_timeout", session_timeout)
        if use_compression is not None:
            pulumi.set(__self__, "use_compression", use_compression)
        if use_encryption is not None:
            pulumi.set(__self__, "use_encryption", use_encryption)
        if use_ipv6 is not None:
            pulumi.set(__self__, "use_ipv6", use_ipv6)
        if use_mpls is not None:
            pulumi.set(__self__, "use_mpls", use_mpls)
        if use_upnp is not None:
            pulumi.set(__self__, "use_upnp", use_upnp)
        if wins_servers is not None:
            pulumi.set(__self__, "wins_servers", wins_servers)

    @property
    @pulumi.getter
    def ___id_(self) -> Optional[pulumi.Input[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @___id_.setter
    def ___id_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "___id_", value)

    @property
    @pulumi.getter
    def ___path_(self) -> Optional[pulumi.Input[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @___path_.setter
    def ___path_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "___path_", value)

    @property
    @pulumi.getter(name="addressList")
    def address_list(self) -> Optional[pulumi.Input[str]]:
        """
        Address list name to which ppp assigned (on server) or received (on client) address will be added.
        """
        return pulumi.get(self, "address_list")

    @address_list.setter
    def address_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_list", value)

    @property
    @pulumi.getter
    def bridge(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the bridge interface to which ppp interface will be added as a slave port. Both  tunnel endpoints (server and client) must be in bridge in order to make  this work, see more details on the BCP bridging manual.
        """
        return pulumi.get(self, "bridge")

    @bridge.setter
    def bridge(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bridge", value)

    @property
    @pulumi.getter(name="bridgeHorizon")
    def bridge_horizon(self) -> Optional[pulumi.Input[int]]:
        """
        Used  split-horizon value for the dynamically created bridge port. Can be  used to prevent bridging loops and isolate traffic. Set the same value  for a group of ports, to prevent them from sending data to ports with  the same horizon value.
        """
        return pulumi.get(self, "bridge_horizon")

    @bridge_horizon.setter
    def bridge_horizon(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bridge_horizon", value)

    @property
    @pulumi.getter(name="bridgeLearning")
    def bridge_learning(self) -> Optional[pulumi.Input[str]]:
        """
        Changes MAC learning behavior on the dynamically created bridge port: yes - enables MAC learning no - disables MAC learning default - derive this value from the interface default profile; same as yes if this is the interface default profile.
        """
        return pulumi.get(self, "bridge_learning")

    @bridge_learning.setter
    def bridge_learning(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bridge_learning", value)

    @property
    @pulumi.getter(name="bridgePathCost")
    def bridge_path_cost(self) -> Optional[pulumi.Input[int]]:
        """
        Used  path cost for the dynamically created bridge port, used by STP/RSTP to  determine the best path, used by MSTP to determine the best path between  regions. This property has no effect when a bridge protocol-mode is set to none.
        """
        return pulumi.get(self, "bridge_path_cost")

    @bridge_path_cost.setter
    def bridge_path_cost(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bridge_path_cost", value)

    @property
    @pulumi.getter(name="bridgePortPriority")
    def bridge_port_priority(self) -> Optional[pulumi.Input[int]]:
        """
        Used  priority for the dynamically created bridge port, used by STP/RSTP to  determine the root port, used by MSTP to determine root port between  regions. This property has no effect when a bridge protocol-mode is set  to none.
        """
        return pulumi.get(self, "bridge_port_priority")

    @bridge_port_priority.setter
    def bridge_port_priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bridge_port_priority", value)

    @property
    @pulumi.getter(name="changeTcpMss")
    def change_tcp_mss(self) -> Optional[pulumi.Input[str]]:
        """
        Modifies connection MSS settings (applies only for IPv4): yes - adjust connection MSS value no - do not adjust connection MSS value default - derive this value from the interface default profile; same as no if this is the interface default profile.
        """
        return pulumi.get(self, "change_tcp_mss")

    @change_tcp_mss.setter
    def change_tcp_mss(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "change_tcp_mss", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter(name="dhcpv6PdPool")
    def dhcpv6_pd_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the IPv6 pool which will be used by dynamically created DHCPv6-PD server when client connects. [Read more >>](https://wiki.mikrotik.com/wiki/Manual:IPv6_PD_over_PPP)
        """
        return pulumi.get(self, "dhcpv6_pd_pool")

    @dhcpv6_pd_pool.setter
    def dhcpv6_pd_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dhcpv6_pd_pool", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP address of the DNS server that is supplied to ppp clients.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies  the amount of time after which the link will be terminated if there are  no activity present. Timeout is not set by default.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idle_timeout", value)

    @property
    @pulumi.getter(name="incomingFilter")
    def incoming_filter(self) -> Optional[pulumi.Input[str]]:
        """
        Firewall  chain name for incoming packets. Specified chain gets control for each  packet coming from the client. The ppp chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the examples section.
        """
        return pulumi.get(self, "incoming_filter")

    @incoming_filter.setter
    def incoming_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "incoming_filter", value)

    @property
    @pulumi.getter(name="insertQueueBefore")
    def insert_queue_before(self) -> Optional[pulumi.Input[str]]:
        """
        Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        """
        return pulumi.get(self, "insert_queue_before")

    @insert_queue_before.setter
    def insert_queue_before(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "insert_queue_before", value)

    @property
    @pulumi.getter(name="interfaceList")
    def interface_list(self) -> Optional[pulumi.Input[str]]:
        """
        Interface list name.
        """
        return pulumi.get(self, "interface_list")

    @interface_list.setter
    def interface_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface_list", value)

    @property
    @pulumi.getter(name="localAddress")
    def local_address(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel address or name of the pool from which address is assigned to ppp interface locally.
        """
        return pulumi.get(self, "local_address")

    @local_address.setter
    def local_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        PPP profile name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="onDown")
    def on_down(self) -> Optional[pulumi.Input[str]]:
        """
        Execute script on user logging off. See on-up for more details.
        """
        return pulumi.get(self, "on_down")

    @on_down.setter
    def on_down(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_down", value)

    @property
    @pulumi.getter(name="onUp")
    def on_up(self) -> Optional[pulumi.Input[str]]:
        """
        Execute script on user login-event. These are available variables that are accessible for the event script: *user *local-address *remote-address *caller-id *called-id *interface.
        """
        return pulumi.get(self, "on_up")

    @on_up.setter
    def on_up(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_up", value)

    @property
    @pulumi.getter(name="onlyOne")
    def only_one(self) -> Optional[pulumi.Input[str]]:
        """
        Defines whether a user is allowed to have more than one ppp session at a time yes - a user is not allowed to have more than one ppp session at a time no - the user is allowed to have more than one ppp session at a time default - derive this value from the interface default profile; same as no if this is the interface default profile.
        """
        return pulumi.get(self, "only_one")

    @only_one.setter
    def only_one(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "only_one", value)

    @property
    @pulumi.getter(name="outgoingFilter")
    def outgoing_filter(self) -> Optional[pulumi.Input[str]]:
        """
        Firewall  chain name for outgoing packets. The specified chain gets control for  each packet going to the client. The PPP chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the Examples section.
        """
        return pulumi.get(self, "outgoing_filter")

    @outgoing_filter.setter
    def outgoing_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "outgoing_filter", value)

    @property
    @pulumi.getter(name="parentQueue")
    def parent_queue(self) -> Optional[pulumi.Input[str]]:
        """
        Name of parent simple queue.
        """
        return pulumi.get(self, "parent_queue")

    @parent_queue.setter
    def parent_queue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_queue", value)

    @property
    @pulumi.getter(name="queueType")
    def queue_type(self) -> Optional[pulumi.Input[str]]:
        """
        Queue types.
        """
        return pulumi.get(self, "queue_type")

    @queue_type.setter
    def queue_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "queue_type", value)

    @property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input[str]]:
        """
        Rate limitation in form of rx-rate[/tx-rate]  [rx-burst-rate[/tx-burst-rate] [rx-burst-threshold[/tx-burst-threshold]  [rx-burst-time[/tx-burst-time] [priority] [rx-rate-min[/tx-rate-min]]]] from the point of view of the router (so 'rx' is client upload, and  'tx' is client download). All rates are measured in bits per second,  unless followed by optional 'k' suffix (kilobits per second) or 'M'  suffix (megabits per second). If tx-rate is not specified, rx-rate  serves as tx-rate too. The same applies for tx-burst-rate,  tx-burst-threshold and tx-burst-time. If both rx-burst-threshold and  tx-burst-threshold are not specified (but burst-rate is specified),  rx-rate and tx-rate are used as burst thresholds. If both rx-burst-time  and tx-burst-time are not specified, 1s is used as default. Priority  takes values 1..8, where 1 implies the highest priority, but 8 - the  lowest. If rx-rate-min and tx-rate-min are not specified rx-rate and  tx-rate values are used. The rx-rate-min and tx-rate-min values can not  exceed rx-rate and tx-rate values.
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rate_limit", value)

    @property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel address or name of the pool from which address is assigned to remote ppp interface.
        """
        return pulumi.get(self, "remote_address")

    @remote_address.setter
    def remote_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_address", value)

    @property
    @pulumi.getter(name="remoteIpv6PrefixPool")
    def remote_ipv6_prefix_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Assign prefix from IPv6 pool to the client and install corresponding IPv6 route.
        """
        return pulumi.get(self, "remote_ipv6_prefix_pool")

    @remote_ipv6_prefix_pool.setter
    def remote_ipv6_prefix_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_ipv6_prefix_pool", value)

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum time the connection can stay up. By default no time limit is set.
        """
        return pulumi.get(self, "session_timeout")

    @session_timeout.setter
    def session_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_timeout", value)

    @property
    @pulumi.getter(name="useCompression")
    def use_compression(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to use data compression or not. yes - enable data compression no - disable data compression default - derive this value from the interface default profile; same as no if this is the interface default profile This setting does not affect OVPN tunnels.
        """
        return pulumi.get(self, "use_compression")

    @use_compression.setter
    def use_compression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_compression", value)

    @property
    @pulumi.getter(name="useEncryption")
    def use_encryption(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to use data encryption or not. yes - enable data encryption no - disable data encryption default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires encryption This setting does not work on OVPN and SSTP tunnels.
        """
        return pulumi.get(self, "use_encryption")

    @use_encryption.setter
    def use_encryption(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_encryption", value)

    @property
    @pulumi.getter(name="useIpv6")
    def use_ipv6(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to allow IPv6. By default is enabled if IPv6 package is installed. yes - enable IPv6 support no - disable IPv6 support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires IPv6 support.
        """
        return pulumi.get(self, "use_ipv6")

    @use_ipv6.setter
    def use_ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_ipv6", value)

    @property
    @pulumi.getter(name="useMpls")
    def use_mpls(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to allow MPLS over PPP. yes - enable MPLS support no - disable MPLS support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires MPLS support
        """
        return pulumi.get(self, "use_mpls")

    @use_mpls.setter
    def use_mpls(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_mpls", value)

    @property
    @pulumi.getter(name="useUpnp")
    def use_upnp(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to allow UPnP.
        """
        return pulumi.get(self, "use_upnp")

    @use_upnp.setter
    def use_upnp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_upnp", value)

    @property
    @pulumi.getter(name="winsServers")
    def wins_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP address of the WINS server to supply to Windows clients.
        """
        return pulumi.get(self, "wins_servers")

    @wins_servers.setter
    def wins_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "wins_servers", value)


@pulumi.input_type
class _ProfileState:
    def __init__(__self__, *,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 address_list: Optional[pulumi.Input[str]] = None,
                 bridge: Optional[pulumi.Input[str]] = None,
                 bridge_horizon: Optional[pulumi.Input[int]] = None,
                 bridge_learning: Optional[pulumi.Input[str]] = None,
                 bridge_path_cost: Optional[pulumi.Input[int]] = None,
                 bridge_port_priority: Optional[pulumi.Input[int]] = None,
                 change_tcp_mss: Optional[pulumi.Input[str]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 default: Optional[pulumi.Input[str]] = None,
                 dhcpv6_pd_pool: Optional[pulumi.Input[str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 idle_timeout: Optional[pulumi.Input[str]] = None,
                 incoming_filter: Optional[pulumi.Input[str]] = None,
                 insert_queue_before: Optional[pulumi.Input[str]] = None,
                 interface_list: Optional[pulumi.Input[str]] = None,
                 local_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 on_down: Optional[pulumi.Input[str]] = None,
                 on_up: Optional[pulumi.Input[str]] = None,
                 only_one: Optional[pulumi.Input[str]] = None,
                 outgoing_filter: Optional[pulumi.Input[str]] = None,
                 parent_queue: Optional[pulumi.Input[str]] = None,
                 queue_type: Optional[pulumi.Input[str]] = None,
                 rate_limit: Optional[pulumi.Input[str]] = None,
                 remote_address: Optional[pulumi.Input[str]] = None,
                 remote_ipv6_prefix_pool: Optional[pulumi.Input[str]] = None,
                 session_timeout: Optional[pulumi.Input[str]] = None,
                 use_compression: Optional[pulumi.Input[str]] = None,
                 use_encryption: Optional[pulumi.Input[str]] = None,
                 use_ipv6: Optional[pulumi.Input[str]] = None,
                 use_mpls: Optional[pulumi.Input[str]] = None,
                 use_upnp: Optional[pulumi.Input[str]] = None,
                 wins_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Input properties used for looking up and filtering Profile resources.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] address_list: Address list name to which ppp assigned (on server) or received (on client) address will be added.
        :param pulumi.Input[str] bridge: Name of the bridge interface to which ppp interface will be added as a slave port. Both  tunnel endpoints (server and client) must be in bridge in order to make  this work, see more details on the BCP bridging manual.
        :param pulumi.Input[int] bridge_horizon: Used  split-horizon value for the dynamically created bridge port. Can be  used to prevent bridging loops and isolate traffic. Set the same value  for a group of ports, to prevent them from sending data to ports with  the same horizon value.
        :param pulumi.Input[str] bridge_learning: Changes MAC learning behavior on the dynamically created bridge port: yes - enables MAC learning no - disables MAC learning default - derive this value from the interface default profile; same as yes if this is the interface default profile.
        :param pulumi.Input[int] bridge_path_cost: Used  path cost for the dynamically created bridge port, used by STP/RSTP to  determine the best path, used by MSTP to determine the best path between  regions. This property has no effect when a bridge protocol-mode is set to none.
        :param pulumi.Input[int] bridge_port_priority: Used  priority for the dynamically created bridge port, used by STP/RSTP to  determine the root port, used by MSTP to determine root port between  regions. This property has no effect when a bridge protocol-mode is set  to none.
        :param pulumi.Input[str] change_tcp_mss: Modifies connection MSS settings (applies only for IPv4): yes - adjust connection MSS value no - do not adjust connection MSS value default - derive this value from the interface default profile; same as no if this is the interface default profile.
        :param pulumi.Input[str] default: Default profile sign.
        :param pulumi.Input[str] dhcpv6_pd_pool: Name of the IPv6 pool which will be used by dynamically created DHCPv6-PD server when client connects. [Read more >>](https://wiki.mikrotik.com/wiki/Manual:IPv6_PD_over_PPP)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: IP address of the DNS server that is supplied to ppp clients.
        :param pulumi.Input[str] idle_timeout: Specifies  the amount of time after which the link will be terminated if there are  no activity present. Timeout is not set by default.
        :param pulumi.Input[str] incoming_filter: Firewall  chain name for incoming packets. Specified chain gets control for each  packet coming from the client. The ppp chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the examples section.
        :param pulumi.Input[str] insert_queue_before: Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        :param pulumi.Input[str] interface_list: Interface list name.
        :param pulumi.Input[str] local_address: Tunnel address or name of the pool from which address is assigned to ppp interface locally.
        :param pulumi.Input[str] name: PPP profile name.
        :param pulumi.Input[str] on_down: Execute script on user logging off. See on-up for more details.
        :param pulumi.Input[str] on_up: Execute script on user login-event. These are available variables that are accessible for the event script: *user *local-address *remote-address *caller-id *called-id *interface.
        :param pulumi.Input[str] only_one: Defines whether a user is allowed to have more than one ppp session at a time yes - a user is not allowed to have more than one ppp session at a time no - the user is allowed to have more than one ppp session at a time default - derive this value from the interface default profile; same as no if this is the interface default profile.
        :param pulumi.Input[str] outgoing_filter: Firewall  chain name for outgoing packets. The specified chain gets control for  each packet going to the client. The PPP chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the Examples section.
        :param pulumi.Input[str] parent_queue: Name of parent simple queue.
        :param pulumi.Input[str] queue_type: Queue types.
        :param pulumi.Input[str] rate_limit: Rate limitation in form of rx-rate[/tx-rate]  [rx-burst-rate[/tx-burst-rate] [rx-burst-threshold[/tx-burst-threshold]  [rx-burst-time[/tx-burst-time] [priority] [rx-rate-min[/tx-rate-min]]]] from the point of view of the router (so 'rx' is client upload, and  'tx' is client download). All rates are measured in bits per second,  unless followed by optional 'k' suffix (kilobits per second) or 'M'  suffix (megabits per second). If tx-rate is not specified, rx-rate  serves as tx-rate too. The same applies for tx-burst-rate,  tx-burst-threshold and tx-burst-time. If both rx-burst-threshold and  tx-burst-threshold are not specified (but burst-rate is specified),  rx-rate and tx-rate are used as burst thresholds. If both rx-burst-time  and tx-burst-time are not specified, 1s is used as default. Priority  takes values 1..8, where 1 implies the highest priority, but 8 - the  lowest. If rx-rate-min and tx-rate-min are not specified rx-rate and  tx-rate values are used. The rx-rate-min and tx-rate-min values can not  exceed rx-rate and tx-rate values.
        :param pulumi.Input[str] remote_address: Tunnel address or name of the pool from which address is assigned to remote ppp interface.
        :param pulumi.Input[str] remote_ipv6_prefix_pool: Assign prefix from IPv6 pool to the client and install corresponding IPv6 route.
        :param pulumi.Input[str] session_timeout: Maximum time the connection can stay up. By default no time limit is set.
        :param pulumi.Input[str] use_compression: Specifies whether to use data compression or not. yes - enable data compression no - disable data compression default - derive this value from the interface default profile; same as no if this is the interface default profile This setting does not affect OVPN tunnels.
        :param pulumi.Input[str] use_encryption: Specifies whether to use data encryption or not. yes - enable data encryption no - disable data encryption default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires encryption This setting does not work on OVPN and SSTP tunnels.
        :param pulumi.Input[str] use_ipv6: Specifies whether to allow IPv6. By default is enabled if IPv6 package is installed. yes - enable IPv6 support no - disable IPv6 support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires IPv6 support.
        :param pulumi.Input[str] use_mpls: Specifies whether to allow MPLS over PPP. yes - enable MPLS support no - disable MPLS support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires MPLS support
        :param pulumi.Input[str] use_upnp: Specifies whether to allow UPnP.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] wins_servers: IP address of the WINS server to supply to Windows clients.
        """
        if ___id_ is not None:
            pulumi.set(__self__, "___id_", ___id_)
        if ___path_ is not None:
            pulumi.set(__self__, "___path_", ___path_)
        if address_list is not None:
            pulumi.set(__self__, "address_list", address_list)
        if bridge is not None:
            pulumi.set(__self__, "bridge", bridge)
        if bridge_horizon is not None:
            pulumi.set(__self__, "bridge_horizon", bridge_horizon)
        if bridge_learning is not None:
            pulumi.set(__self__, "bridge_learning", bridge_learning)
        if bridge_path_cost is not None:
            pulumi.set(__self__, "bridge_path_cost", bridge_path_cost)
        if bridge_port_priority is not None:
            pulumi.set(__self__, "bridge_port_priority", bridge_port_priority)
        if change_tcp_mss is not None:
            pulumi.set(__self__, "change_tcp_mss", change_tcp_mss)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if dhcpv6_pd_pool is not None:
            pulumi.set(__self__, "dhcpv6_pd_pool", dhcpv6_pd_pool)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if incoming_filter is not None:
            pulumi.set(__self__, "incoming_filter", incoming_filter)
        if insert_queue_before is not None:
            pulumi.set(__self__, "insert_queue_before", insert_queue_before)
        if interface_list is not None:
            pulumi.set(__self__, "interface_list", interface_list)
        if local_address is not None:
            pulumi.set(__self__, "local_address", local_address)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if on_down is not None:
            pulumi.set(__self__, "on_down", on_down)
        if on_up is not None:
            pulumi.set(__self__, "on_up", on_up)
        if only_one is not None:
            pulumi.set(__self__, "only_one", only_one)
        if outgoing_filter is not None:
            pulumi.set(__self__, "outgoing_filter", outgoing_filter)
        if parent_queue is not None:
            pulumi.set(__self__, "parent_queue", parent_queue)
        if queue_type is not None:
            pulumi.set(__self__, "queue_type", queue_type)
        if rate_limit is not None:
            pulumi.set(__self__, "rate_limit", rate_limit)
        if remote_address is not None:
            pulumi.set(__self__, "remote_address", remote_address)
        if remote_ipv6_prefix_pool is not None:
            pulumi.set(__self__, "remote_ipv6_prefix_pool", remote_ipv6_prefix_pool)
        if session_timeout is not None:
            pulumi.set(__self__, "session_timeout", session_timeout)
        if use_compression is not None:
            pulumi.set(__self__, "use_compression", use_compression)
        if use_encryption is not None:
            pulumi.set(__self__, "use_encryption", use_encryption)
        if use_ipv6 is not None:
            pulumi.set(__self__, "use_ipv6", use_ipv6)
        if use_mpls is not None:
            pulumi.set(__self__, "use_mpls", use_mpls)
        if use_upnp is not None:
            pulumi.set(__self__, "use_upnp", use_upnp)
        if wins_servers is not None:
            pulumi.set(__self__, "wins_servers", wins_servers)

    @property
    @pulumi.getter
    def ___id_(self) -> Optional[pulumi.Input[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @___id_.setter
    def ___id_(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "___id_", value)

    @property
    @pulumi.getter
    def ___path_(self) -> Optional[pulumi.Input[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @___path_.setter
    def ___path_(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "___path_", value)

    @property
    @pulumi.getter(name="addressList")
    def address_list(self) -> Optional[pulumi.Input[str]]:
        """
        Address list name to which ppp assigned (on server) or received (on client) address will be added.
        """
        return pulumi.get(self, "address_list")

    @address_list.setter
    def address_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address_list", value)

    @property
    @pulumi.getter
    def bridge(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the bridge interface to which ppp interface will be added as a slave port. Both  tunnel endpoints (server and client) must be in bridge in order to make  this work, see more details on the BCP bridging manual.
        """
        return pulumi.get(self, "bridge")

    @bridge.setter
    def bridge(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bridge", value)

    @property
    @pulumi.getter(name="bridgeHorizon")
    def bridge_horizon(self) -> Optional[pulumi.Input[int]]:
        """
        Used  split-horizon value for the dynamically created bridge port. Can be  used to prevent bridging loops and isolate traffic. Set the same value  for a group of ports, to prevent them from sending data to ports with  the same horizon value.
        """
        return pulumi.get(self, "bridge_horizon")

    @bridge_horizon.setter
    def bridge_horizon(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bridge_horizon", value)

    @property
    @pulumi.getter(name="bridgeLearning")
    def bridge_learning(self) -> Optional[pulumi.Input[str]]:
        """
        Changes MAC learning behavior on the dynamically created bridge port: yes - enables MAC learning no - disables MAC learning default - derive this value from the interface default profile; same as yes if this is the interface default profile.
        """
        return pulumi.get(self, "bridge_learning")

    @bridge_learning.setter
    def bridge_learning(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bridge_learning", value)

    @property
    @pulumi.getter(name="bridgePathCost")
    def bridge_path_cost(self) -> Optional[pulumi.Input[int]]:
        """
        Used  path cost for the dynamically created bridge port, used by STP/RSTP to  determine the best path, used by MSTP to determine the best path between  regions. This property has no effect when a bridge protocol-mode is set to none.
        """
        return pulumi.get(self, "bridge_path_cost")

    @bridge_path_cost.setter
    def bridge_path_cost(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bridge_path_cost", value)

    @property
    @pulumi.getter(name="bridgePortPriority")
    def bridge_port_priority(self) -> Optional[pulumi.Input[int]]:
        """
        Used  priority for the dynamically created bridge port, used by STP/RSTP to  determine the root port, used by MSTP to determine root port between  regions. This property has no effect when a bridge protocol-mode is set  to none.
        """
        return pulumi.get(self, "bridge_port_priority")

    @bridge_port_priority.setter
    def bridge_port_priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bridge_port_priority", value)

    @property
    @pulumi.getter(name="changeTcpMss")
    def change_tcp_mss(self) -> Optional[pulumi.Input[str]]:
        """
        Modifies connection MSS settings (applies only for IPv4): yes - adjust connection MSS value no - do not adjust connection MSS value default - derive this value from the interface default profile; same as no if this is the interface default profile.
        """
        return pulumi.get(self, "change_tcp_mss")

    @change_tcp_mss.setter
    def change_tcp_mss(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "change_tcp_mss", value)

    @property
    @pulumi.getter
    def comment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "comment")

    @comment.setter
    def comment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "comment", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[str]]:
        """
        Default profile sign.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter(name="dhcpv6PdPool")
    def dhcpv6_pd_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the IPv6 pool which will be used by dynamically created DHCPv6-PD server when client connects. [Read more >>](https://wiki.mikrotik.com/wiki/Manual:IPv6_PD_over_PPP)
        """
        return pulumi.get(self, "dhcpv6_pd_pool")

    @dhcpv6_pd_pool.setter
    def dhcpv6_pd_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dhcpv6_pd_pool", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP address of the DNS server that is supplied to ppp clients.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies  the amount of time after which the link will be terminated if there are  no activity present. Timeout is not set by default.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idle_timeout", value)

    @property
    @pulumi.getter(name="incomingFilter")
    def incoming_filter(self) -> Optional[pulumi.Input[str]]:
        """
        Firewall  chain name for incoming packets. Specified chain gets control for each  packet coming from the client. The ppp chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the examples section.
        """
        return pulumi.get(self, "incoming_filter")

    @incoming_filter.setter
    def incoming_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "incoming_filter", value)

    @property
    @pulumi.getter(name="insertQueueBefore")
    def insert_queue_before(self) -> Optional[pulumi.Input[str]]:
        """
        Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        """
        return pulumi.get(self, "insert_queue_before")

    @insert_queue_before.setter
    def insert_queue_before(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "insert_queue_before", value)

    @property
    @pulumi.getter(name="interfaceList")
    def interface_list(self) -> Optional[pulumi.Input[str]]:
        """
        Interface list name.
        """
        return pulumi.get(self, "interface_list")

    @interface_list.setter
    def interface_list(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interface_list", value)

    @property
    @pulumi.getter(name="localAddress")
    def local_address(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel address or name of the pool from which address is assigned to ppp interface locally.
        """
        return pulumi.get(self, "local_address")

    @local_address.setter
    def local_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "local_address", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        PPP profile name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="onDown")
    def on_down(self) -> Optional[pulumi.Input[str]]:
        """
        Execute script on user logging off. See on-up for more details.
        """
        return pulumi.get(self, "on_down")

    @on_down.setter
    def on_down(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_down", value)

    @property
    @pulumi.getter(name="onUp")
    def on_up(self) -> Optional[pulumi.Input[str]]:
        """
        Execute script on user login-event. These are available variables that are accessible for the event script: *user *local-address *remote-address *caller-id *called-id *interface.
        """
        return pulumi.get(self, "on_up")

    @on_up.setter
    def on_up(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_up", value)

    @property
    @pulumi.getter(name="onlyOne")
    def only_one(self) -> Optional[pulumi.Input[str]]:
        """
        Defines whether a user is allowed to have more than one ppp session at a time yes - a user is not allowed to have more than one ppp session at a time no - the user is allowed to have more than one ppp session at a time default - derive this value from the interface default profile; same as no if this is the interface default profile.
        """
        return pulumi.get(self, "only_one")

    @only_one.setter
    def only_one(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "only_one", value)

    @property
    @pulumi.getter(name="outgoingFilter")
    def outgoing_filter(self) -> Optional[pulumi.Input[str]]:
        """
        Firewall  chain name for outgoing packets. The specified chain gets control for  each packet going to the client. The PPP chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the Examples section.
        """
        return pulumi.get(self, "outgoing_filter")

    @outgoing_filter.setter
    def outgoing_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "outgoing_filter", value)

    @property
    @pulumi.getter(name="parentQueue")
    def parent_queue(self) -> Optional[pulumi.Input[str]]:
        """
        Name of parent simple queue.
        """
        return pulumi.get(self, "parent_queue")

    @parent_queue.setter
    def parent_queue(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parent_queue", value)

    @property
    @pulumi.getter(name="queueType")
    def queue_type(self) -> Optional[pulumi.Input[str]]:
        """
        Queue types.
        """
        return pulumi.get(self, "queue_type")

    @queue_type.setter
    def queue_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "queue_type", value)

    @property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> Optional[pulumi.Input[str]]:
        """
        Rate limitation in form of rx-rate[/tx-rate]  [rx-burst-rate[/tx-burst-rate] [rx-burst-threshold[/tx-burst-threshold]  [rx-burst-time[/tx-burst-time] [priority] [rx-rate-min[/tx-rate-min]]]] from the point of view of the router (so 'rx' is client upload, and  'tx' is client download). All rates are measured in bits per second,  unless followed by optional 'k' suffix (kilobits per second) or 'M'  suffix (megabits per second). If tx-rate is not specified, rx-rate  serves as tx-rate too. The same applies for tx-burst-rate,  tx-burst-threshold and tx-burst-time. If both rx-burst-threshold and  tx-burst-threshold are not specified (but burst-rate is specified),  rx-rate and tx-rate are used as burst thresholds. If both rx-burst-time  and tx-burst-time are not specified, 1s is used as default. Priority  takes values 1..8, where 1 implies the highest priority, but 8 - the  lowest. If rx-rate-min and tx-rate-min are not specified rx-rate and  tx-rate values are used. The rx-rate-min and tx-rate-min values can not  exceed rx-rate and tx-rate values.
        """
        return pulumi.get(self, "rate_limit")

    @rate_limit.setter
    def rate_limit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rate_limit", value)

    @property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel address or name of the pool from which address is assigned to remote ppp interface.
        """
        return pulumi.get(self, "remote_address")

    @remote_address.setter
    def remote_address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_address", value)

    @property
    @pulumi.getter(name="remoteIpv6PrefixPool")
    def remote_ipv6_prefix_pool(self) -> Optional[pulumi.Input[str]]:
        """
        Assign prefix from IPv6 pool to the client and install corresponding IPv6 route.
        """
        return pulumi.get(self, "remote_ipv6_prefix_pool")

    @remote_ipv6_prefix_pool.setter
    def remote_ipv6_prefix_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "remote_ipv6_prefix_pool", value)

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum time the connection can stay up. By default no time limit is set.
        """
        return pulumi.get(self, "session_timeout")

    @session_timeout.setter
    def session_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "session_timeout", value)

    @property
    @pulumi.getter(name="useCompression")
    def use_compression(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to use data compression or not. yes - enable data compression no - disable data compression default - derive this value from the interface default profile; same as no if this is the interface default profile This setting does not affect OVPN tunnels.
        """
        return pulumi.get(self, "use_compression")

    @use_compression.setter
    def use_compression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_compression", value)

    @property
    @pulumi.getter(name="useEncryption")
    def use_encryption(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to use data encryption or not. yes - enable data encryption no - disable data encryption default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires encryption This setting does not work on OVPN and SSTP tunnels.
        """
        return pulumi.get(self, "use_encryption")

    @use_encryption.setter
    def use_encryption(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_encryption", value)

    @property
    @pulumi.getter(name="useIpv6")
    def use_ipv6(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to allow IPv6. By default is enabled if IPv6 package is installed. yes - enable IPv6 support no - disable IPv6 support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires IPv6 support.
        """
        return pulumi.get(self, "use_ipv6")

    @use_ipv6.setter
    def use_ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_ipv6", value)

    @property
    @pulumi.getter(name="useMpls")
    def use_mpls(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to allow MPLS over PPP. yes - enable MPLS support no - disable MPLS support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires MPLS support
        """
        return pulumi.get(self, "use_mpls")

    @use_mpls.setter
    def use_mpls(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_mpls", value)

    @property
    @pulumi.getter(name="useUpnp")
    def use_upnp(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether to allow UPnP.
        """
        return pulumi.get(self, "use_upnp")

    @use_upnp.setter
    def use_upnp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "use_upnp", value)

    @property
    @pulumi.getter(name="winsServers")
    def wins_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IP address of the WINS server to supply to Windows clients.
        """
        return pulumi.get(self, "wins_servers")

    @wins_servers.setter
    def wins_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "wins_servers", value)


class Profile(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 address_list: Optional[pulumi.Input[str]] = None,
                 bridge: Optional[pulumi.Input[str]] = None,
                 bridge_horizon: Optional[pulumi.Input[int]] = None,
                 bridge_learning: Optional[pulumi.Input[str]] = None,
                 bridge_path_cost: Optional[pulumi.Input[int]] = None,
                 bridge_port_priority: Optional[pulumi.Input[int]] = None,
                 change_tcp_mss: Optional[pulumi.Input[str]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 dhcpv6_pd_pool: Optional[pulumi.Input[str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 idle_timeout: Optional[pulumi.Input[str]] = None,
                 incoming_filter: Optional[pulumi.Input[str]] = None,
                 insert_queue_before: Optional[pulumi.Input[str]] = None,
                 interface_list: Optional[pulumi.Input[str]] = None,
                 local_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 on_down: Optional[pulumi.Input[str]] = None,
                 on_up: Optional[pulumi.Input[str]] = None,
                 only_one: Optional[pulumi.Input[str]] = None,
                 outgoing_filter: Optional[pulumi.Input[str]] = None,
                 parent_queue: Optional[pulumi.Input[str]] = None,
                 queue_type: Optional[pulumi.Input[str]] = None,
                 rate_limit: Optional[pulumi.Input[str]] = None,
                 remote_address: Optional[pulumi.Input[str]] = None,
                 remote_ipv6_prefix_pool: Optional[pulumi.Input[str]] = None,
                 session_timeout: Optional[pulumi.Input[str]] = None,
                 use_compression: Optional[pulumi.Input[str]] = None,
                 use_encryption: Optional[pulumi.Input[str]] = None,
                 use_ipv6: Optional[pulumi.Input[str]] = None,
                 use_mpls: Optional[pulumi.Input[str]] = None,
                 use_upnp: Optional[pulumi.Input[str]] = None,
                 wins_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 __props__=None):
        """
        ## Example Usage

        ```python
        import pulumi
        import pulumi_routeros as routeros

        test = routeros.ppp.Profile("test",
            local_address="192.168.77.1",
            remote_address="ovpn-pool",
            use_upnp="no")
        ```

        ## Import

        #The ID can be found via API or the terminal #The command for the terminal is -> :put [/ppp/profile get [print show-ids]]

        ```sh
         $ pulumi import routeros:Ppp/profile:Profile test *6
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] address_list: Address list name to which ppp assigned (on server) or received (on client) address will be added.
        :param pulumi.Input[str] bridge: Name of the bridge interface to which ppp interface will be added as a slave port. Both  tunnel endpoints (server and client) must be in bridge in order to make  this work, see more details on the BCP bridging manual.
        :param pulumi.Input[int] bridge_horizon: Used  split-horizon value for the dynamically created bridge port. Can be  used to prevent bridging loops and isolate traffic. Set the same value  for a group of ports, to prevent them from sending data to ports with  the same horizon value.
        :param pulumi.Input[str] bridge_learning: Changes MAC learning behavior on the dynamically created bridge port: yes - enables MAC learning no - disables MAC learning default - derive this value from the interface default profile; same as yes if this is the interface default profile.
        :param pulumi.Input[int] bridge_path_cost: Used  path cost for the dynamically created bridge port, used by STP/RSTP to  determine the best path, used by MSTP to determine the best path between  regions. This property has no effect when a bridge protocol-mode is set to none.
        :param pulumi.Input[int] bridge_port_priority: Used  priority for the dynamically created bridge port, used by STP/RSTP to  determine the root port, used by MSTP to determine root port between  regions. This property has no effect when a bridge protocol-mode is set  to none.
        :param pulumi.Input[str] change_tcp_mss: Modifies connection MSS settings (applies only for IPv4): yes - adjust connection MSS value no - do not adjust connection MSS value default - derive this value from the interface default profile; same as no if this is the interface default profile.
        :param pulumi.Input[str] dhcpv6_pd_pool: Name of the IPv6 pool which will be used by dynamically created DHCPv6-PD server when client connects. [Read more >>](https://wiki.mikrotik.com/wiki/Manual:IPv6_PD_over_PPP)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: IP address of the DNS server that is supplied to ppp clients.
        :param pulumi.Input[str] idle_timeout: Specifies  the amount of time after which the link will be terminated if there are  no activity present. Timeout is not set by default.
        :param pulumi.Input[str] incoming_filter: Firewall  chain name for incoming packets. Specified chain gets control for each  packet coming from the client. The ppp chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the examples section.
        :param pulumi.Input[str] insert_queue_before: Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        :param pulumi.Input[str] interface_list: Interface list name.
        :param pulumi.Input[str] local_address: Tunnel address or name of the pool from which address is assigned to ppp interface locally.
        :param pulumi.Input[str] name: PPP profile name.
        :param pulumi.Input[str] on_down: Execute script on user logging off. See on-up for more details.
        :param pulumi.Input[str] on_up: Execute script on user login-event. These are available variables that are accessible for the event script: *user *local-address *remote-address *caller-id *called-id *interface.
        :param pulumi.Input[str] only_one: Defines whether a user is allowed to have more than one ppp session at a time yes - a user is not allowed to have more than one ppp session at a time no - the user is allowed to have more than one ppp session at a time default - derive this value from the interface default profile; same as no if this is the interface default profile.
        :param pulumi.Input[str] outgoing_filter: Firewall  chain name for outgoing packets. The specified chain gets control for  each packet going to the client. The PPP chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the Examples section.
        :param pulumi.Input[str] parent_queue: Name of parent simple queue.
        :param pulumi.Input[str] queue_type: Queue types.
        :param pulumi.Input[str] rate_limit: Rate limitation in form of rx-rate[/tx-rate]  [rx-burst-rate[/tx-burst-rate] [rx-burst-threshold[/tx-burst-threshold]  [rx-burst-time[/tx-burst-time] [priority] [rx-rate-min[/tx-rate-min]]]] from the point of view of the router (so 'rx' is client upload, and  'tx' is client download). All rates are measured in bits per second,  unless followed by optional 'k' suffix (kilobits per second) or 'M'  suffix (megabits per second). If tx-rate is not specified, rx-rate  serves as tx-rate too. The same applies for tx-burst-rate,  tx-burst-threshold and tx-burst-time. If both rx-burst-threshold and  tx-burst-threshold are not specified (but burst-rate is specified),  rx-rate and tx-rate are used as burst thresholds. If both rx-burst-time  and tx-burst-time are not specified, 1s is used as default. Priority  takes values 1..8, where 1 implies the highest priority, but 8 - the  lowest. If rx-rate-min and tx-rate-min are not specified rx-rate and  tx-rate values are used. The rx-rate-min and tx-rate-min values can not  exceed rx-rate and tx-rate values.
        :param pulumi.Input[str] remote_address: Tunnel address or name of the pool from which address is assigned to remote ppp interface.
        :param pulumi.Input[str] remote_ipv6_prefix_pool: Assign prefix from IPv6 pool to the client and install corresponding IPv6 route.
        :param pulumi.Input[str] session_timeout: Maximum time the connection can stay up. By default no time limit is set.
        :param pulumi.Input[str] use_compression: Specifies whether to use data compression or not. yes - enable data compression no - disable data compression default - derive this value from the interface default profile; same as no if this is the interface default profile This setting does not affect OVPN tunnels.
        :param pulumi.Input[str] use_encryption: Specifies whether to use data encryption or not. yes - enable data encryption no - disable data encryption default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires encryption This setting does not work on OVPN and SSTP tunnels.
        :param pulumi.Input[str] use_ipv6: Specifies whether to allow IPv6. By default is enabled if IPv6 package is installed. yes - enable IPv6 support no - disable IPv6 support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires IPv6 support.
        :param pulumi.Input[str] use_mpls: Specifies whether to allow MPLS over PPP. yes - enable MPLS support no - disable MPLS support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires MPLS support
        :param pulumi.Input[str] use_upnp: Specifies whether to allow UPnP.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] wins_servers: IP address of the WINS server to supply to Windows clients.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: Optional[ProfileArgs] = None,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        ## Example Usage

        ```python
        import pulumi
        import pulumi_routeros as routeros

        test = routeros.ppp.Profile("test",
            local_address="192.168.77.1",
            remote_address="ovpn-pool",
            use_upnp="no")
        ```

        ## Import

        #The ID can be found via API or the terminal #The command for the terminal is -> :put [/ppp/profile get [print show-ids]]

        ```sh
         $ pulumi import routeros:Ppp/profile:Profile test *6
        ```

        :param str resource_name: The name of the resource.
        :param ProfileArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ProfileArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 ___id_: Optional[pulumi.Input[int]] = None,
                 ___path_: Optional[pulumi.Input[str]] = None,
                 address_list: Optional[pulumi.Input[str]] = None,
                 bridge: Optional[pulumi.Input[str]] = None,
                 bridge_horizon: Optional[pulumi.Input[int]] = None,
                 bridge_learning: Optional[pulumi.Input[str]] = None,
                 bridge_path_cost: Optional[pulumi.Input[int]] = None,
                 bridge_port_priority: Optional[pulumi.Input[int]] = None,
                 change_tcp_mss: Optional[pulumi.Input[str]] = None,
                 comment: Optional[pulumi.Input[str]] = None,
                 dhcpv6_pd_pool: Optional[pulumi.Input[str]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 idle_timeout: Optional[pulumi.Input[str]] = None,
                 incoming_filter: Optional[pulumi.Input[str]] = None,
                 insert_queue_before: Optional[pulumi.Input[str]] = None,
                 interface_list: Optional[pulumi.Input[str]] = None,
                 local_address: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 on_down: Optional[pulumi.Input[str]] = None,
                 on_up: Optional[pulumi.Input[str]] = None,
                 only_one: Optional[pulumi.Input[str]] = None,
                 outgoing_filter: Optional[pulumi.Input[str]] = None,
                 parent_queue: Optional[pulumi.Input[str]] = None,
                 queue_type: Optional[pulumi.Input[str]] = None,
                 rate_limit: Optional[pulumi.Input[str]] = None,
                 remote_address: Optional[pulumi.Input[str]] = None,
                 remote_ipv6_prefix_pool: Optional[pulumi.Input[str]] = None,
                 session_timeout: Optional[pulumi.Input[str]] = None,
                 use_compression: Optional[pulumi.Input[str]] = None,
                 use_encryption: Optional[pulumi.Input[str]] = None,
                 use_ipv6: Optional[pulumi.Input[str]] = None,
                 use_mpls: Optional[pulumi.Input[str]] = None,
                 use_upnp: Optional[pulumi.Input[str]] = None,
                 wins_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ProfileArgs.__new__(ProfileArgs)

            __props__.__dict__["___id_"] = ___id_
            __props__.__dict__["___path_"] = ___path_
            __props__.__dict__["address_list"] = address_list
            __props__.__dict__["bridge"] = bridge
            __props__.__dict__["bridge_horizon"] = bridge_horizon
            __props__.__dict__["bridge_learning"] = bridge_learning
            __props__.__dict__["bridge_path_cost"] = bridge_path_cost
            __props__.__dict__["bridge_port_priority"] = bridge_port_priority
            __props__.__dict__["change_tcp_mss"] = change_tcp_mss
            __props__.__dict__["comment"] = comment
            __props__.__dict__["dhcpv6_pd_pool"] = dhcpv6_pd_pool
            __props__.__dict__["dns_servers"] = dns_servers
            __props__.__dict__["idle_timeout"] = idle_timeout
            __props__.__dict__["incoming_filter"] = incoming_filter
            __props__.__dict__["insert_queue_before"] = insert_queue_before
            __props__.__dict__["interface_list"] = interface_list
            __props__.__dict__["local_address"] = local_address
            __props__.__dict__["name"] = name
            __props__.__dict__["on_down"] = on_down
            __props__.__dict__["on_up"] = on_up
            __props__.__dict__["only_one"] = only_one
            __props__.__dict__["outgoing_filter"] = outgoing_filter
            __props__.__dict__["parent_queue"] = parent_queue
            __props__.__dict__["queue_type"] = queue_type
            __props__.__dict__["rate_limit"] = rate_limit
            __props__.__dict__["remote_address"] = remote_address
            __props__.__dict__["remote_ipv6_prefix_pool"] = remote_ipv6_prefix_pool
            __props__.__dict__["session_timeout"] = session_timeout
            __props__.__dict__["use_compression"] = use_compression
            __props__.__dict__["use_encryption"] = use_encryption
            __props__.__dict__["use_ipv6"] = use_ipv6
            __props__.__dict__["use_mpls"] = use_mpls
            __props__.__dict__["use_upnp"] = use_upnp
            __props__.__dict__["wins_servers"] = wins_servers
            __props__.__dict__["default"] = None
        super(Profile, __self__).__init__(
            'routeros:Ppp/profile:Profile',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            ___id_: Optional[pulumi.Input[int]] = None,
            ___path_: Optional[pulumi.Input[str]] = None,
            address_list: Optional[pulumi.Input[str]] = None,
            bridge: Optional[pulumi.Input[str]] = None,
            bridge_horizon: Optional[pulumi.Input[int]] = None,
            bridge_learning: Optional[pulumi.Input[str]] = None,
            bridge_path_cost: Optional[pulumi.Input[int]] = None,
            bridge_port_priority: Optional[pulumi.Input[int]] = None,
            change_tcp_mss: Optional[pulumi.Input[str]] = None,
            comment: Optional[pulumi.Input[str]] = None,
            default: Optional[pulumi.Input[str]] = None,
            dhcpv6_pd_pool: Optional[pulumi.Input[str]] = None,
            dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
            idle_timeout: Optional[pulumi.Input[str]] = None,
            incoming_filter: Optional[pulumi.Input[str]] = None,
            insert_queue_before: Optional[pulumi.Input[str]] = None,
            interface_list: Optional[pulumi.Input[str]] = None,
            local_address: Optional[pulumi.Input[str]] = None,
            name: Optional[pulumi.Input[str]] = None,
            on_down: Optional[pulumi.Input[str]] = None,
            on_up: Optional[pulumi.Input[str]] = None,
            only_one: Optional[pulumi.Input[str]] = None,
            outgoing_filter: Optional[pulumi.Input[str]] = None,
            parent_queue: Optional[pulumi.Input[str]] = None,
            queue_type: Optional[pulumi.Input[str]] = None,
            rate_limit: Optional[pulumi.Input[str]] = None,
            remote_address: Optional[pulumi.Input[str]] = None,
            remote_ipv6_prefix_pool: Optional[pulumi.Input[str]] = None,
            session_timeout: Optional[pulumi.Input[str]] = None,
            use_compression: Optional[pulumi.Input[str]] = None,
            use_encryption: Optional[pulumi.Input[str]] = None,
            use_ipv6: Optional[pulumi.Input[str]] = None,
            use_mpls: Optional[pulumi.Input[str]] = None,
            use_upnp: Optional[pulumi.Input[str]] = None,
            wins_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None) -> 'Profile':
        """
        Get an existing Profile resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[int] ___id_: <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] ___path_: <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        :param pulumi.Input[str] address_list: Address list name to which ppp assigned (on server) or received (on client) address will be added.
        :param pulumi.Input[str] bridge: Name of the bridge interface to which ppp interface will be added as a slave port. Both  tunnel endpoints (server and client) must be in bridge in order to make  this work, see more details on the BCP bridging manual.
        :param pulumi.Input[int] bridge_horizon: Used  split-horizon value for the dynamically created bridge port. Can be  used to prevent bridging loops and isolate traffic. Set the same value  for a group of ports, to prevent them from sending data to ports with  the same horizon value.
        :param pulumi.Input[str] bridge_learning: Changes MAC learning behavior on the dynamically created bridge port: yes - enables MAC learning no - disables MAC learning default - derive this value from the interface default profile; same as yes if this is the interface default profile.
        :param pulumi.Input[int] bridge_path_cost: Used  path cost for the dynamically created bridge port, used by STP/RSTP to  determine the best path, used by MSTP to determine the best path between  regions. This property has no effect when a bridge protocol-mode is set to none.
        :param pulumi.Input[int] bridge_port_priority: Used  priority for the dynamically created bridge port, used by STP/RSTP to  determine the root port, used by MSTP to determine root port between  regions. This property has no effect when a bridge protocol-mode is set  to none.
        :param pulumi.Input[str] change_tcp_mss: Modifies connection MSS settings (applies only for IPv4): yes - adjust connection MSS value no - do not adjust connection MSS value default - derive this value from the interface default profile; same as no if this is the interface default profile.
        :param pulumi.Input[str] default: Default profile sign.
        :param pulumi.Input[str] dhcpv6_pd_pool: Name of the IPv6 pool which will be used by dynamically created DHCPv6-PD server when client connects. [Read more >>](https://wiki.mikrotik.com/wiki/Manual:IPv6_PD_over_PPP)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: IP address of the DNS server that is supplied to ppp clients.
        :param pulumi.Input[str] idle_timeout: Specifies  the amount of time after which the link will be terminated if there are  no activity present. Timeout is not set by default.
        :param pulumi.Input[str] incoming_filter: Firewall  chain name for incoming packets. Specified chain gets control for each  packet coming from the client. The ppp chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the examples section.
        :param pulumi.Input[str] insert_queue_before: Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        :param pulumi.Input[str] interface_list: Interface list name.
        :param pulumi.Input[str] local_address: Tunnel address or name of the pool from which address is assigned to ppp interface locally.
        :param pulumi.Input[str] name: PPP profile name.
        :param pulumi.Input[str] on_down: Execute script on user logging off. See on-up for more details.
        :param pulumi.Input[str] on_up: Execute script on user login-event. These are available variables that are accessible for the event script: *user *local-address *remote-address *caller-id *called-id *interface.
        :param pulumi.Input[str] only_one: Defines whether a user is allowed to have more than one ppp session at a time yes - a user is not allowed to have more than one ppp session at a time no - the user is allowed to have more than one ppp session at a time default - derive this value from the interface default profile; same as no if this is the interface default profile.
        :param pulumi.Input[str] outgoing_filter: Firewall  chain name for outgoing packets. The specified chain gets control for  each packet going to the client. The PPP chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the Examples section.
        :param pulumi.Input[str] parent_queue: Name of parent simple queue.
        :param pulumi.Input[str] queue_type: Queue types.
        :param pulumi.Input[str] rate_limit: Rate limitation in form of rx-rate[/tx-rate]  [rx-burst-rate[/tx-burst-rate] [rx-burst-threshold[/tx-burst-threshold]  [rx-burst-time[/tx-burst-time] [priority] [rx-rate-min[/tx-rate-min]]]] from the point of view of the router (so 'rx' is client upload, and  'tx' is client download). All rates are measured in bits per second,  unless followed by optional 'k' suffix (kilobits per second) or 'M'  suffix (megabits per second). If tx-rate is not specified, rx-rate  serves as tx-rate too. The same applies for tx-burst-rate,  tx-burst-threshold and tx-burst-time. If both rx-burst-threshold and  tx-burst-threshold are not specified (but burst-rate is specified),  rx-rate and tx-rate are used as burst thresholds. If both rx-burst-time  and tx-burst-time are not specified, 1s is used as default. Priority  takes values 1..8, where 1 implies the highest priority, but 8 - the  lowest. If rx-rate-min and tx-rate-min are not specified rx-rate and  tx-rate values are used. The rx-rate-min and tx-rate-min values can not  exceed rx-rate and tx-rate values.
        :param pulumi.Input[str] remote_address: Tunnel address or name of the pool from which address is assigned to remote ppp interface.
        :param pulumi.Input[str] remote_ipv6_prefix_pool: Assign prefix from IPv6 pool to the client and install corresponding IPv6 route.
        :param pulumi.Input[str] session_timeout: Maximum time the connection can stay up. By default no time limit is set.
        :param pulumi.Input[str] use_compression: Specifies whether to use data compression or not. yes - enable data compression no - disable data compression default - derive this value from the interface default profile; same as no if this is the interface default profile This setting does not affect OVPN tunnels.
        :param pulumi.Input[str] use_encryption: Specifies whether to use data encryption or not. yes - enable data encryption no - disable data encryption default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires encryption This setting does not work on OVPN and SSTP tunnels.
        :param pulumi.Input[str] use_ipv6: Specifies whether to allow IPv6. By default is enabled if IPv6 package is installed. yes - enable IPv6 support no - disable IPv6 support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires IPv6 support.
        :param pulumi.Input[str] use_mpls: Specifies whether to allow MPLS over PPP. yes - enable MPLS support no - disable MPLS support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires MPLS support
        :param pulumi.Input[str] use_upnp: Specifies whether to allow UPnP.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] wins_servers: IP address of the WINS server to supply to Windows clients.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _ProfileState.__new__(_ProfileState)

        __props__.__dict__["___id_"] = ___id_
        __props__.__dict__["___path_"] = ___path_
        __props__.__dict__["address_list"] = address_list
        __props__.__dict__["bridge"] = bridge
        __props__.__dict__["bridge_horizon"] = bridge_horizon
        __props__.__dict__["bridge_learning"] = bridge_learning
        __props__.__dict__["bridge_path_cost"] = bridge_path_cost
        __props__.__dict__["bridge_port_priority"] = bridge_port_priority
        __props__.__dict__["change_tcp_mss"] = change_tcp_mss
        __props__.__dict__["comment"] = comment
        __props__.__dict__["default"] = default
        __props__.__dict__["dhcpv6_pd_pool"] = dhcpv6_pd_pool
        __props__.__dict__["dns_servers"] = dns_servers
        __props__.__dict__["idle_timeout"] = idle_timeout
        __props__.__dict__["incoming_filter"] = incoming_filter
        __props__.__dict__["insert_queue_before"] = insert_queue_before
        __props__.__dict__["interface_list"] = interface_list
        __props__.__dict__["local_address"] = local_address
        __props__.__dict__["name"] = name
        __props__.__dict__["on_down"] = on_down
        __props__.__dict__["on_up"] = on_up
        __props__.__dict__["only_one"] = only_one
        __props__.__dict__["outgoing_filter"] = outgoing_filter
        __props__.__dict__["parent_queue"] = parent_queue
        __props__.__dict__["queue_type"] = queue_type
        __props__.__dict__["rate_limit"] = rate_limit
        __props__.__dict__["remote_address"] = remote_address
        __props__.__dict__["remote_ipv6_prefix_pool"] = remote_ipv6_prefix_pool
        __props__.__dict__["session_timeout"] = session_timeout
        __props__.__dict__["use_compression"] = use_compression
        __props__.__dict__["use_encryption"] = use_encryption
        __props__.__dict__["use_ipv6"] = use_ipv6
        __props__.__dict__["use_mpls"] = use_mpls
        __props__.__dict__["use_upnp"] = use_upnp
        __props__.__dict__["wins_servers"] = wins_servers
        return Profile(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def ___id_(self) -> pulumi.Output[Optional[int]]:
        """
        <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___id_")

    @property
    @pulumi.getter
    def ___path_(self) -> pulumi.Output[Optional[str]]:
        """
        <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
        """
        return pulumi.get(self, "___path_")

    @property
    @pulumi.getter(name="addressList")
    def address_list(self) -> pulumi.Output[Optional[str]]:
        """
        Address list name to which ppp assigned (on server) or received (on client) address will be added.
        """
        return pulumi.get(self, "address_list")

    @property
    @pulumi.getter
    def bridge(self) -> pulumi.Output[Optional[str]]:
        """
        Name of the bridge interface to which ppp interface will be added as a slave port. Both  tunnel endpoints (server and client) must be in bridge in order to make  this work, see more details on the BCP bridging manual.
        """
        return pulumi.get(self, "bridge")

    @property
    @pulumi.getter(name="bridgeHorizon")
    def bridge_horizon(self) -> pulumi.Output[Optional[int]]:
        """
        Used  split-horizon value for the dynamically created bridge port. Can be  used to prevent bridging loops and isolate traffic. Set the same value  for a group of ports, to prevent them from sending data to ports with  the same horizon value.
        """
        return pulumi.get(self, "bridge_horizon")

    @property
    @pulumi.getter(name="bridgeLearning")
    def bridge_learning(self) -> pulumi.Output[Optional[str]]:
        """
        Changes MAC learning behavior on the dynamically created bridge port: yes - enables MAC learning no - disables MAC learning default - derive this value from the interface default profile; same as yes if this is the interface default profile.
        """
        return pulumi.get(self, "bridge_learning")

    @property
    @pulumi.getter(name="bridgePathCost")
    def bridge_path_cost(self) -> pulumi.Output[Optional[int]]:
        """
        Used  path cost for the dynamically created bridge port, used by STP/RSTP to  determine the best path, used by MSTP to determine the best path between  regions. This property has no effect when a bridge protocol-mode is set to none.
        """
        return pulumi.get(self, "bridge_path_cost")

    @property
    @pulumi.getter(name="bridgePortPriority")
    def bridge_port_priority(self) -> pulumi.Output[Optional[int]]:
        """
        Used  priority for the dynamically created bridge port, used by STP/RSTP to  determine the root port, used by MSTP to determine root port between  regions. This property has no effect when a bridge protocol-mode is set  to none.
        """
        return pulumi.get(self, "bridge_port_priority")

    @property
    @pulumi.getter(name="changeTcpMss")
    def change_tcp_mss(self) -> pulumi.Output[Optional[str]]:
        """
        Modifies connection MSS settings (applies only for IPv4): yes - adjust connection MSS value no - do not adjust connection MSS value default - derive this value from the interface default profile; same as no if this is the interface default profile.
        """
        return pulumi.get(self, "change_tcp_mss")

    @property
    @pulumi.getter
    def comment(self) -> pulumi.Output[Optional[str]]:
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def default(self) -> pulumi.Output[str]:
        """
        Default profile sign.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter(name="dhcpv6PdPool")
    def dhcpv6_pd_pool(self) -> pulumi.Output[Optional[str]]:
        """
        Name of the IPv6 pool which will be used by dynamically created DHCPv6-PD server when client connects. [Read more >>](https://wiki.mikrotik.com/wiki/Manual:IPv6_PD_over_PPP)
        """
        return pulumi.get(self, "dhcpv6_pd_pool")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        IP address of the DNS server that is supplied to ppp clients.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies  the amount of time after which the link will be terminated if there are  no activity present. Timeout is not set by default.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter(name="incomingFilter")
    def incoming_filter(self) -> pulumi.Output[Optional[str]]:
        """
        Firewall  chain name for incoming packets. Specified chain gets control for each  packet coming from the client. The ppp chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the examples section.
        """
        return pulumi.get(self, "incoming_filter")

    @property
    @pulumi.getter(name="insertQueueBefore")
    def insert_queue_before(self) -> pulumi.Output[Optional[str]]:
        """
        Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.
        """
        return pulumi.get(self, "insert_queue_before")

    @property
    @pulumi.getter(name="interfaceList")
    def interface_list(self) -> pulumi.Output[Optional[str]]:
        """
        Interface list name.
        """
        return pulumi.get(self, "interface_list")

    @property
    @pulumi.getter(name="localAddress")
    def local_address(self) -> pulumi.Output[Optional[str]]:
        """
        Tunnel address or name of the pool from which address is assigned to ppp interface locally.
        """
        return pulumi.get(self, "local_address")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        PPP profile name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="onDown")
    def on_down(self) -> pulumi.Output[Optional[str]]:
        """
        Execute script on user logging off. See on-up for more details.
        """
        return pulumi.get(self, "on_down")

    @property
    @pulumi.getter(name="onUp")
    def on_up(self) -> pulumi.Output[Optional[str]]:
        """
        Execute script on user login-event. These are available variables that are accessible for the event script: *user *local-address *remote-address *caller-id *called-id *interface.
        """
        return pulumi.get(self, "on_up")

    @property
    @pulumi.getter(name="onlyOne")
    def only_one(self) -> pulumi.Output[Optional[str]]:
        """
        Defines whether a user is allowed to have more than one ppp session at a time yes - a user is not allowed to have more than one ppp session at a time no - the user is allowed to have more than one ppp session at a time default - derive this value from the interface default profile; same as no if this is the interface default profile.
        """
        return pulumi.get(self, "only_one")

    @property
    @pulumi.getter(name="outgoingFilter")
    def outgoing_filter(self) -> pulumi.Output[Optional[str]]:
        """
        Firewall  chain name for outgoing packets. The specified chain gets control for  each packet going to the client. The PPP chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the Examples section.
        """
        return pulumi.get(self, "outgoing_filter")

    @property
    @pulumi.getter(name="parentQueue")
    def parent_queue(self) -> pulumi.Output[Optional[str]]:
        """
        Name of parent simple queue.
        """
        return pulumi.get(self, "parent_queue")

    @property
    @pulumi.getter(name="queueType")
    def queue_type(self) -> pulumi.Output[Optional[str]]:
        """
        Queue types.
        """
        return pulumi.get(self, "queue_type")

    @property
    @pulumi.getter(name="rateLimit")
    def rate_limit(self) -> pulumi.Output[Optional[str]]:
        """
        Rate limitation in form of rx-rate[/tx-rate]  [rx-burst-rate[/tx-burst-rate] [rx-burst-threshold[/tx-burst-threshold]  [rx-burst-time[/tx-burst-time] [priority] [rx-rate-min[/tx-rate-min]]]] from the point of view of the router (so 'rx' is client upload, and  'tx' is client download). All rates are measured in bits per second,  unless followed by optional 'k' suffix (kilobits per second) or 'M'  suffix (megabits per second). If tx-rate is not specified, rx-rate  serves as tx-rate too. The same applies for tx-burst-rate,  tx-burst-threshold and tx-burst-time. If both rx-burst-threshold and  tx-burst-threshold are not specified (but burst-rate is specified),  rx-rate and tx-rate are used as burst thresholds. If both rx-burst-time  and tx-burst-time are not specified, 1s is used as default. Priority  takes values 1..8, where 1 implies the highest priority, but 8 - the  lowest. If rx-rate-min and tx-rate-min are not specified rx-rate and  tx-rate values are used. The rx-rate-min and tx-rate-min values can not  exceed rx-rate and tx-rate values.
        """
        return pulumi.get(self, "rate_limit")

    @property
    @pulumi.getter(name="remoteAddress")
    def remote_address(self) -> pulumi.Output[Optional[str]]:
        """
        Tunnel address or name of the pool from which address is assigned to remote ppp interface.
        """
        return pulumi.get(self, "remote_address")

    @property
    @pulumi.getter(name="remoteIpv6PrefixPool")
    def remote_ipv6_prefix_pool(self) -> pulumi.Output[Optional[str]]:
        """
        Assign prefix from IPv6 pool to the client and install corresponding IPv6 route.
        """
        return pulumi.get(self, "remote_ipv6_prefix_pool")

    @property
    @pulumi.getter(name="sessionTimeout")
    def session_timeout(self) -> pulumi.Output[Optional[str]]:
        """
        Maximum time the connection can stay up. By default no time limit is set.
        """
        return pulumi.get(self, "session_timeout")

    @property
    @pulumi.getter(name="useCompression")
    def use_compression(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies whether to use data compression or not. yes - enable data compression no - disable data compression default - derive this value from the interface default profile; same as no if this is the interface default profile This setting does not affect OVPN tunnels.
        """
        return pulumi.get(self, "use_compression")

    @property
    @pulumi.getter(name="useEncryption")
    def use_encryption(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies whether to use data encryption or not. yes - enable data encryption no - disable data encryption default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires encryption This setting does not work on OVPN and SSTP tunnels.
        """
        return pulumi.get(self, "use_encryption")

    @property
    @pulumi.getter(name="useIpv6")
    def use_ipv6(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies whether to allow IPv6. By default is enabled if IPv6 package is installed. yes - enable IPv6 support no - disable IPv6 support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires IPv6 support.
        """
        return pulumi.get(self, "use_ipv6")

    @property
    @pulumi.getter(name="useMpls")
    def use_mpls(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies whether to allow MPLS over PPP. yes - enable MPLS support no - disable MPLS support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires MPLS support
        """
        return pulumi.get(self, "use_mpls")

    @property
    @pulumi.getter(name="useUpnp")
    def use_upnp(self) -> pulumi.Output[Optional[str]]:
        """
        Specifies whether to allow UPnP.
        """
        return pulumi.get(self, "use_upnp")

    @property
    @pulumi.getter(name="winsServers")
    def wins_servers(self) -> pulumi.Output[Optional[Sequence[str]]]:
        """
        IP address of the WINS server to supply to Windows clients.
        """
        return pulumi.get(self, "wins_servers")

