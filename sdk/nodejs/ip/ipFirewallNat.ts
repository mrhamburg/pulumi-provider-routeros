// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "../utilities";

/**
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as routeros from "@pulumi/routeros";
 *
 * const rule = new routeros.ip.IpFirewallNat("rule", {
 *     action: "masquerade",
 *     chain: "srcnat",
 *     outInterface: "ether16",
 * });
 * ```
 *
 * ## Import
 *
 * #The ID can be found via API or the terminal #The command for the terminal is -> :put [/ip/firewall/nat get [print show-ids]]
 *
 * ```sh
 *  $ pulumi import routeros:Ip/ipFirewallNat:IpFirewallNat rule "*0"
 * ```
 */
export class IpFirewallNat extends pulumi.CustomResource {
    /**
     * Get an existing IpFirewallNat resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: IpFirewallNatState, opts?: pulumi.CustomResourceOptions): IpFirewallNat {
        return new IpFirewallNat(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'routeros:Ip/ipFirewallNat:IpFirewallNat';

    /**
     * Returns true if the given object is an instance of IpFirewallNat.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is IpFirewallNat {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === IpFirewallNat.__pulumiType;
    }

    /**
     * <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
     */
    public readonly ___id_!: pulumi.Output<number | undefined>;
    /**
     * <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
     */
    public readonly ___path_!: pulumi.Output<string | undefined>;
    /**
     * Action to take if a packet is matched by the rule
     */
    public readonly action!: pulumi.Output<string>;
    /**
     * Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.
     */
    public readonly addressList!: pulumi.Output<string | undefined>;
    /**
     * Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
     * conjunction with add-dst-to-address-list or add-src-to-address-list actions.
     */
    public readonly addressListTimeout!: pulumi.Output<string | undefined>;
    /**
     * The total amount of bytes matched by the rule.
     */
    public /*out*/ readonly bytes!: pulumi.Output<number>;
    /**
     * Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
     * chain will be created.
     */
    public readonly chain!: pulumi.Output<string>;
    public readonly comment!: pulumi.Output<string | undefined>;
    /**
     * Matches packets only if a given amount of bytes has been transfered through the particular connection.
     */
    public readonly connectionBytes!: pulumi.Output<string | undefined>;
    /**
     * Matches connections per address or address block after given value is reached. Should be used together with
     * connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
     */
    public readonly connectionLimit!: pulumi.Output<string | undefined>;
    /**
     * Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
     * unmarked connection.
     */
    public readonly connectionMark!: pulumi.Output<string | undefined>;
    /**
     * Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
     * (0..4294967295).
     */
    public readonly connectionRate!: pulumi.Output<string | undefined>;
    /**
     * Matches packets from related connections based on information from their connection tracking helpers.
     */
    public readonly connectionType!: pulumi.Output<string | undefined>;
    /**
     * Match packets that contain specified text.
     */
    public readonly content!: pulumi.Output<string | undefined>;
    public readonly disabled!: pulumi.Output<boolean | undefined>;
    /**
     * Matches DSCP IP header field.
     */
    public readonly dscp!: pulumi.Output<number | undefined>;
    /**
     * Matches packets which destination is equal to specified IP or falls into specified IP range.
     */
    public readonly dstAddress!: pulumi.Output<string | undefined>;
    /**
     * Matches destination address of a packet against user-defined address list.
     */
    public readonly dstAddressList!: pulumi.Output<string | undefined>;
    /**
     * Matches destination address type.
     */
    public readonly dstAddressType!: pulumi.Output<string | undefined>;
    /**
     * Matches packets until a given rate is exceeded.
     */
    public readonly dstLimit!: pulumi.Output<string | undefined>;
    /**
     * List of destination port numbers or port number ranges.
     */
    public readonly dstPort!: pulumi.Output<string | undefined>;
    /**
     * Configuration item created by software, not by management interface. It is not exported, and cannot be directly
     * modified.
     */
    public /*out*/ readonly dynamic!: pulumi.Output<boolean>;
    /**
     * Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
     * fragments as system automatically assembles every packet
     */
    public readonly fragment!: pulumi.Output<boolean | undefined>;
    /**
     * Matches packets received from HotSpot clients against various HotSpot matchers.
     */
    public readonly hotspot!: pulumi.Output<string | undefined>;
    /**
     * Matches ICMP type: code fields.
     */
    public readonly icmpOptions!: pulumi.Output<string | undefined>;
    /**
     * Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
     * is enabled in bridge settings.
     */
    public readonly inBridgePort!: pulumi.Output<string | undefined>;
    /**
     * Set of interfaces defined in interface list. Works the same as in-bridge-port.
     */
    public readonly inBridgePortList!: pulumi.Output<string | undefined>;
    /**
     * Interface the packet has entered the router.
     */
    public readonly inInterface!: pulumi.Output<string | undefined>;
    /**
     * Set of interfaces defined in interface list. Works the same as in-interface.
     */
    public readonly inInterfaceList!: pulumi.Output<string | undefined>;
    /**
     * Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
     */
    public readonly ingressPriority!: pulumi.Output<number | undefined>;
    public /*out*/ readonly invalid!: pulumi.Output<boolean>;
    /**
     * Matches the policy used by IPsec. Value is written in the following format: direction, policy.
     */
    public readonly ipsecPolicy!: pulumi.Output<string | undefined>;
    /**
     * Matches IPv4 header options.
     */
    public readonly ipv4Options!: pulumi.Output<string | undefined>;
    /**
     * Name of the target chain to jump to. Applicable only if action=jump.
     */
    public readonly jumpTarget!: pulumi.Output<string | undefined>;
    /**
     * Layer7 filter name.
     */
    public readonly layer7Protocol!: pulumi.Output<string | undefined>;
    /**
     * Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
     * reached. Parameters are written in the following format: rate[/time],burst:mode.
     */
    public readonly limit!: pulumi.Output<string | undefined>;
    /**
     * Add a message to the system log.
     */
    public readonly log!: pulumi.Output<boolean | undefined>;
    /**
     * Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
     */
    public readonly logPrefix!: pulumi.Output<string | undefined>;
    /**
     * Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
     * by the rule
     */
    public readonly nth!: pulumi.Output<string | undefined>;
    /**
     * Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
     * is enabled in bridge settings.
     */
    public readonly outBridgePort!: pulumi.Output<string | undefined>;
    /**
     * Set of interfaces defined in interface list. Works the same as out-bridge-port.
     */
    public readonly outBridgePortList!: pulumi.Output<string | undefined>;
    /**
     * Interface the packet is leaving the router.
     */
    public readonly outInterface!: pulumi.Output<string | undefined>;
    /**
     * Set of interfaces defined in interface list. Works the same as out-interface.
     */
    public readonly outInterfaceList!: pulumi.Output<string | undefined>;
    /**
     * Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
     * unmarked packet.
     */
    public readonly packetMark!: pulumi.Output<string | undefined>;
    /**
     * Matches packets of specified size or size range in bytes.
     */
    public readonly packetSize!: pulumi.Output<string | undefined>;
    /**
     * The total amount of packets matched by the rule.
     */
    public /*out*/ readonly packets!: pulumi.Output<number>;
    /**
     * PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
     * in one particular stream.
     */
    public readonly perConnectionClassifier!: pulumi.Output<string | undefined>;
    /**
     * Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
     * think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
     */
    public readonly placeBefore!: pulumi.Output<string | undefined>;
    /**
     * Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
     * protocol is TCP or UDP
     */
    public readonly port!: pulumi.Output<string | undefined>;
    /**
     * Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP
     * bit, or from the priority that has been set using the set-priority action.
     */
    public readonly priority!: pulumi.Output<number | undefined>;
    /**
     * Matches particular IP protocol specified by protocol name or number.
     */
    public readonly protocol!: pulumi.Output<string | undefined>;
    /**
     * Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
     * LowPortWeight, HighPortWeight.
     */
    public readonly psd!: pulumi.Output<string | undefined>;
    /**
     * Matches packets randomly with a given probability.
     */
    public readonly random!: pulumi.Output<number | undefined>;
    /**
     * Matches packets marked by mangle facility with particular routing mark.
     */
    public readonly routingMark!: pulumi.Output<string | undefined>;
    /**
     * Specifies whether to take into account or not destination IP address when selecting a new source IP address. Applicable
     * if action=same
     */
    public readonly sameNotByDst!: pulumi.Output<boolean | undefined>;
    /**
     * Matches packets which source is equal to specified IP or falls into a specified IP range.
     */
    public readonly srcAddress!: pulumi.Output<string | undefined>;
    /**
     * Matches source address of a packet against user-defined address list.
     */
    public readonly srcAddressList!: pulumi.Output<string | undefined>;
    /**
     * Matches source address type.
     */
    public readonly srcAddressType!: pulumi.Output<string | undefined>;
    /**
     * Matches source MAC address of the packet.
     */
    public readonly srcMacAddress!: pulumi.Output<string | undefined>;
    /**
     * List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
     */
    public readonly srcPort!: pulumi.Output<string | undefined>;
    /**
     * Matches TCP MSS value of an IP packet.
     */
    public readonly tcpMss!: pulumi.Output<string | undefined>;
    /**
     * Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
     * and date.
     */
    public readonly time!: pulumi.Output<string | undefined>;
    /**
     * Replace original address with specified one. Applicable if action is dst-nat, netmap, same, src-nat.
     */
    public readonly toAddresses!: pulumi.Output<string | undefined>;
    /**
     * Replace the original port with the specified one. Applicable if action is dst-nat, redirect, masquerade, netmap, same,
     * src-nat.
     */
    public readonly toPorts!: pulumi.Output<string | undefined>;
    /**
     * Matches packets TTL value.
     */
    public readonly ttl!: pulumi.Output<string | undefined>;

    /**
     * Create a IpFirewallNat resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: IpFirewallNatArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: IpFirewallNatArgs | IpFirewallNatState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as IpFirewallNatState | undefined;
            resourceInputs["___id_"] = state ? state.___id_ : undefined;
            resourceInputs["___path_"] = state ? state.___path_ : undefined;
            resourceInputs["action"] = state ? state.action : undefined;
            resourceInputs["addressList"] = state ? state.addressList : undefined;
            resourceInputs["addressListTimeout"] = state ? state.addressListTimeout : undefined;
            resourceInputs["bytes"] = state ? state.bytes : undefined;
            resourceInputs["chain"] = state ? state.chain : undefined;
            resourceInputs["comment"] = state ? state.comment : undefined;
            resourceInputs["connectionBytes"] = state ? state.connectionBytes : undefined;
            resourceInputs["connectionLimit"] = state ? state.connectionLimit : undefined;
            resourceInputs["connectionMark"] = state ? state.connectionMark : undefined;
            resourceInputs["connectionRate"] = state ? state.connectionRate : undefined;
            resourceInputs["connectionType"] = state ? state.connectionType : undefined;
            resourceInputs["content"] = state ? state.content : undefined;
            resourceInputs["disabled"] = state ? state.disabled : undefined;
            resourceInputs["dscp"] = state ? state.dscp : undefined;
            resourceInputs["dstAddress"] = state ? state.dstAddress : undefined;
            resourceInputs["dstAddressList"] = state ? state.dstAddressList : undefined;
            resourceInputs["dstAddressType"] = state ? state.dstAddressType : undefined;
            resourceInputs["dstLimit"] = state ? state.dstLimit : undefined;
            resourceInputs["dstPort"] = state ? state.dstPort : undefined;
            resourceInputs["dynamic"] = state ? state.dynamic : undefined;
            resourceInputs["fragment"] = state ? state.fragment : undefined;
            resourceInputs["hotspot"] = state ? state.hotspot : undefined;
            resourceInputs["icmpOptions"] = state ? state.icmpOptions : undefined;
            resourceInputs["inBridgePort"] = state ? state.inBridgePort : undefined;
            resourceInputs["inBridgePortList"] = state ? state.inBridgePortList : undefined;
            resourceInputs["inInterface"] = state ? state.inInterface : undefined;
            resourceInputs["inInterfaceList"] = state ? state.inInterfaceList : undefined;
            resourceInputs["ingressPriority"] = state ? state.ingressPriority : undefined;
            resourceInputs["invalid"] = state ? state.invalid : undefined;
            resourceInputs["ipsecPolicy"] = state ? state.ipsecPolicy : undefined;
            resourceInputs["ipv4Options"] = state ? state.ipv4Options : undefined;
            resourceInputs["jumpTarget"] = state ? state.jumpTarget : undefined;
            resourceInputs["layer7Protocol"] = state ? state.layer7Protocol : undefined;
            resourceInputs["limit"] = state ? state.limit : undefined;
            resourceInputs["log"] = state ? state.log : undefined;
            resourceInputs["logPrefix"] = state ? state.logPrefix : undefined;
            resourceInputs["nth"] = state ? state.nth : undefined;
            resourceInputs["outBridgePort"] = state ? state.outBridgePort : undefined;
            resourceInputs["outBridgePortList"] = state ? state.outBridgePortList : undefined;
            resourceInputs["outInterface"] = state ? state.outInterface : undefined;
            resourceInputs["outInterfaceList"] = state ? state.outInterfaceList : undefined;
            resourceInputs["packetMark"] = state ? state.packetMark : undefined;
            resourceInputs["packetSize"] = state ? state.packetSize : undefined;
            resourceInputs["packets"] = state ? state.packets : undefined;
            resourceInputs["perConnectionClassifier"] = state ? state.perConnectionClassifier : undefined;
            resourceInputs["placeBefore"] = state ? state.placeBefore : undefined;
            resourceInputs["port"] = state ? state.port : undefined;
            resourceInputs["priority"] = state ? state.priority : undefined;
            resourceInputs["protocol"] = state ? state.protocol : undefined;
            resourceInputs["psd"] = state ? state.psd : undefined;
            resourceInputs["random"] = state ? state.random : undefined;
            resourceInputs["routingMark"] = state ? state.routingMark : undefined;
            resourceInputs["sameNotByDst"] = state ? state.sameNotByDst : undefined;
            resourceInputs["srcAddress"] = state ? state.srcAddress : undefined;
            resourceInputs["srcAddressList"] = state ? state.srcAddressList : undefined;
            resourceInputs["srcAddressType"] = state ? state.srcAddressType : undefined;
            resourceInputs["srcMacAddress"] = state ? state.srcMacAddress : undefined;
            resourceInputs["srcPort"] = state ? state.srcPort : undefined;
            resourceInputs["tcpMss"] = state ? state.tcpMss : undefined;
            resourceInputs["time"] = state ? state.time : undefined;
            resourceInputs["toAddresses"] = state ? state.toAddresses : undefined;
            resourceInputs["toPorts"] = state ? state.toPorts : undefined;
            resourceInputs["ttl"] = state ? state.ttl : undefined;
        } else {
            const args = argsOrState as IpFirewallNatArgs | undefined;
            if ((!args || args.action === undefined) && !opts.urn) {
                throw new Error("Missing required property 'action'");
            }
            if ((!args || args.chain === undefined) && !opts.urn) {
                throw new Error("Missing required property 'chain'");
            }
            resourceInputs["___id_"] = args ? args.___id_ : undefined;
            resourceInputs["___path_"] = args ? args.___path_ : undefined;
            resourceInputs["action"] = args ? args.action : undefined;
            resourceInputs["addressList"] = args ? args.addressList : undefined;
            resourceInputs["addressListTimeout"] = args ? args.addressListTimeout : undefined;
            resourceInputs["chain"] = args ? args.chain : undefined;
            resourceInputs["comment"] = args ? args.comment : undefined;
            resourceInputs["connectionBytes"] = args ? args.connectionBytes : undefined;
            resourceInputs["connectionLimit"] = args ? args.connectionLimit : undefined;
            resourceInputs["connectionMark"] = args ? args.connectionMark : undefined;
            resourceInputs["connectionRate"] = args ? args.connectionRate : undefined;
            resourceInputs["connectionType"] = args ? args.connectionType : undefined;
            resourceInputs["content"] = args ? args.content : undefined;
            resourceInputs["disabled"] = args ? args.disabled : undefined;
            resourceInputs["dscp"] = args ? args.dscp : undefined;
            resourceInputs["dstAddress"] = args ? args.dstAddress : undefined;
            resourceInputs["dstAddressList"] = args ? args.dstAddressList : undefined;
            resourceInputs["dstAddressType"] = args ? args.dstAddressType : undefined;
            resourceInputs["dstLimit"] = args ? args.dstLimit : undefined;
            resourceInputs["dstPort"] = args ? args.dstPort : undefined;
            resourceInputs["fragment"] = args ? args.fragment : undefined;
            resourceInputs["hotspot"] = args ? args.hotspot : undefined;
            resourceInputs["icmpOptions"] = args ? args.icmpOptions : undefined;
            resourceInputs["inBridgePort"] = args ? args.inBridgePort : undefined;
            resourceInputs["inBridgePortList"] = args ? args.inBridgePortList : undefined;
            resourceInputs["inInterface"] = args ? args.inInterface : undefined;
            resourceInputs["inInterfaceList"] = args ? args.inInterfaceList : undefined;
            resourceInputs["ingressPriority"] = args ? args.ingressPriority : undefined;
            resourceInputs["ipsecPolicy"] = args ? args.ipsecPolicy : undefined;
            resourceInputs["ipv4Options"] = args ? args.ipv4Options : undefined;
            resourceInputs["jumpTarget"] = args ? args.jumpTarget : undefined;
            resourceInputs["layer7Protocol"] = args ? args.layer7Protocol : undefined;
            resourceInputs["limit"] = args ? args.limit : undefined;
            resourceInputs["log"] = args ? args.log : undefined;
            resourceInputs["logPrefix"] = args ? args.logPrefix : undefined;
            resourceInputs["nth"] = args ? args.nth : undefined;
            resourceInputs["outBridgePort"] = args ? args.outBridgePort : undefined;
            resourceInputs["outBridgePortList"] = args ? args.outBridgePortList : undefined;
            resourceInputs["outInterface"] = args ? args.outInterface : undefined;
            resourceInputs["outInterfaceList"] = args ? args.outInterfaceList : undefined;
            resourceInputs["packetMark"] = args ? args.packetMark : undefined;
            resourceInputs["packetSize"] = args ? args.packetSize : undefined;
            resourceInputs["perConnectionClassifier"] = args ? args.perConnectionClassifier : undefined;
            resourceInputs["placeBefore"] = args ? args.placeBefore : undefined;
            resourceInputs["port"] = args ? args.port : undefined;
            resourceInputs["priority"] = args ? args.priority : undefined;
            resourceInputs["protocol"] = args ? args.protocol : undefined;
            resourceInputs["psd"] = args ? args.psd : undefined;
            resourceInputs["random"] = args ? args.random : undefined;
            resourceInputs["routingMark"] = args ? args.routingMark : undefined;
            resourceInputs["sameNotByDst"] = args ? args.sameNotByDst : undefined;
            resourceInputs["srcAddress"] = args ? args.srcAddress : undefined;
            resourceInputs["srcAddressList"] = args ? args.srcAddressList : undefined;
            resourceInputs["srcAddressType"] = args ? args.srcAddressType : undefined;
            resourceInputs["srcMacAddress"] = args ? args.srcMacAddress : undefined;
            resourceInputs["srcPort"] = args ? args.srcPort : undefined;
            resourceInputs["tcpMss"] = args ? args.tcpMss : undefined;
            resourceInputs["time"] = args ? args.time : undefined;
            resourceInputs["toAddresses"] = args ? args.toAddresses : undefined;
            resourceInputs["toPorts"] = args ? args.toPorts : undefined;
            resourceInputs["ttl"] = args ? args.ttl : undefined;
            resourceInputs["bytes"] = undefined /*out*/;
            resourceInputs["dynamic"] = undefined /*out*/;
            resourceInputs["invalid"] = undefined /*out*/;
            resourceInputs["packets"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(IpFirewallNat.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering IpFirewallNat resources.
 */
export interface IpFirewallNatState {
    /**
     * <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
     */
    ___id_?: pulumi.Input<number>;
    /**
     * <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
     */
    ___path_?: pulumi.Input<string>;
    /**
     * Action to take if a packet is matched by the rule
     */
    action?: pulumi.Input<string>;
    /**
     * Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.
     */
    addressList?: pulumi.Input<string>;
    /**
     * Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
     * conjunction with add-dst-to-address-list or add-src-to-address-list actions.
     */
    addressListTimeout?: pulumi.Input<string>;
    /**
     * The total amount of bytes matched by the rule.
     */
    bytes?: pulumi.Input<number>;
    /**
     * Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
     * chain will be created.
     */
    chain?: pulumi.Input<string>;
    comment?: pulumi.Input<string>;
    /**
     * Matches packets only if a given amount of bytes has been transfered through the particular connection.
     */
    connectionBytes?: pulumi.Input<string>;
    /**
     * Matches connections per address or address block after given value is reached. Should be used together with
     * connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
     */
    connectionLimit?: pulumi.Input<string>;
    /**
     * Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
     * unmarked connection.
     */
    connectionMark?: pulumi.Input<string>;
    /**
     * Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
     * (0..4294967295).
     */
    connectionRate?: pulumi.Input<string>;
    /**
     * Matches packets from related connections based on information from their connection tracking helpers.
     */
    connectionType?: pulumi.Input<string>;
    /**
     * Match packets that contain specified text.
     */
    content?: pulumi.Input<string>;
    disabled?: pulumi.Input<boolean>;
    /**
     * Matches DSCP IP header field.
     */
    dscp?: pulumi.Input<number>;
    /**
     * Matches packets which destination is equal to specified IP or falls into specified IP range.
     */
    dstAddress?: pulumi.Input<string>;
    /**
     * Matches destination address of a packet against user-defined address list.
     */
    dstAddressList?: pulumi.Input<string>;
    /**
     * Matches destination address type.
     */
    dstAddressType?: pulumi.Input<string>;
    /**
     * Matches packets until a given rate is exceeded.
     */
    dstLimit?: pulumi.Input<string>;
    /**
     * List of destination port numbers or port number ranges.
     */
    dstPort?: pulumi.Input<string>;
    /**
     * Configuration item created by software, not by management interface. It is not exported, and cannot be directly
     * modified.
     */
    dynamic?: pulumi.Input<boolean>;
    /**
     * Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
     * fragments as system automatically assembles every packet
     */
    fragment?: pulumi.Input<boolean>;
    /**
     * Matches packets received from HotSpot clients against various HotSpot matchers.
     */
    hotspot?: pulumi.Input<string>;
    /**
     * Matches ICMP type: code fields.
     */
    icmpOptions?: pulumi.Input<string>;
    /**
     * Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
     * is enabled in bridge settings.
     */
    inBridgePort?: pulumi.Input<string>;
    /**
     * Set of interfaces defined in interface list. Works the same as in-bridge-port.
     */
    inBridgePortList?: pulumi.Input<string>;
    /**
     * Interface the packet has entered the router.
     */
    inInterface?: pulumi.Input<string>;
    /**
     * Set of interfaces defined in interface list. Works the same as in-interface.
     */
    inInterfaceList?: pulumi.Input<string>;
    /**
     * Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
     */
    ingressPriority?: pulumi.Input<number>;
    invalid?: pulumi.Input<boolean>;
    /**
     * Matches the policy used by IPsec. Value is written in the following format: direction, policy.
     */
    ipsecPolicy?: pulumi.Input<string>;
    /**
     * Matches IPv4 header options.
     */
    ipv4Options?: pulumi.Input<string>;
    /**
     * Name of the target chain to jump to. Applicable only if action=jump.
     */
    jumpTarget?: pulumi.Input<string>;
    /**
     * Layer7 filter name.
     */
    layer7Protocol?: pulumi.Input<string>;
    /**
     * Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
     * reached. Parameters are written in the following format: rate[/time],burst:mode.
     */
    limit?: pulumi.Input<string>;
    /**
     * Add a message to the system log.
     */
    log?: pulumi.Input<boolean>;
    /**
     * Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
     */
    logPrefix?: pulumi.Input<string>;
    /**
     * Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
     * by the rule
     */
    nth?: pulumi.Input<string>;
    /**
     * Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
     * is enabled in bridge settings.
     */
    outBridgePort?: pulumi.Input<string>;
    /**
     * Set of interfaces defined in interface list. Works the same as out-bridge-port.
     */
    outBridgePortList?: pulumi.Input<string>;
    /**
     * Interface the packet is leaving the router.
     */
    outInterface?: pulumi.Input<string>;
    /**
     * Set of interfaces defined in interface list. Works the same as out-interface.
     */
    outInterfaceList?: pulumi.Input<string>;
    /**
     * Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
     * unmarked packet.
     */
    packetMark?: pulumi.Input<string>;
    /**
     * Matches packets of specified size or size range in bytes.
     */
    packetSize?: pulumi.Input<string>;
    /**
     * The total amount of packets matched by the rule.
     */
    packets?: pulumi.Input<number>;
    /**
     * PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
     * in one particular stream.
     */
    perConnectionClassifier?: pulumi.Input<string>;
    /**
     * Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
     * think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
     */
    placeBefore?: pulumi.Input<string>;
    /**
     * Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
     * protocol is TCP or UDP
     */
    port?: pulumi.Input<string>;
    /**
     * Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP
     * bit, or from the priority that has been set using the set-priority action.
     */
    priority?: pulumi.Input<number>;
    /**
     * Matches particular IP protocol specified by protocol name or number.
     */
    protocol?: pulumi.Input<string>;
    /**
     * Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
     * LowPortWeight, HighPortWeight.
     */
    psd?: pulumi.Input<string>;
    /**
     * Matches packets randomly with a given probability.
     */
    random?: pulumi.Input<number>;
    /**
     * Matches packets marked by mangle facility with particular routing mark.
     */
    routingMark?: pulumi.Input<string>;
    /**
     * Specifies whether to take into account or not destination IP address when selecting a new source IP address. Applicable
     * if action=same
     */
    sameNotByDst?: pulumi.Input<boolean>;
    /**
     * Matches packets which source is equal to specified IP or falls into a specified IP range.
     */
    srcAddress?: pulumi.Input<string>;
    /**
     * Matches source address of a packet against user-defined address list.
     */
    srcAddressList?: pulumi.Input<string>;
    /**
     * Matches source address type.
     */
    srcAddressType?: pulumi.Input<string>;
    /**
     * Matches source MAC address of the packet.
     */
    srcMacAddress?: pulumi.Input<string>;
    /**
     * List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
     */
    srcPort?: pulumi.Input<string>;
    /**
     * Matches TCP MSS value of an IP packet.
     */
    tcpMss?: pulumi.Input<string>;
    /**
     * Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
     * and date.
     */
    time?: pulumi.Input<string>;
    /**
     * Replace original address with specified one. Applicable if action is dst-nat, netmap, same, src-nat.
     */
    toAddresses?: pulumi.Input<string>;
    /**
     * Replace the original port with the specified one. Applicable if action is dst-nat, redirect, masquerade, netmap, same,
     * src-nat.
     */
    toPorts?: pulumi.Input<string>;
    /**
     * Matches packets TTL value.
     */
    ttl?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a IpFirewallNat resource.
 */
export interface IpFirewallNatArgs {
    /**
     * <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
     */
    ___id_?: pulumi.Input<number>;
    /**
     * <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
     */
    ___path_?: pulumi.Input<string>;
    /**
     * Action to take if a packet is matched by the rule
     */
    action: pulumi.Input<string>;
    /**
     * Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.
     */
    addressList?: pulumi.Input<string>;
    /**
     * Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
     * conjunction with add-dst-to-address-list or add-src-to-address-list actions.
     */
    addressListTimeout?: pulumi.Input<string>;
    /**
     * Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
     * chain will be created.
     */
    chain: pulumi.Input<string>;
    comment?: pulumi.Input<string>;
    /**
     * Matches packets only if a given amount of bytes has been transfered through the particular connection.
     */
    connectionBytes?: pulumi.Input<string>;
    /**
     * Matches connections per address or address block after given value is reached. Should be used together with
     * connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
     */
    connectionLimit?: pulumi.Input<string>;
    /**
     * Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
     * unmarked connection.
     */
    connectionMark?: pulumi.Input<string>;
    /**
     * Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
     * (0..4294967295).
     */
    connectionRate?: pulumi.Input<string>;
    /**
     * Matches packets from related connections based on information from their connection tracking helpers.
     */
    connectionType?: pulumi.Input<string>;
    /**
     * Match packets that contain specified text.
     */
    content?: pulumi.Input<string>;
    disabled?: pulumi.Input<boolean>;
    /**
     * Matches DSCP IP header field.
     */
    dscp?: pulumi.Input<number>;
    /**
     * Matches packets which destination is equal to specified IP or falls into specified IP range.
     */
    dstAddress?: pulumi.Input<string>;
    /**
     * Matches destination address of a packet against user-defined address list.
     */
    dstAddressList?: pulumi.Input<string>;
    /**
     * Matches destination address type.
     */
    dstAddressType?: pulumi.Input<string>;
    /**
     * Matches packets until a given rate is exceeded.
     */
    dstLimit?: pulumi.Input<string>;
    /**
     * List of destination port numbers or port number ranges.
     */
    dstPort?: pulumi.Input<string>;
    /**
     * Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
     * fragments as system automatically assembles every packet
     */
    fragment?: pulumi.Input<boolean>;
    /**
     * Matches packets received from HotSpot clients against various HotSpot matchers.
     */
    hotspot?: pulumi.Input<string>;
    /**
     * Matches ICMP type: code fields.
     */
    icmpOptions?: pulumi.Input<string>;
    /**
     * Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
     * is enabled in bridge settings.
     */
    inBridgePort?: pulumi.Input<string>;
    /**
     * Set of interfaces defined in interface list. Works the same as in-bridge-port.
     */
    inBridgePortList?: pulumi.Input<string>;
    /**
     * Interface the packet has entered the router.
     */
    inInterface?: pulumi.Input<string>;
    /**
     * Set of interfaces defined in interface list. Works the same as in-interface.
     */
    inInterfaceList?: pulumi.Input<string>;
    /**
     * Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
     */
    ingressPriority?: pulumi.Input<number>;
    /**
     * Matches the policy used by IPsec. Value is written in the following format: direction, policy.
     */
    ipsecPolicy?: pulumi.Input<string>;
    /**
     * Matches IPv4 header options.
     */
    ipv4Options?: pulumi.Input<string>;
    /**
     * Name of the target chain to jump to. Applicable only if action=jump.
     */
    jumpTarget?: pulumi.Input<string>;
    /**
     * Layer7 filter name.
     */
    layer7Protocol?: pulumi.Input<string>;
    /**
     * Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
     * reached. Parameters are written in the following format: rate[/time],burst:mode.
     */
    limit?: pulumi.Input<string>;
    /**
     * Add a message to the system log.
     */
    log?: pulumi.Input<boolean>;
    /**
     * Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
     */
    logPrefix?: pulumi.Input<string>;
    /**
     * Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
     * by the rule
     */
    nth?: pulumi.Input<string>;
    /**
     * Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
     * is enabled in bridge settings.
     */
    outBridgePort?: pulumi.Input<string>;
    /**
     * Set of interfaces defined in interface list. Works the same as out-bridge-port.
     */
    outBridgePortList?: pulumi.Input<string>;
    /**
     * Interface the packet is leaving the router.
     */
    outInterface?: pulumi.Input<string>;
    /**
     * Set of interfaces defined in interface list. Works the same as out-interface.
     */
    outInterfaceList?: pulumi.Input<string>;
    /**
     * Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
     * unmarked packet.
     */
    packetMark?: pulumi.Input<string>;
    /**
     * Matches packets of specified size or size range in bytes.
     */
    packetSize?: pulumi.Input<string>;
    /**
     * PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
     * in one particular stream.
     */
    perConnectionClassifier?: pulumi.Input<string>;
    /**
     * Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
     * think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
     */
    placeBefore?: pulumi.Input<string>;
    /**
     * Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
     * protocol is TCP or UDP
     */
    port?: pulumi.Input<string>;
    /**
     * Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP
     * bit, or from the priority that has been set using the set-priority action.
     */
    priority?: pulumi.Input<number>;
    /**
     * Matches particular IP protocol specified by protocol name or number.
     */
    protocol?: pulumi.Input<string>;
    /**
     * Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
     * LowPortWeight, HighPortWeight.
     */
    psd?: pulumi.Input<string>;
    /**
     * Matches packets randomly with a given probability.
     */
    random?: pulumi.Input<number>;
    /**
     * Matches packets marked by mangle facility with particular routing mark.
     */
    routingMark?: pulumi.Input<string>;
    /**
     * Specifies whether to take into account or not destination IP address when selecting a new source IP address. Applicable
     * if action=same
     */
    sameNotByDst?: pulumi.Input<boolean>;
    /**
     * Matches packets which source is equal to specified IP or falls into a specified IP range.
     */
    srcAddress?: pulumi.Input<string>;
    /**
     * Matches source address of a packet against user-defined address list.
     */
    srcAddressList?: pulumi.Input<string>;
    /**
     * Matches source address type.
     */
    srcAddressType?: pulumi.Input<string>;
    /**
     * Matches source MAC address of the packet.
     */
    srcMacAddress?: pulumi.Input<string>;
    /**
     * List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
     */
    srcPort?: pulumi.Input<string>;
    /**
     * Matches TCP MSS value of an IP packet.
     */
    tcpMss?: pulumi.Input<string>;
    /**
     * Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
     * and date.
     */
    time?: pulumi.Input<string>;
    /**
     * Replace original address with specified one. Applicable if action is dst-nat, netmap, same, src-nat.
     */
    toAddresses?: pulumi.Input<string>;
    /**
     * Replace the original port with the specified one. Applicable if action is dst-nat, redirect, masquerade, netmap, same,
     * src-nat.
     */
    toPorts?: pulumi.Input<string>;
    /**
     * Matches packets TTL value.
     */
    ttl?: pulumi.Input<string>;
}
