// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "../utilities";

/**
 * ## Example Usage
 *
 * ```typescript
 * import * as pulumi from "@pulumi/pulumi";
 * import * as routeros from "@pulumi/routeros";
 *
 * const testWgInterface = new routeros.iface.InterfaceWireguard("testWgInterface", {listenPort: 13231});
 * const wgPeer = new routeros.iface.InterfaceWireguardPeer("wgPeer", {
 *     "interface": testWgInterface.name,
 *     publicKey: "MY_BASE_64_PUBLIC_KEY",
 *     allowedAddresses: [
 *         "192.168.0.0/16",
 *         "172.16.0.0/12",
 *         "10.0.0.0/8",
 *     ],
 * });
 * ```
 *
 * ## Import
 *
 * #The ID can be found via API or the terminal #The command for the terminal is -> :put [/interface/wireguard/peers get [print show-ids]]
 *
 * ```sh
 *  $ pulumi import routeros:Iface/interfaceWireguardPeer:InterfaceWireguardPeer wg_peer "*0"
 * ```
 */
export class InterfaceWireguardPeer extends pulumi.CustomResource {
    /**
     * Get an existing InterfaceWireguardPeer resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: InterfaceWireguardPeerState, opts?: pulumi.CustomResourceOptions): InterfaceWireguardPeer {
        return new InterfaceWireguardPeer(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'routeros:Iface/interfaceWireguardPeer:InterfaceWireguardPeer';

    /**
     * Returns true if the given object is an instance of InterfaceWireguardPeer.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is InterfaceWireguardPeer {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === InterfaceWireguardPeer.__pulumiType;
    }

    /**
     * <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
     */
    public readonly ___id_!: pulumi.Output<number | undefined>;
    /**
     * <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
     */
    public readonly ___path_!: pulumi.Output<string | undefined>;
    /**
     * List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.
     */
    public readonly allowedAddresses!: pulumi.Output<string[] | undefined>;
    public readonly comment!: pulumi.Output<string | undefined>;
    /**
     * The most recent source IP address of correctly authenticated packets from the peer.
     */
    public /*out*/ readonly currentEndpointAddress!: pulumi.Output<string>;
    /**
     * The most recent source IP port of correctly authenticated packets from the peer.
     */
    public /*out*/ readonly currentEndpointPort!: pulumi.Output<number>;
    public readonly disabled!: pulumi.Output<boolean | undefined>;
    /**
     * An endpoint IP or hostname can be left blank to allow remote connection from any address.
     */
    public readonly endpointAddress!: pulumi.Output<string>;
    /**
     * An endpoint port can be left blank to allow remote connection from any port.
     */
    public readonly endpointPort!: pulumi.Output<string>;
    /**
     * Name of the interface.
     */
    public readonly interface!: pulumi.Output<string>;
    /**
     * Time in seconds after the last successful handshake.
     */
    public /*out*/ readonly lastHandshake!: pulumi.Output<string>;
    /**
     * A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.
     */
    public readonly persistentKeepalive!: pulumi.Output<string | undefined>;
    /**
     * A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
     */
    public readonly presharedKey!: pulumi.Output<string | undefined>;
    /**
     * The remote peer's calculated public key.
     */
    public readonly publicKey!: pulumi.Output<string>;
    /**
     * The total amount of bytes received from the peer.
     */
    public /*out*/ readonly rx!: pulumi.Output<string>;
    /**
     * The total amount of bytes transmitted to the peer.
     */
    public /*out*/ readonly tx!: pulumi.Output<string>;

    /**
     * Create a InterfaceWireguardPeer resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: InterfaceWireguardPeerArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: InterfaceWireguardPeerArgs | InterfaceWireguardPeerState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as InterfaceWireguardPeerState | undefined;
            resourceInputs["___id_"] = state ? state.___id_ : undefined;
            resourceInputs["___path_"] = state ? state.___path_ : undefined;
            resourceInputs["allowedAddresses"] = state ? state.allowedAddresses : undefined;
            resourceInputs["comment"] = state ? state.comment : undefined;
            resourceInputs["currentEndpointAddress"] = state ? state.currentEndpointAddress : undefined;
            resourceInputs["currentEndpointPort"] = state ? state.currentEndpointPort : undefined;
            resourceInputs["disabled"] = state ? state.disabled : undefined;
            resourceInputs["endpointAddress"] = state ? state.endpointAddress : undefined;
            resourceInputs["endpointPort"] = state ? state.endpointPort : undefined;
            resourceInputs["interface"] = state ? state.interface : undefined;
            resourceInputs["lastHandshake"] = state ? state.lastHandshake : undefined;
            resourceInputs["persistentKeepalive"] = state ? state.persistentKeepalive : undefined;
            resourceInputs["presharedKey"] = state ? state.presharedKey : undefined;
            resourceInputs["publicKey"] = state ? state.publicKey : undefined;
            resourceInputs["rx"] = state ? state.rx : undefined;
            resourceInputs["tx"] = state ? state.tx : undefined;
        } else {
            const args = argsOrState as InterfaceWireguardPeerArgs | undefined;
            if ((!args || args.interface === undefined) && !opts.urn) {
                throw new Error("Missing required property 'interface'");
            }
            if ((!args || args.publicKey === undefined) && !opts.urn) {
                throw new Error("Missing required property 'publicKey'");
            }
            resourceInputs["___id_"] = args ? args.___id_ : undefined;
            resourceInputs["___path_"] = args ? args.___path_ : undefined;
            resourceInputs["allowedAddresses"] = args ? args.allowedAddresses : undefined;
            resourceInputs["comment"] = args ? args.comment : undefined;
            resourceInputs["disabled"] = args ? args.disabled : undefined;
            resourceInputs["endpointAddress"] = args ? args.endpointAddress : undefined;
            resourceInputs["endpointPort"] = args ? args.endpointPort : undefined;
            resourceInputs["interface"] = args ? args.interface : undefined;
            resourceInputs["persistentKeepalive"] = args ? args.persistentKeepalive : undefined;
            resourceInputs["presharedKey"] = args?.presharedKey ? pulumi.secret(args.presharedKey) : undefined;
            resourceInputs["publicKey"] = args ? args.publicKey : undefined;
            resourceInputs["currentEndpointAddress"] = undefined /*out*/;
            resourceInputs["currentEndpointPort"] = undefined /*out*/;
            resourceInputs["lastHandshake"] = undefined /*out*/;
            resourceInputs["rx"] = undefined /*out*/;
            resourceInputs["tx"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["presharedKey"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(InterfaceWireguardPeer.__pulumiType, name, resourceInputs, opts);
    }
}

/**
 * Input properties used for looking up and filtering InterfaceWireguardPeer resources.
 */
export interface InterfaceWireguardPeerState {
    /**
     * <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
     */
    ___id_?: pulumi.Input<number>;
    /**
     * <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
     */
    ___path_?: pulumi.Input<string>;
    /**
     * List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.
     */
    allowedAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    comment?: pulumi.Input<string>;
    /**
     * The most recent source IP address of correctly authenticated packets from the peer.
     */
    currentEndpointAddress?: pulumi.Input<string>;
    /**
     * The most recent source IP port of correctly authenticated packets from the peer.
     */
    currentEndpointPort?: pulumi.Input<number>;
    disabled?: pulumi.Input<boolean>;
    /**
     * An endpoint IP or hostname can be left blank to allow remote connection from any address.
     */
    endpointAddress?: pulumi.Input<string>;
    /**
     * An endpoint port can be left blank to allow remote connection from any port.
     */
    endpointPort?: pulumi.Input<string>;
    /**
     * Name of the interface.
     */
    interface?: pulumi.Input<string>;
    /**
     * Time in seconds after the last successful handshake.
     */
    lastHandshake?: pulumi.Input<string>;
    /**
     * A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.
     */
    persistentKeepalive?: pulumi.Input<string>;
    /**
     * A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
     */
    presharedKey?: pulumi.Input<string>;
    /**
     * The remote peer's calculated public key.
     */
    publicKey?: pulumi.Input<string>;
    /**
     * The total amount of bytes received from the peer.
     */
    rx?: pulumi.Input<string>;
    /**
     * The total amount of bytes transmitted to the peer.
     */
    tx?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a InterfaceWireguardPeer resource.
 */
export interface InterfaceWireguardPeerArgs {
    /**
     * <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
     */
    ___id_?: pulumi.Input<number>;
    /**
     * <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
     */
    ___path_?: pulumi.Input<string>;
    /**
     * List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.
     */
    allowedAddresses?: pulumi.Input<pulumi.Input<string>[]>;
    comment?: pulumi.Input<string>;
    disabled?: pulumi.Input<boolean>;
    /**
     * An endpoint IP or hostname can be left blank to allow remote connection from any address.
     */
    endpointAddress?: pulumi.Input<string>;
    /**
     * An endpoint port can be left blank to allow remote connection from any port.
     */
    endpointPort?: pulumi.Input<string>;
    /**
     * Name of the interface.
     */
    interface: pulumi.Input<string>;
    /**
     * A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.
     */
    persistentKeepalive?: pulumi.Input<string>;
    /**
     * A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
     */
    presharedKey?: pulumi.Input<string>;
    /**
     * The remote peer's calculated public key.
     */
    publicKey: pulumi.Input<string>;
}
