// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package ip

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Import
//
// #The ID can be found via API or the terminal #The command for the terminal is -> :put [/ip/firewall/mangle get [print show-ids]]
//
// ```sh
//
//	$ pulumi import routeros:Ip/ipFirewallMangle:IpFirewallMangle rule "*0"
//
// ```
type IpFirewallMangle struct {
	pulumi.CustomResourceState

	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ pulumi.IntPtrOutput `pulumi:"___id_"`
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ pulumi.StringPtrOutput `pulumi:"___path_"`
	// Action to take if a packet is matched by the rule.
	Action pulumi.StringOutput `pulumi:"action"`
	// Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.
	AddressList pulumi.StringPtrOutput `pulumi:"addressList"`
	// Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
	// conjunction with add-dst-to-address-list or add-src-to-address-list actions.
	AddressListTimeout pulumi.StringPtrOutput `pulumi:"addressListTimeout"`
	// The total amount of bytes matched by the rule.
	Bytes pulumi.IntOutput `pulumi:"bytes"`
	// Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
	// chain will be created.
	Chain   pulumi.StringOutput    `pulumi:"chain"`
	Comment pulumi.StringPtrOutput `pulumi:"comment"`
	// Matches packets only if a given amount of bytes has been transfered through the particular connection.
	ConnectionBytes pulumi.StringPtrOutput `pulumi:"connectionBytes"`
	// Matches connections per address or address block after given value is reached. Should be used together with
	// connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
	ConnectionLimit pulumi.StringPtrOutput `pulumi:"connectionLimit"`
	// Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
	// unmarked connection.
	ConnectionMark pulumi.StringPtrOutput `pulumi:"connectionMark"`
	// Can match connections that are srcnatted, dstnatted or both.
	ConnectionNatState pulumi.StringPtrOutput `pulumi:"connectionNatState"`
	// Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
	// (0..4294967295).
	ConnectionRate pulumi.StringPtrOutput `pulumi:"connectionRate"`
	// Interprets the connection tracking analysis data for a particular packet.
	ConnectionState pulumi.StringPtrOutput `pulumi:"connectionState"`
	// Matches packets from related connections based on information from their connection tracking helpers.
	ConnectionType pulumi.StringPtrOutput `pulumi:"connectionType"`
	// Match packets that contain specified text.
	Content  pulumi.StringPtrOutput `pulumi:"content"`
	Disabled pulumi.BoolPtrOutput   `pulumi:"disabled"`
	// Matches DSCP IP header field.
	Dscp pulumi.IntPtrOutput `pulumi:"dscp"`
	// Matches packets which destination is equal to specified IP or falls into specified IP range.
	DstAddress pulumi.StringPtrOutput `pulumi:"dstAddress"`
	// Matches destination address of a packet against user-defined address list.
	DstAddressList pulumi.StringPtrOutput `pulumi:"dstAddressList"`
	// Matches destination address type.
	DstAddressType pulumi.StringPtrOutput `pulumi:"dstAddressType"`
	// Matches packets until a given rate is exceeded.
	DstLimit pulumi.StringPtrOutput `pulumi:"dstLimit"`
	// List of destination port numbers or port number ranges.
	DstPort pulumi.StringPtrOutput `pulumi:"dstPort"`
	// Configuration item created by software, not by management interface. It is not exported, and cannot be directly
	// modified.
	Dynamic pulumi.BoolOutput `pulumi:"dynamic"`
	// Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
	// fragments as system automatically assembles every packet
	Fragment pulumi.BoolPtrOutput `pulumi:"fragment"`
	// Matches packets received from HotSpot clients against various HotSpot matchers.
	Hotspot pulumi.StringPtrOutput `pulumi:"hotspot"`
	// Matches ICMP type: code fields.
	IcmpOptions pulumi.StringPtrOutput `pulumi:"icmpOptions"`
	// Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
	// is enabled in bridge settings.
	InBridgePort pulumi.StringPtrOutput `pulumi:"inBridgePort"`
	// Set of interfaces defined in interface list. Works the same as in-bridge-port.
	InBridgePortList pulumi.StringPtrOutput `pulumi:"inBridgePortList"`
	// Interface the packet has entered the router.
	InInterface pulumi.StringPtrOutput `pulumi:"inInterface"`
	// Set of interfaces defined in interface list. Works the same as in-interface.
	InInterfaceList pulumi.StringPtrOutput `pulumi:"inInterfaceList"`
	// Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
	IngressPriority pulumi.IntPtrOutput `pulumi:"ingressPriority"`
	Invalid         pulumi.BoolOutput   `pulumi:"invalid"`
	// Matches the policy used by IPsec. Value is written in the following format: direction, policy.
	IpsecPolicy pulumi.StringPtrOutput `pulumi:"ipsecPolicy"`
	// Matches IPv4 header options.
	Ipv4Options pulumi.StringPtrOutput `pulumi:"ipv4Options"`
	// Name of the target chain to jump to. Applicable only if action=jump.
	JumpTarget pulumi.StringPtrOutput `pulumi:"jumpTarget"`
	// Layer7 filter name.
	Layer7Protocol pulumi.StringPtrOutput `pulumi:"layer7Protocol"`
	// Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
	// reached. Parameters are written in the following format: rate[/time],burst:mode.
	Limit pulumi.StringPtrOutput `pulumi:"limit"`
	// Add a message to the system log.
	Log pulumi.BoolPtrOutput `pulumi:"log"`
	// Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
	LogPrefix pulumi.StringPtrOutput `pulumi:"logPrefix"`
	// Sets a new connection-mark value.
	NewConnectionMark pulumi.StringPtrOutput `pulumi:"newConnectionMark"`
	// Sets a new DSCP value for a packet.
	NewDscp pulumi.IntPtrOutput `pulumi:"newDscp"`
	// Sets a new MSS for a packet. > clamp-to-pmtu feature sets (DF) bit in the IP header to dynamically discover the PMTU of
	// a path. > Host sends all datagrams on that path with the DF bit set until receives ICMP. > Destination Unreachable
	// messages with a code meaning "fragmentation needed and DF set". > Upon receipt of such a message, the source host
	// reduces its assumed PMTU for the path.
	NewMss pulumi.StringPtrOutput `pulumi:"newMss"`
	// Sets a new packet-mark value.
	NewPacketMark pulumi.StringPtrOutput `pulumi:"newPacketMark"`
	// Sets a new priority for a packet. This can be the VLAN, WMM, DSCP or MPLS EXP priority. This property can also be used
	// to set an internal priority.
	NewPriority pulumi.StringPtrOutput `pulumi:"newPriority"`
	// Sets a new routing-mark value.
	NewRoutingMark pulumi.StringPtrOutput `pulumi:"newRoutingMark"`
	// Sets a new TTL for a packet.
	NewTtl pulumi.StringPtrOutput `pulumi:"newTtl"`
	// Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
	// by the rule
	Nth pulumi.StringPtrOutput `pulumi:"nth"`
	// Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
	// is enabled in bridge settings.
	OutBridgePort pulumi.StringPtrOutput `pulumi:"outBridgePort"`
	// Set of interfaces defined in interface list. Works the same as out-bridge-port.
	OutBridgePortList pulumi.StringPtrOutput `pulumi:"outBridgePortList"`
	// Interface the packet is leaving the router.
	OutInterface pulumi.StringPtrOutput `pulumi:"outInterface"`
	// Set of interfaces defined in interface list. Works the same as out-interface.
	OutInterfaceList pulumi.StringPtrOutput `pulumi:"outInterfaceList"`
	// Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
	// unmarked packet.
	PacketMark pulumi.StringPtrOutput `pulumi:"packetMark"`
	// Matches packets of specified size or size range in bytes.
	PacketSize pulumi.StringPtrOutput `pulumi:"packetSize"`
	// The total amount of packets matched by the rule.
	Packets pulumi.IntOutput `pulumi:"packets"`
	// Whether to let the packet to pass further (like action passthrough) into the firewall or not (property only valid some
	// actions).
	Passthrough pulumi.BoolOutput `pulumi:"passthrough"`
	// PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
	// in one particular stream.
	PerConnectionClassifier pulumi.StringPtrOutput `pulumi:"perConnectionClassifier"`
	// Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
	// think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
	PlaceBefore pulumi.StringPtrOutput `pulumi:"placeBefore"`
	// Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
	// protocol is TCP or UDP
	Port pulumi.StringPtrOutput `pulumi:"port"`
	// Matches particular IP protocol specified by protocol name or number.
	Protocol pulumi.StringPtrOutput `pulumi:"protocol"`
	// Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
	// LowPortWeight, HighPortWeight.
	Psd pulumi.StringPtrOutput `pulumi:"psd"`
	// Matches packets randomly with a given probability.
	Random pulumi.IntPtrOutput `pulumi:"random"`
	// Matches packets with a specific gateway.
	RouteDst pulumi.StringPtrOutput `pulumi:"routeDst"`
	// Matches packets marked by mangle facility with particular routing mark.
	RoutingMark pulumi.StringPtrOutput `pulumi:"routingMark"`
	// Matches packets which source is equal to specified IP or falls into a specified IP range.
	SrcAddress pulumi.StringPtrOutput `pulumi:"srcAddress"`
	// Matches source address of a packet against user-defined address list.
	SrcAddressList pulumi.StringPtrOutput `pulumi:"srcAddressList"`
	// Matches source address type.
	SrcAddressType pulumi.StringPtrOutput `pulumi:"srcAddressType"`
	// Matches source MAC address of the packet.
	SrcMacAddress pulumi.StringPtrOutput `pulumi:"srcMacAddress"`
	// List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
	SrcPort pulumi.StringPtrOutput `pulumi:"srcPort"`
	// Matches specified TCP flags.
	TcpFlags pulumi.StringPtrOutput `pulumi:"tcpFlags"`
	// Matches TCP MSS value of an IP packet.
	TcpMss pulumi.StringPtrOutput `pulumi:"tcpMss"`
	// Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
	// and date.
	Time pulumi.StringPtrOutput `pulumi:"time"`
	// Allows matching HTTPS traffic based on TLS SNI hostname.
	TlsHost pulumi.StringPtrOutput `pulumi:"tlsHost"`
	// Matches packets TTL value.
	Ttl pulumi.StringPtrOutput `pulumi:"ttl"`
}

// NewIpFirewallMangle registers a new resource with the given unique name, arguments, and options.
func NewIpFirewallMangle(ctx *pulumi.Context,
	name string, args *IpFirewallMangleArgs, opts ...pulumi.ResourceOption) (*IpFirewallMangle, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Action == nil {
		return nil, errors.New("invalid value for required argument 'Action'")
	}
	if args.Chain == nil {
		return nil, errors.New("invalid value for required argument 'Chain'")
	}
	var resource IpFirewallMangle
	err := ctx.RegisterResource("routeros:Ip/ipFirewallMangle:IpFirewallMangle", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIpFirewallMangle gets an existing IpFirewallMangle resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIpFirewallMangle(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IpFirewallMangleState, opts ...pulumi.ResourceOption) (*IpFirewallMangle, error) {
	var resource IpFirewallMangle
	err := ctx.ReadResource("routeros:Ip/ipFirewallMangle:IpFirewallMangle", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering IpFirewallMangle resources.
type ipFirewallMangleState struct {
	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ *int `pulumi:"___id_"`
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ *string `pulumi:"___path_"`
	// Action to take if a packet is matched by the rule.
	Action *string `pulumi:"action"`
	// Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.
	AddressList *string `pulumi:"addressList"`
	// Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
	// conjunction with add-dst-to-address-list or add-src-to-address-list actions.
	AddressListTimeout *string `pulumi:"addressListTimeout"`
	// The total amount of bytes matched by the rule.
	Bytes *int `pulumi:"bytes"`
	// Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
	// chain will be created.
	Chain   *string `pulumi:"chain"`
	Comment *string `pulumi:"comment"`
	// Matches packets only if a given amount of bytes has been transfered through the particular connection.
	ConnectionBytes *string `pulumi:"connectionBytes"`
	// Matches connections per address or address block after given value is reached. Should be used together with
	// connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
	ConnectionLimit *string `pulumi:"connectionLimit"`
	// Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
	// unmarked connection.
	ConnectionMark *string `pulumi:"connectionMark"`
	// Can match connections that are srcnatted, dstnatted or both.
	ConnectionNatState *string `pulumi:"connectionNatState"`
	// Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
	// (0..4294967295).
	ConnectionRate *string `pulumi:"connectionRate"`
	// Interprets the connection tracking analysis data for a particular packet.
	ConnectionState *string `pulumi:"connectionState"`
	// Matches packets from related connections based on information from their connection tracking helpers.
	ConnectionType *string `pulumi:"connectionType"`
	// Match packets that contain specified text.
	Content  *string `pulumi:"content"`
	Disabled *bool   `pulumi:"disabled"`
	// Matches DSCP IP header field.
	Dscp *int `pulumi:"dscp"`
	// Matches packets which destination is equal to specified IP or falls into specified IP range.
	DstAddress *string `pulumi:"dstAddress"`
	// Matches destination address of a packet against user-defined address list.
	DstAddressList *string `pulumi:"dstAddressList"`
	// Matches destination address type.
	DstAddressType *string `pulumi:"dstAddressType"`
	// Matches packets until a given rate is exceeded.
	DstLimit *string `pulumi:"dstLimit"`
	// List of destination port numbers or port number ranges.
	DstPort *string `pulumi:"dstPort"`
	// Configuration item created by software, not by management interface. It is not exported, and cannot be directly
	// modified.
	Dynamic *bool `pulumi:"dynamic"`
	// Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
	// fragments as system automatically assembles every packet
	Fragment *bool `pulumi:"fragment"`
	// Matches packets received from HotSpot clients against various HotSpot matchers.
	Hotspot *string `pulumi:"hotspot"`
	// Matches ICMP type: code fields.
	IcmpOptions *string `pulumi:"icmpOptions"`
	// Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
	// is enabled in bridge settings.
	InBridgePort *string `pulumi:"inBridgePort"`
	// Set of interfaces defined in interface list. Works the same as in-bridge-port.
	InBridgePortList *string `pulumi:"inBridgePortList"`
	// Interface the packet has entered the router.
	InInterface *string `pulumi:"inInterface"`
	// Set of interfaces defined in interface list. Works the same as in-interface.
	InInterfaceList *string `pulumi:"inInterfaceList"`
	// Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
	IngressPriority *int  `pulumi:"ingressPriority"`
	Invalid         *bool `pulumi:"invalid"`
	// Matches the policy used by IPsec. Value is written in the following format: direction, policy.
	IpsecPolicy *string `pulumi:"ipsecPolicy"`
	// Matches IPv4 header options.
	Ipv4Options *string `pulumi:"ipv4Options"`
	// Name of the target chain to jump to. Applicable only if action=jump.
	JumpTarget *string `pulumi:"jumpTarget"`
	// Layer7 filter name.
	Layer7Protocol *string `pulumi:"layer7Protocol"`
	// Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
	// reached. Parameters are written in the following format: rate[/time],burst:mode.
	Limit *string `pulumi:"limit"`
	// Add a message to the system log.
	Log *bool `pulumi:"log"`
	// Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
	LogPrefix *string `pulumi:"logPrefix"`
	// Sets a new connection-mark value.
	NewConnectionMark *string `pulumi:"newConnectionMark"`
	// Sets a new DSCP value for a packet.
	NewDscp *int `pulumi:"newDscp"`
	// Sets a new MSS for a packet. > clamp-to-pmtu feature sets (DF) bit in the IP header to dynamically discover the PMTU of
	// a path. > Host sends all datagrams on that path with the DF bit set until receives ICMP. > Destination Unreachable
	// messages with a code meaning "fragmentation needed and DF set". > Upon receipt of such a message, the source host
	// reduces its assumed PMTU for the path.
	NewMss *string `pulumi:"newMss"`
	// Sets a new packet-mark value.
	NewPacketMark *string `pulumi:"newPacketMark"`
	// Sets a new priority for a packet. This can be the VLAN, WMM, DSCP or MPLS EXP priority. This property can also be used
	// to set an internal priority.
	NewPriority *string `pulumi:"newPriority"`
	// Sets a new routing-mark value.
	NewRoutingMark *string `pulumi:"newRoutingMark"`
	// Sets a new TTL for a packet.
	NewTtl *string `pulumi:"newTtl"`
	// Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
	// by the rule
	Nth *string `pulumi:"nth"`
	// Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
	// is enabled in bridge settings.
	OutBridgePort *string `pulumi:"outBridgePort"`
	// Set of interfaces defined in interface list. Works the same as out-bridge-port.
	OutBridgePortList *string `pulumi:"outBridgePortList"`
	// Interface the packet is leaving the router.
	OutInterface *string `pulumi:"outInterface"`
	// Set of interfaces defined in interface list. Works the same as out-interface.
	OutInterfaceList *string `pulumi:"outInterfaceList"`
	// Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
	// unmarked packet.
	PacketMark *string `pulumi:"packetMark"`
	// Matches packets of specified size or size range in bytes.
	PacketSize *string `pulumi:"packetSize"`
	// The total amount of packets matched by the rule.
	Packets *int `pulumi:"packets"`
	// Whether to let the packet to pass further (like action passthrough) into the firewall or not (property only valid some
	// actions).
	Passthrough *bool `pulumi:"passthrough"`
	// PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
	// in one particular stream.
	PerConnectionClassifier *string `pulumi:"perConnectionClassifier"`
	// Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
	// think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
	PlaceBefore *string `pulumi:"placeBefore"`
	// Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
	// protocol is TCP or UDP
	Port *string `pulumi:"port"`
	// Matches particular IP protocol specified by protocol name or number.
	Protocol *string `pulumi:"protocol"`
	// Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
	// LowPortWeight, HighPortWeight.
	Psd *string `pulumi:"psd"`
	// Matches packets randomly with a given probability.
	Random *int `pulumi:"random"`
	// Matches packets with a specific gateway.
	RouteDst *string `pulumi:"routeDst"`
	// Matches packets marked by mangle facility with particular routing mark.
	RoutingMark *string `pulumi:"routingMark"`
	// Matches packets which source is equal to specified IP or falls into a specified IP range.
	SrcAddress *string `pulumi:"srcAddress"`
	// Matches source address of a packet against user-defined address list.
	SrcAddressList *string `pulumi:"srcAddressList"`
	// Matches source address type.
	SrcAddressType *string `pulumi:"srcAddressType"`
	// Matches source MAC address of the packet.
	SrcMacAddress *string `pulumi:"srcMacAddress"`
	// List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
	SrcPort *string `pulumi:"srcPort"`
	// Matches specified TCP flags.
	TcpFlags *string `pulumi:"tcpFlags"`
	// Matches TCP MSS value of an IP packet.
	TcpMss *string `pulumi:"tcpMss"`
	// Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
	// and date.
	Time *string `pulumi:"time"`
	// Allows matching HTTPS traffic based on TLS SNI hostname.
	TlsHost *string `pulumi:"tlsHost"`
	// Matches packets TTL value.
	Ttl *string `pulumi:"ttl"`
}

type IpFirewallMangleState struct {
	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ pulumi.IntPtrInput
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ pulumi.StringPtrInput
	// Action to take if a packet is matched by the rule.
	Action pulumi.StringPtrInput
	// Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.
	AddressList pulumi.StringPtrInput
	// Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
	// conjunction with add-dst-to-address-list or add-src-to-address-list actions.
	AddressListTimeout pulumi.StringPtrInput
	// The total amount of bytes matched by the rule.
	Bytes pulumi.IntPtrInput
	// Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
	// chain will be created.
	Chain   pulumi.StringPtrInput
	Comment pulumi.StringPtrInput
	// Matches packets only if a given amount of bytes has been transfered through the particular connection.
	ConnectionBytes pulumi.StringPtrInput
	// Matches connections per address or address block after given value is reached. Should be used together with
	// connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
	ConnectionLimit pulumi.StringPtrInput
	// Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
	// unmarked connection.
	ConnectionMark pulumi.StringPtrInput
	// Can match connections that are srcnatted, dstnatted or both.
	ConnectionNatState pulumi.StringPtrInput
	// Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
	// (0..4294967295).
	ConnectionRate pulumi.StringPtrInput
	// Interprets the connection tracking analysis data for a particular packet.
	ConnectionState pulumi.StringPtrInput
	// Matches packets from related connections based on information from their connection tracking helpers.
	ConnectionType pulumi.StringPtrInput
	// Match packets that contain specified text.
	Content  pulumi.StringPtrInput
	Disabled pulumi.BoolPtrInput
	// Matches DSCP IP header field.
	Dscp pulumi.IntPtrInput
	// Matches packets which destination is equal to specified IP or falls into specified IP range.
	DstAddress pulumi.StringPtrInput
	// Matches destination address of a packet against user-defined address list.
	DstAddressList pulumi.StringPtrInput
	// Matches destination address type.
	DstAddressType pulumi.StringPtrInput
	// Matches packets until a given rate is exceeded.
	DstLimit pulumi.StringPtrInput
	// List of destination port numbers or port number ranges.
	DstPort pulumi.StringPtrInput
	// Configuration item created by software, not by management interface. It is not exported, and cannot be directly
	// modified.
	Dynamic pulumi.BoolPtrInput
	// Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
	// fragments as system automatically assembles every packet
	Fragment pulumi.BoolPtrInput
	// Matches packets received from HotSpot clients against various HotSpot matchers.
	Hotspot pulumi.StringPtrInput
	// Matches ICMP type: code fields.
	IcmpOptions pulumi.StringPtrInput
	// Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
	// is enabled in bridge settings.
	InBridgePort pulumi.StringPtrInput
	// Set of interfaces defined in interface list. Works the same as in-bridge-port.
	InBridgePortList pulumi.StringPtrInput
	// Interface the packet has entered the router.
	InInterface pulumi.StringPtrInput
	// Set of interfaces defined in interface list. Works the same as in-interface.
	InInterfaceList pulumi.StringPtrInput
	// Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
	IngressPriority pulumi.IntPtrInput
	Invalid         pulumi.BoolPtrInput
	// Matches the policy used by IPsec. Value is written in the following format: direction, policy.
	IpsecPolicy pulumi.StringPtrInput
	// Matches IPv4 header options.
	Ipv4Options pulumi.StringPtrInput
	// Name of the target chain to jump to. Applicable only if action=jump.
	JumpTarget pulumi.StringPtrInput
	// Layer7 filter name.
	Layer7Protocol pulumi.StringPtrInput
	// Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
	// reached. Parameters are written in the following format: rate[/time],burst:mode.
	Limit pulumi.StringPtrInput
	// Add a message to the system log.
	Log pulumi.BoolPtrInput
	// Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
	LogPrefix pulumi.StringPtrInput
	// Sets a new connection-mark value.
	NewConnectionMark pulumi.StringPtrInput
	// Sets a new DSCP value for a packet.
	NewDscp pulumi.IntPtrInput
	// Sets a new MSS for a packet. > clamp-to-pmtu feature sets (DF) bit in the IP header to dynamically discover the PMTU of
	// a path. > Host sends all datagrams on that path with the DF bit set until receives ICMP. > Destination Unreachable
	// messages with a code meaning "fragmentation needed and DF set". > Upon receipt of such a message, the source host
	// reduces its assumed PMTU for the path.
	NewMss pulumi.StringPtrInput
	// Sets a new packet-mark value.
	NewPacketMark pulumi.StringPtrInput
	// Sets a new priority for a packet. This can be the VLAN, WMM, DSCP or MPLS EXP priority. This property can also be used
	// to set an internal priority.
	NewPriority pulumi.StringPtrInput
	// Sets a new routing-mark value.
	NewRoutingMark pulumi.StringPtrInput
	// Sets a new TTL for a packet.
	NewTtl pulumi.StringPtrInput
	// Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
	// by the rule
	Nth pulumi.StringPtrInput
	// Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
	// is enabled in bridge settings.
	OutBridgePort pulumi.StringPtrInput
	// Set of interfaces defined in interface list. Works the same as out-bridge-port.
	OutBridgePortList pulumi.StringPtrInput
	// Interface the packet is leaving the router.
	OutInterface pulumi.StringPtrInput
	// Set of interfaces defined in interface list. Works the same as out-interface.
	OutInterfaceList pulumi.StringPtrInput
	// Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
	// unmarked packet.
	PacketMark pulumi.StringPtrInput
	// Matches packets of specified size or size range in bytes.
	PacketSize pulumi.StringPtrInput
	// The total amount of packets matched by the rule.
	Packets pulumi.IntPtrInput
	// Whether to let the packet to pass further (like action passthrough) into the firewall or not (property only valid some
	// actions).
	Passthrough pulumi.BoolPtrInput
	// PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
	// in one particular stream.
	PerConnectionClassifier pulumi.StringPtrInput
	// Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
	// think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
	PlaceBefore pulumi.StringPtrInput
	// Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
	// protocol is TCP or UDP
	Port pulumi.StringPtrInput
	// Matches particular IP protocol specified by protocol name or number.
	Protocol pulumi.StringPtrInput
	// Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
	// LowPortWeight, HighPortWeight.
	Psd pulumi.StringPtrInput
	// Matches packets randomly with a given probability.
	Random pulumi.IntPtrInput
	// Matches packets with a specific gateway.
	RouteDst pulumi.StringPtrInput
	// Matches packets marked by mangle facility with particular routing mark.
	RoutingMark pulumi.StringPtrInput
	// Matches packets which source is equal to specified IP or falls into a specified IP range.
	SrcAddress pulumi.StringPtrInput
	// Matches source address of a packet against user-defined address list.
	SrcAddressList pulumi.StringPtrInput
	// Matches source address type.
	SrcAddressType pulumi.StringPtrInput
	// Matches source MAC address of the packet.
	SrcMacAddress pulumi.StringPtrInput
	// List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
	SrcPort pulumi.StringPtrInput
	// Matches specified TCP flags.
	TcpFlags pulumi.StringPtrInput
	// Matches TCP MSS value of an IP packet.
	TcpMss pulumi.StringPtrInput
	// Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
	// and date.
	Time pulumi.StringPtrInput
	// Allows matching HTTPS traffic based on TLS SNI hostname.
	TlsHost pulumi.StringPtrInput
	// Matches packets TTL value.
	Ttl pulumi.StringPtrInput
}

func (IpFirewallMangleState) ElementType() reflect.Type {
	return reflect.TypeOf((*ipFirewallMangleState)(nil)).Elem()
}

type ipFirewallMangleArgs struct {
	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ *int `pulumi:"___id_"`
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ *string `pulumi:"___path_"`
	// Action to take if a packet is matched by the rule.
	Action string `pulumi:"action"`
	// Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.
	AddressList *string `pulumi:"addressList"`
	// Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
	// conjunction with add-dst-to-address-list or add-src-to-address-list actions.
	AddressListTimeout *string `pulumi:"addressListTimeout"`
	// Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
	// chain will be created.
	Chain   string  `pulumi:"chain"`
	Comment *string `pulumi:"comment"`
	// Matches packets only if a given amount of bytes has been transfered through the particular connection.
	ConnectionBytes *string `pulumi:"connectionBytes"`
	// Matches connections per address or address block after given value is reached. Should be used together with
	// connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
	ConnectionLimit *string `pulumi:"connectionLimit"`
	// Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
	// unmarked connection.
	ConnectionMark *string `pulumi:"connectionMark"`
	// Can match connections that are srcnatted, dstnatted or both.
	ConnectionNatState *string `pulumi:"connectionNatState"`
	// Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
	// (0..4294967295).
	ConnectionRate *string `pulumi:"connectionRate"`
	// Interprets the connection tracking analysis data for a particular packet.
	ConnectionState *string `pulumi:"connectionState"`
	// Matches packets from related connections based on information from their connection tracking helpers.
	ConnectionType *string `pulumi:"connectionType"`
	// Match packets that contain specified text.
	Content  *string `pulumi:"content"`
	Disabled *bool   `pulumi:"disabled"`
	// Matches DSCP IP header field.
	Dscp *int `pulumi:"dscp"`
	// Matches packets which destination is equal to specified IP or falls into specified IP range.
	DstAddress *string `pulumi:"dstAddress"`
	// Matches destination address of a packet against user-defined address list.
	DstAddressList *string `pulumi:"dstAddressList"`
	// Matches destination address type.
	DstAddressType *string `pulumi:"dstAddressType"`
	// Matches packets until a given rate is exceeded.
	DstLimit *string `pulumi:"dstLimit"`
	// List of destination port numbers or port number ranges.
	DstPort *string `pulumi:"dstPort"`
	// Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
	// fragments as system automatically assembles every packet
	Fragment *bool `pulumi:"fragment"`
	// Matches packets received from HotSpot clients against various HotSpot matchers.
	Hotspot *string `pulumi:"hotspot"`
	// Matches ICMP type: code fields.
	IcmpOptions *string `pulumi:"icmpOptions"`
	// Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
	// is enabled in bridge settings.
	InBridgePort *string `pulumi:"inBridgePort"`
	// Set of interfaces defined in interface list. Works the same as in-bridge-port.
	InBridgePortList *string `pulumi:"inBridgePortList"`
	// Interface the packet has entered the router.
	InInterface *string `pulumi:"inInterface"`
	// Set of interfaces defined in interface list. Works the same as in-interface.
	InInterfaceList *string `pulumi:"inInterfaceList"`
	// Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
	IngressPriority *int `pulumi:"ingressPriority"`
	// Matches the policy used by IPsec. Value is written in the following format: direction, policy.
	IpsecPolicy *string `pulumi:"ipsecPolicy"`
	// Matches IPv4 header options.
	Ipv4Options *string `pulumi:"ipv4Options"`
	// Name of the target chain to jump to. Applicable only if action=jump.
	JumpTarget *string `pulumi:"jumpTarget"`
	// Layer7 filter name.
	Layer7Protocol *string `pulumi:"layer7Protocol"`
	// Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
	// reached. Parameters are written in the following format: rate[/time],burst:mode.
	Limit *string `pulumi:"limit"`
	// Add a message to the system log.
	Log *bool `pulumi:"log"`
	// Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
	LogPrefix *string `pulumi:"logPrefix"`
	// Sets a new connection-mark value.
	NewConnectionMark *string `pulumi:"newConnectionMark"`
	// Sets a new DSCP value for a packet.
	NewDscp *int `pulumi:"newDscp"`
	// Sets a new MSS for a packet. > clamp-to-pmtu feature sets (DF) bit in the IP header to dynamically discover the PMTU of
	// a path. > Host sends all datagrams on that path with the DF bit set until receives ICMP. > Destination Unreachable
	// messages with a code meaning "fragmentation needed and DF set". > Upon receipt of such a message, the source host
	// reduces its assumed PMTU for the path.
	NewMss *string `pulumi:"newMss"`
	// Sets a new packet-mark value.
	NewPacketMark *string `pulumi:"newPacketMark"`
	// Sets a new priority for a packet. This can be the VLAN, WMM, DSCP or MPLS EXP priority. This property can also be used
	// to set an internal priority.
	NewPriority *string `pulumi:"newPriority"`
	// Sets a new routing-mark value.
	NewRoutingMark *string `pulumi:"newRoutingMark"`
	// Sets a new TTL for a packet.
	NewTtl *string `pulumi:"newTtl"`
	// Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
	// by the rule
	Nth *string `pulumi:"nth"`
	// Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
	// is enabled in bridge settings.
	OutBridgePort *string `pulumi:"outBridgePort"`
	// Set of interfaces defined in interface list. Works the same as out-bridge-port.
	OutBridgePortList *string `pulumi:"outBridgePortList"`
	// Interface the packet is leaving the router.
	OutInterface *string `pulumi:"outInterface"`
	// Set of interfaces defined in interface list. Works the same as out-interface.
	OutInterfaceList *string `pulumi:"outInterfaceList"`
	// Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
	// unmarked packet.
	PacketMark *string `pulumi:"packetMark"`
	// Matches packets of specified size or size range in bytes.
	PacketSize *string `pulumi:"packetSize"`
	// Whether to let the packet to pass further (like action passthrough) into the firewall or not (property only valid some
	// actions).
	Passthrough *bool `pulumi:"passthrough"`
	// PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
	// in one particular stream.
	PerConnectionClassifier *string `pulumi:"perConnectionClassifier"`
	// Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
	// think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
	PlaceBefore *string `pulumi:"placeBefore"`
	// Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
	// protocol is TCP or UDP
	Port *string `pulumi:"port"`
	// Matches particular IP protocol specified by protocol name or number.
	Protocol *string `pulumi:"protocol"`
	// Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
	// LowPortWeight, HighPortWeight.
	Psd *string `pulumi:"psd"`
	// Matches packets randomly with a given probability.
	Random *int `pulumi:"random"`
	// Matches packets with a specific gateway.
	RouteDst *string `pulumi:"routeDst"`
	// Matches packets marked by mangle facility with particular routing mark.
	RoutingMark *string `pulumi:"routingMark"`
	// Matches packets which source is equal to specified IP or falls into a specified IP range.
	SrcAddress *string `pulumi:"srcAddress"`
	// Matches source address of a packet against user-defined address list.
	SrcAddressList *string `pulumi:"srcAddressList"`
	// Matches source address type.
	SrcAddressType *string `pulumi:"srcAddressType"`
	// Matches source MAC address of the packet.
	SrcMacAddress *string `pulumi:"srcMacAddress"`
	// List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
	SrcPort *string `pulumi:"srcPort"`
	// Matches specified TCP flags.
	TcpFlags *string `pulumi:"tcpFlags"`
	// Matches TCP MSS value of an IP packet.
	TcpMss *string `pulumi:"tcpMss"`
	// Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
	// and date.
	Time *string `pulumi:"time"`
	// Allows matching HTTPS traffic based on TLS SNI hostname.
	TlsHost *string `pulumi:"tlsHost"`
	// Matches packets TTL value.
	Ttl *string `pulumi:"ttl"`
}

// The set of arguments for constructing a IpFirewallMangle resource.
type IpFirewallMangleArgs struct {
	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ pulumi.IntPtrInput
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ pulumi.StringPtrInput
	// Action to take if a packet is matched by the rule.
	Action pulumi.StringInput
	// Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.
	AddressList pulumi.StringPtrInput
	// Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
	// conjunction with add-dst-to-address-list or add-src-to-address-list actions.
	AddressListTimeout pulumi.StringPtrInput
	// Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
	// chain will be created.
	Chain   pulumi.StringInput
	Comment pulumi.StringPtrInput
	// Matches packets only if a given amount of bytes has been transfered through the particular connection.
	ConnectionBytes pulumi.StringPtrInput
	// Matches connections per address or address block after given value is reached. Should be used together with
	// connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
	ConnectionLimit pulumi.StringPtrInput
	// Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
	// unmarked connection.
	ConnectionMark pulumi.StringPtrInput
	// Can match connections that are srcnatted, dstnatted or both.
	ConnectionNatState pulumi.StringPtrInput
	// Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
	// (0..4294967295).
	ConnectionRate pulumi.StringPtrInput
	// Interprets the connection tracking analysis data for a particular packet.
	ConnectionState pulumi.StringPtrInput
	// Matches packets from related connections based on information from their connection tracking helpers.
	ConnectionType pulumi.StringPtrInput
	// Match packets that contain specified text.
	Content  pulumi.StringPtrInput
	Disabled pulumi.BoolPtrInput
	// Matches DSCP IP header field.
	Dscp pulumi.IntPtrInput
	// Matches packets which destination is equal to specified IP or falls into specified IP range.
	DstAddress pulumi.StringPtrInput
	// Matches destination address of a packet against user-defined address list.
	DstAddressList pulumi.StringPtrInput
	// Matches destination address type.
	DstAddressType pulumi.StringPtrInput
	// Matches packets until a given rate is exceeded.
	DstLimit pulumi.StringPtrInput
	// List of destination port numbers or port number ranges.
	DstPort pulumi.StringPtrInput
	// Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
	// fragments as system automatically assembles every packet
	Fragment pulumi.BoolPtrInput
	// Matches packets received from HotSpot clients against various HotSpot matchers.
	Hotspot pulumi.StringPtrInput
	// Matches ICMP type: code fields.
	IcmpOptions pulumi.StringPtrInput
	// Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
	// is enabled in bridge settings.
	InBridgePort pulumi.StringPtrInput
	// Set of interfaces defined in interface list. Works the same as in-bridge-port.
	InBridgePortList pulumi.StringPtrInput
	// Interface the packet has entered the router.
	InInterface pulumi.StringPtrInput
	// Set of interfaces defined in interface list. Works the same as in-interface.
	InInterfaceList pulumi.StringPtrInput
	// Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
	IngressPriority pulumi.IntPtrInput
	// Matches the policy used by IPsec. Value is written in the following format: direction, policy.
	IpsecPolicy pulumi.StringPtrInput
	// Matches IPv4 header options.
	Ipv4Options pulumi.StringPtrInput
	// Name of the target chain to jump to. Applicable only if action=jump.
	JumpTarget pulumi.StringPtrInput
	// Layer7 filter name.
	Layer7Protocol pulumi.StringPtrInput
	// Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
	// reached. Parameters are written in the following format: rate[/time],burst:mode.
	Limit pulumi.StringPtrInput
	// Add a message to the system log.
	Log pulumi.BoolPtrInput
	// Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
	LogPrefix pulumi.StringPtrInput
	// Sets a new connection-mark value.
	NewConnectionMark pulumi.StringPtrInput
	// Sets a new DSCP value for a packet.
	NewDscp pulumi.IntPtrInput
	// Sets a new MSS for a packet. > clamp-to-pmtu feature sets (DF) bit in the IP header to dynamically discover the PMTU of
	// a path. > Host sends all datagrams on that path with the DF bit set until receives ICMP. > Destination Unreachable
	// messages with a code meaning "fragmentation needed and DF set". > Upon receipt of such a message, the source host
	// reduces its assumed PMTU for the path.
	NewMss pulumi.StringPtrInput
	// Sets a new packet-mark value.
	NewPacketMark pulumi.StringPtrInput
	// Sets a new priority for a packet. This can be the VLAN, WMM, DSCP or MPLS EXP priority. This property can also be used
	// to set an internal priority.
	NewPriority pulumi.StringPtrInput
	// Sets a new routing-mark value.
	NewRoutingMark pulumi.StringPtrInput
	// Sets a new TTL for a packet.
	NewTtl pulumi.StringPtrInput
	// Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
	// by the rule
	Nth pulumi.StringPtrInput
	// Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
	// is enabled in bridge settings.
	OutBridgePort pulumi.StringPtrInput
	// Set of interfaces defined in interface list. Works the same as out-bridge-port.
	OutBridgePortList pulumi.StringPtrInput
	// Interface the packet is leaving the router.
	OutInterface pulumi.StringPtrInput
	// Set of interfaces defined in interface list. Works the same as out-interface.
	OutInterfaceList pulumi.StringPtrInput
	// Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
	// unmarked packet.
	PacketMark pulumi.StringPtrInput
	// Matches packets of specified size or size range in bytes.
	PacketSize pulumi.StringPtrInput
	// Whether to let the packet to pass further (like action passthrough) into the firewall or not (property only valid some
	// actions).
	Passthrough pulumi.BoolPtrInput
	// PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
	// in one particular stream.
	PerConnectionClassifier pulumi.StringPtrInput
	// Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
	// think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
	PlaceBefore pulumi.StringPtrInput
	// Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
	// protocol is TCP or UDP
	Port pulumi.StringPtrInput
	// Matches particular IP protocol specified by protocol name or number.
	Protocol pulumi.StringPtrInput
	// Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
	// LowPortWeight, HighPortWeight.
	Psd pulumi.StringPtrInput
	// Matches packets randomly with a given probability.
	Random pulumi.IntPtrInput
	// Matches packets with a specific gateway.
	RouteDst pulumi.StringPtrInput
	// Matches packets marked by mangle facility with particular routing mark.
	RoutingMark pulumi.StringPtrInput
	// Matches packets which source is equal to specified IP or falls into a specified IP range.
	SrcAddress pulumi.StringPtrInput
	// Matches source address of a packet against user-defined address list.
	SrcAddressList pulumi.StringPtrInput
	// Matches source address type.
	SrcAddressType pulumi.StringPtrInput
	// Matches source MAC address of the packet.
	SrcMacAddress pulumi.StringPtrInput
	// List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
	SrcPort pulumi.StringPtrInput
	// Matches specified TCP flags.
	TcpFlags pulumi.StringPtrInput
	// Matches TCP MSS value of an IP packet.
	TcpMss pulumi.StringPtrInput
	// Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
	// and date.
	Time pulumi.StringPtrInput
	// Allows matching HTTPS traffic based on TLS SNI hostname.
	TlsHost pulumi.StringPtrInput
	// Matches packets TTL value.
	Ttl pulumi.StringPtrInput
}

func (IpFirewallMangleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*ipFirewallMangleArgs)(nil)).Elem()
}

type IpFirewallMangleInput interface {
	pulumi.Input

	ToIpFirewallMangleOutput() IpFirewallMangleOutput
	ToIpFirewallMangleOutputWithContext(ctx context.Context) IpFirewallMangleOutput
}

func (*IpFirewallMangle) ElementType() reflect.Type {
	return reflect.TypeOf((**IpFirewallMangle)(nil)).Elem()
}

func (i *IpFirewallMangle) ToIpFirewallMangleOutput() IpFirewallMangleOutput {
	return i.ToIpFirewallMangleOutputWithContext(context.Background())
}

func (i *IpFirewallMangle) ToIpFirewallMangleOutputWithContext(ctx context.Context) IpFirewallMangleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpFirewallMangleOutput)
}

// IpFirewallMangleArrayInput is an input type that accepts IpFirewallMangleArray and IpFirewallMangleArrayOutput values.
// You can construct a concrete instance of `IpFirewallMangleArrayInput` via:
//
//	IpFirewallMangleArray{ IpFirewallMangleArgs{...} }
type IpFirewallMangleArrayInput interface {
	pulumi.Input

	ToIpFirewallMangleArrayOutput() IpFirewallMangleArrayOutput
	ToIpFirewallMangleArrayOutputWithContext(context.Context) IpFirewallMangleArrayOutput
}

type IpFirewallMangleArray []IpFirewallMangleInput

func (IpFirewallMangleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IpFirewallMangle)(nil)).Elem()
}

func (i IpFirewallMangleArray) ToIpFirewallMangleArrayOutput() IpFirewallMangleArrayOutput {
	return i.ToIpFirewallMangleArrayOutputWithContext(context.Background())
}

func (i IpFirewallMangleArray) ToIpFirewallMangleArrayOutputWithContext(ctx context.Context) IpFirewallMangleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpFirewallMangleArrayOutput)
}

// IpFirewallMangleMapInput is an input type that accepts IpFirewallMangleMap and IpFirewallMangleMapOutput values.
// You can construct a concrete instance of `IpFirewallMangleMapInput` via:
//
//	IpFirewallMangleMap{ "key": IpFirewallMangleArgs{...} }
type IpFirewallMangleMapInput interface {
	pulumi.Input

	ToIpFirewallMangleMapOutput() IpFirewallMangleMapOutput
	ToIpFirewallMangleMapOutputWithContext(context.Context) IpFirewallMangleMapOutput
}

type IpFirewallMangleMap map[string]IpFirewallMangleInput

func (IpFirewallMangleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IpFirewallMangle)(nil)).Elem()
}

func (i IpFirewallMangleMap) ToIpFirewallMangleMapOutput() IpFirewallMangleMapOutput {
	return i.ToIpFirewallMangleMapOutputWithContext(context.Background())
}

func (i IpFirewallMangleMap) ToIpFirewallMangleMapOutputWithContext(ctx context.Context) IpFirewallMangleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IpFirewallMangleMapOutput)
}

type IpFirewallMangleOutput struct{ *pulumi.OutputState }

func (IpFirewallMangleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IpFirewallMangle)(nil)).Elem()
}

func (o IpFirewallMangleOutput) ToIpFirewallMangleOutput() IpFirewallMangleOutput {
	return o
}

func (o IpFirewallMangleOutput) ToIpFirewallMangleOutputWithContext(ctx context.Context) IpFirewallMangleOutput {
	return o
}

// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
func (o IpFirewallMangleOutput) ___id_() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.IntPtrOutput { return v.___id_ }).(pulumi.IntPtrOutput)
}

// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
func (o IpFirewallMangleOutput) ___path_() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.___path_ }).(pulumi.StringPtrOutput)
}

// Action to take if a packet is matched by the rule.
func (o IpFirewallMangleOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringOutput { return v.Action }).(pulumi.StringOutput)
}

// Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.
func (o IpFirewallMangleOutput) AddressList() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.AddressList }).(pulumi.StringPtrOutput)
}

// Time interval after which the address will be removed from the address list specified by address-list parameter. Used in
// conjunction with add-dst-to-address-list or add-src-to-address-list actions.
func (o IpFirewallMangleOutput) AddressListTimeout() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.AddressListTimeout }).(pulumi.StringPtrOutput)
}

// The total amount of bytes matched by the rule.
func (o IpFirewallMangleOutput) Bytes() pulumi.IntOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.IntOutput { return v.Bytes }).(pulumi.IntOutput)
}

// Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new
// chain will be created.
func (o IpFirewallMangleOutput) Chain() pulumi.StringOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringOutput { return v.Chain }).(pulumi.StringOutput)
}

func (o IpFirewallMangleOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

// Matches packets only if a given amount of bytes has been transfered through the particular connection.
func (o IpFirewallMangleOutput) ConnectionBytes() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.ConnectionBytes }).(pulumi.StringPtrOutput)
}

// Matches connections per address or address block after given value is reached. Should be used together with
// connection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.
func (o IpFirewallMangleOutput) ConnectionLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.ConnectionLimit }).(pulumi.StringPtrOutput)
}

// Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any
// unmarked connection.
func (o IpFirewallMangleOutput) ConnectionMark() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.ConnectionMark }).(pulumi.StringPtrOutput)
}

// Can match connections that are srcnatted, dstnatted or both.
func (o IpFirewallMangleOutput) ConnectionNatState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.ConnectionNatState }).(pulumi.StringPtrOutput)
}

// Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection
// (0..4294967295).
func (o IpFirewallMangleOutput) ConnectionRate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.ConnectionRate }).(pulumi.StringPtrOutput)
}

// Interprets the connection tracking analysis data for a particular packet.
func (o IpFirewallMangleOutput) ConnectionState() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.ConnectionState }).(pulumi.StringPtrOutput)
}

// Matches packets from related connections based on information from their connection tracking helpers.
func (o IpFirewallMangleOutput) ConnectionType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.ConnectionType }).(pulumi.StringPtrOutput)
}

// Match packets that contain specified text.
func (o IpFirewallMangleOutput) Content() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.Content }).(pulumi.StringPtrOutput)
}

func (o IpFirewallMangleOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.BoolPtrOutput { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// Matches DSCP IP header field.
func (o IpFirewallMangleOutput) Dscp() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.IntPtrOutput { return v.Dscp }).(pulumi.IntPtrOutput)
}

// Matches packets which destination is equal to specified IP or falls into specified IP range.
func (o IpFirewallMangleOutput) DstAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.DstAddress }).(pulumi.StringPtrOutput)
}

// Matches destination address of a packet against user-defined address list.
func (o IpFirewallMangleOutput) DstAddressList() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.DstAddressList }).(pulumi.StringPtrOutput)
}

// Matches destination address type.
func (o IpFirewallMangleOutput) DstAddressType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.DstAddressType }).(pulumi.StringPtrOutput)
}

// Matches packets until a given rate is exceeded.
func (o IpFirewallMangleOutput) DstLimit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.DstLimit }).(pulumi.StringPtrOutput)
}

// List of destination port numbers or port number ranges.
func (o IpFirewallMangleOutput) DstPort() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.DstPort }).(pulumi.StringPtrOutput)
}

// Configuration item created by software, not by management interface. It is not exported, and cannot be directly
// modified.
func (o IpFirewallMangleOutput) Dynamic() pulumi.BoolOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.BoolOutput { return v.Dynamic }).(pulumi.BoolOutput)
}

// Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no
// fragments as system automatically assembles every packet
func (o IpFirewallMangleOutput) Fragment() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.BoolPtrOutput { return v.Fragment }).(pulumi.BoolPtrOutput)
}

// Matches packets received from HotSpot clients against various HotSpot matchers.
func (o IpFirewallMangleOutput) Hotspot() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.Hotspot }).(pulumi.StringPtrOutput)
}

// Matches ICMP type: code fields.
func (o IpFirewallMangleOutput) IcmpOptions() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.IcmpOptions }).(pulumi.StringPtrOutput)
}

// Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall
// is enabled in bridge settings.
func (o IpFirewallMangleOutput) InBridgePort() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.InBridgePort }).(pulumi.StringPtrOutput)
}

// Set of interfaces defined in interface list. Works the same as in-bridge-port.
func (o IpFirewallMangleOutput) InBridgePortList() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.InBridgePortList }).(pulumi.StringPtrOutput)
}

// Interface the packet has entered the router.
func (o IpFirewallMangleOutput) InInterface() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.InInterface }).(pulumi.StringPtrOutput)
}

// Set of interfaces defined in interface list. Works the same as in-interface.
func (o IpFirewallMangleOutput) InInterfaceList() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.InInterfaceList }).(pulumi.StringPtrOutput)
}

// Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.
func (o IpFirewallMangleOutput) IngressPriority() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.IntPtrOutput { return v.IngressPriority }).(pulumi.IntPtrOutput)
}

func (o IpFirewallMangleOutput) Invalid() pulumi.BoolOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.BoolOutput { return v.Invalid }).(pulumi.BoolOutput)
}

// Matches the policy used by IPsec. Value is written in the following format: direction, policy.
func (o IpFirewallMangleOutput) IpsecPolicy() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.IpsecPolicy }).(pulumi.StringPtrOutput)
}

// Matches IPv4 header options.
func (o IpFirewallMangleOutput) Ipv4Options() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.Ipv4Options }).(pulumi.StringPtrOutput)
}

// Name of the target chain to jump to. Applicable only if action=jump.
func (o IpFirewallMangleOutput) JumpTarget() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.JumpTarget }).(pulumi.StringPtrOutput)
}

// Layer7 filter name.
func (o IpFirewallMangleOutput) Layer7Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.Layer7Protocol }).(pulumi.StringPtrOutput)
}

// Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is
// reached. Parameters are written in the following format: rate[/time],burst:mode.
func (o IpFirewallMangleOutput) Limit() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.Limit }).(pulumi.StringPtrOutput)
}

// Add a message to the system log.
func (o IpFirewallMangleOutput) Log() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.BoolPtrOutput { return v.Log }).(pulumi.BoolPtrOutput)
}

// Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.
func (o IpFirewallMangleOutput) LogPrefix() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.LogPrefix }).(pulumi.StringPtrOutput)
}

// Sets a new connection-mark value.
func (o IpFirewallMangleOutput) NewConnectionMark() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.NewConnectionMark }).(pulumi.StringPtrOutput)
}

// Sets a new DSCP value for a packet.
func (o IpFirewallMangleOutput) NewDscp() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.IntPtrOutput { return v.NewDscp }).(pulumi.IntPtrOutput)
}

// Sets a new MSS for a packet. > clamp-to-pmtu feature sets (DF) bit in the IP header to dynamically discover the PMTU of
// a path. > Host sends all datagrams on that path with the DF bit set until receives ICMP. > Destination Unreachable
// messages with a code meaning "fragmentation needed and DF set". > Upon receipt of such a message, the source host
// reduces its assumed PMTU for the path.
func (o IpFirewallMangleOutput) NewMss() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.NewMss }).(pulumi.StringPtrOutput)
}

// Sets a new packet-mark value.
func (o IpFirewallMangleOutput) NewPacketMark() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.NewPacketMark }).(pulumi.StringPtrOutput)
}

// Sets a new priority for a packet. This can be the VLAN, WMM, DSCP or MPLS EXP priority. This property can also be used
// to set an internal priority.
func (o IpFirewallMangleOutput) NewPriority() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.NewPriority }).(pulumi.StringPtrOutput)
}

// Sets a new routing-mark value.
func (o IpFirewallMangleOutput) NewRoutingMark() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.NewRoutingMark }).(pulumi.StringPtrOutput)
}

// Sets a new TTL for a packet.
func (o IpFirewallMangleOutput) NewTtl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.NewTtl }).(pulumi.StringPtrOutput)
}

// Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched
// by the rule
func (o IpFirewallMangleOutput) Nth() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.Nth }).(pulumi.StringPtrOutput)
}

// Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall
// is enabled in bridge settings.
func (o IpFirewallMangleOutput) OutBridgePort() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.OutBridgePort }).(pulumi.StringPtrOutput)
}

// Set of interfaces defined in interface list. Works the same as out-bridge-port.
func (o IpFirewallMangleOutput) OutBridgePortList() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.OutBridgePortList }).(pulumi.StringPtrOutput)
}

// Interface the packet is leaving the router.
func (o IpFirewallMangleOutput) OutInterface() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.OutInterface }).(pulumi.StringPtrOutput)
}

// Set of interfaces defined in interface list. Works the same as out-interface.
func (o IpFirewallMangleOutput) OutInterfaceList() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.OutInterfaceList }).(pulumi.StringPtrOutput)
}

// Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any
// unmarked packet.
func (o IpFirewallMangleOutput) PacketMark() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.PacketMark }).(pulumi.StringPtrOutput)
}

// Matches packets of specified size or size range in bytes.
func (o IpFirewallMangleOutput) PacketSize() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.PacketSize }).(pulumi.StringPtrOutput)
}

// The total amount of packets matched by the rule.
func (o IpFirewallMangleOutput) Packets() pulumi.IntOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.IntOutput { return v.Packets }).(pulumi.IntOutput)
}

// Whether to let the packet to pass further (like action passthrough) into the firewall or not (property only valid some
// actions).
func (o IpFirewallMangleOutput) Passthrough() pulumi.BoolOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.BoolOutput { return v.Passthrough }).(pulumi.BoolOutput)
}

// PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options
// in one particular stream.
func (o IpFirewallMangleOutput) PerConnectionClassifier() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.PerConnectionClassifier }).(pulumi.StringPtrOutput)
}

// Before which position the rule will be inserted. > Please check the effect of this option, as it does not work as you
// think! > Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).
func (o IpFirewallMangleOutput) PlaceBefore() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.PlaceBefore }).(pulumi.StringPtrOutput)
}

// Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if
// protocol is TCP or UDP
func (o IpFirewallMangleOutput) Port() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.Port }).(pulumi.StringPtrOutput)
}

// Matches particular IP protocol specified by protocol name or number.
func (o IpFirewallMangleOutput) Protocol() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.Protocol }).(pulumi.StringPtrOutput)
}

// Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,
// LowPortWeight, HighPortWeight.
func (o IpFirewallMangleOutput) Psd() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.Psd }).(pulumi.StringPtrOutput)
}

// Matches packets randomly with a given probability.
func (o IpFirewallMangleOutput) Random() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.IntPtrOutput { return v.Random }).(pulumi.IntPtrOutput)
}

// Matches packets with a specific gateway.
func (o IpFirewallMangleOutput) RouteDst() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.RouteDst }).(pulumi.StringPtrOutput)
}

// Matches packets marked by mangle facility with particular routing mark.
func (o IpFirewallMangleOutput) RoutingMark() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.RoutingMark }).(pulumi.StringPtrOutput)
}

// Matches packets which source is equal to specified IP or falls into a specified IP range.
func (o IpFirewallMangleOutput) SrcAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.SrcAddress }).(pulumi.StringPtrOutput)
}

// Matches source address of a packet against user-defined address list.
func (o IpFirewallMangleOutput) SrcAddressList() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.SrcAddressList }).(pulumi.StringPtrOutput)
}

// Matches source address type.
func (o IpFirewallMangleOutput) SrcAddressType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.SrcAddressType }).(pulumi.StringPtrOutput)
}

// Matches source MAC address of the packet.
func (o IpFirewallMangleOutput) SrcMacAddress() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.SrcMacAddress }).(pulumi.StringPtrOutput)
}

// List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.
func (o IpFirewallMangleOutput) SrcPort() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.SrcPort }).(pulumi.StringPtrOutput)
}

// Matches specified TCP flags.
func (o IpFirewallMangleOutput) TcpFlags() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.TcpFlags }).(pulumi.StringPtrOutput)
}

// Matches TCP MSS value of an IP packet.
func (o IpFirewallMangleOutput) TcpMss() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.TcpMss }).(pulumi.StringPtrOutput)
}

// Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time
// and date.
func (o IpFirewallMangleOutput) Time() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.Time }).(pulumi.StringPtrOutput)
}

// Allows matching HTTPS traffic based on TLS SNI hostname.
func (o IpFirewallMangleOutput) TlsHost() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.TlsHost }).(pulumi.StringPtrOutput)
}

// Matches packets TTL value.
func (o IpFirewallMangleOutput) Ttl() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IpFirewallMangle) pulumi.StringPtrOutput { return v.Ttl }).(pulumi.StringPtrOutput)
}

type IpFirewallMangleArrayOutput struct{ *pulumi.OutputState }

func (IpFirewallMangleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IpFirewallMangle)(nil)).Elem()
}

func (o IpFirewallMangleArrayOutput) ToIpFirewallMangleArrayOutput() IpFirewallMangleArrayOutput {
	return o
}

func (o IpFirewallMangleArrayOutput) ToIpFirewallMangleArrayOutputWithContext(ctx context.Context) IpFirewallMangleArrayOutput {
	return o
}

func (o IpFirewallMangleArrayOutput) Index(i pulumi.IntInput) IpFirewallMangleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *IpFirewallMangle {
		return vs[0].([]*IpFirewallMangle)[vs[1].(int)]
	}).(IpFirewallMangleOutput)
}

type IpFirewallMangleMapOutput struct{ *pulumi.OutputState }

func (IpFirewallMangleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IpFirewallMangle)(nil)).Elem()
}

func (o IpFirewallMangleMapOutput) ToIpFirewallMangleMapOutput() IpFirewallMangleMapOutput {
	return o
}

func (o IpFirewallMangleMapOutput) ToIpFirewallMangleMapOutputWithContext(ctx context.Context) IpFirewallMangleMapOutput {
	return o
}

func (o IpFirewallMangleMapOutput) MapIndex(k pulumi.StringInput) IpFirewallMangleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *IpFirewallMangle {
		return vs[0].(map[string]*IpFirewallMangle)[vs[1].(string)]
	}).(IpFirewallMangleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IpFirewallMangleInput)(nil)).Elem(), &IpFirewallMangle{})
	pulumi.RegisterInputType(reflect.TypeOf((*IpFirewallMangleArrayInput)(nil)).Elem(), IpFirewallMangleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IpFirewallMangleMapInput)(nil)).Elem(), IpFirewallMangleMap{})
	pulumi.RegisterOutputType(IpFirewallMangleOutput{})
	pulumi.RegisterOutputType(IpFirewallMangleArrayOutput{})
	pulumi.RegisterOutputType(IpFirewallMangleMapOutput{})
}
