// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package routeros

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-routeros/sdk/go/routeros"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			testWgInterface, err := routeros.NewResourceInterfaceWireguard(ctx, "testWgInterface", &routeros.ResourceInterfaceWireguardArgs{
//				ListenPort: pulumi.Int(13231),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = routeros.NewResourceInterfaceWireguardPeer(ctx, "wgPeer", &routeros.ResourceInterfaceWireguardPeerArgs{
//				Interface: testWgInterface.Name,
//				PublicKey: pulumi.String("MY_BASE_64_PUBLIC_KEY"),
//				AllowedAddresses: pulumi.StringArray{
//					pulumi.String("192.168.0.0/16"),
//					pulumi.String("172.16.0.0/12"),
//					pulumi.String("10.0.0.0/8"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// #The ID can be found via API or the terminal #The command for the terminal is -> :put [/interface/wireguard/peers get [print show-ids]]
//
// ```sh
//
//	$ pulumi import routeros:index/resourceInterfaceWireguardPeer:ResourceInterfaceWireguardPeer wg_peer "*0"
//
// ```
type ResourceInterfaceWireguardPeer struct {
	pulumi.CustomResourceState

	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ pulumi.IntPtrOutput `pulumi:"___id_"`
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ pulumi.StringPtrOutput `pulumi:"___path_"`
	// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.
	AllowedAddresses pulumi.StringArrayOutput `pulumi:"allowedAddresses"`
	Comment          pulumi.StringPtrOutput   `pulumi:"comment"`
	// The most recent source IP address of correctly authenticated packets from the peer.
	CurrentEndpointAddress pulumi.StringOutput `pulumi:"currentEndpointAddress"`
	// The most recent source IP port of correctly authenticated packets from the peer.
	CurrentEndpointPort pulumi.IntOutput     `pulumi:"currentEndpointPort"`
	Disabled            pulumi.BoolPtrOutput `pulumi:"disabled"`
	// An endpoint IP or hostname can be left blank to allow remote connection from any address.
	EndpointAddress pulumi.StringOutput `pulumi:"endpointAddress"`
	// An endpoint port can be left blank to allow remote connection from any port.
	EndpointPort pulumi.StringOutput `pulumi:"endpointPort"`
	// Name of the interface.
	Interface pulumi.StringOutput `pulumi:"interface"`
	// Time in seconds after the last successful handshake.
	LastHandshake pulumi.StringOutput `pulumi:"lastHandshake"`
	// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.
	PersistentKeepalive pulumi.StringPtrOutput `pulumi:"persistentKeepalive"`
	// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
	PresharedKey pulumi.StringPtrOutput `pulumi:"presharedKey"`
	// The remote peer's calculated public key.
	PublicKey pulumi.StringOutput `pulumi:"publicKey"`
	// The total amount of bytes received from the peer.
	Rx pulumi.StringOutput `pulumi:"rx"`
	// The total amount of bytes transmitted to the peer.
	Tx pulumi.StringOutput `pulumi:"tx"`
}

// NewResourceInterfaceWireguardPeer registers a new resource with the given unique name, arguments, and options.
func NewResourceInterfaceWireguardPeer(ctx *pulumi.Context,
	name string, args *ResourceInterfaceWireguardPeerArgs, opts ...pulumi.ResourceOption) (*ResourceInterfaceWireguardPeer, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Interface == nil {
		return nil, errors.New("invalid value for required argument 'Interface'")
	}
	if args.PublicKey == nil {
		return nil, errors.New("invalid value for required argument 'PublicKey'")
	}
	if args.PresharedKey != nil {
		args.PresharedKey = pulumi.ToSecret(args.PresharedKey).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"presharedKey",
	})
	opts = append(opts, secrets)
	var resource ResourceInterfaceWireguardPeer
	err := ctx.RegisterResource("routeros:index/resourceInterfaceWireguardPeer:ResourceInterfaceWireguardPeer", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetResourceInterfaceWireguardPeer gets an existing ResourceInterfaceWireguardPeer resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetResourceInterfaceWireguardPeer(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ResourceInterfaceWireguardPeerState, opts ...pulumi.ResourceOption) (*ResourceInterfaceWireguardPeer, error) {
	var resource ResourceInterfaceWireguardPeer
	err := ctx.ReadResource("routeros:index/resourceInterfaceWireguardPeer:ResourceInterfaceWireguardPeer", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ResourceInterfaceWireguardPeer resources.
type resourceInterfaceWireguardPeerState struct {
	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ *int `pulumi:"___id_"`
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ *string `pulumi:"___path_"`
	// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.
	AllowedAddresses []string `pulumi:"allowedAddresses"`
	Comment          *string  `pulumi:"comment"`
	// The most recent source IP address of correctly authenticated packets from the peer.
	CurrentEndpointAddress *string `pulumi:"currentEndpointAddress"`
	// The most recent source IP port of correctly authenticated packets from the peer.
	CurrentEndpointPort *int  `pulumi:"currentEndpointPort"`
	Disabled            *bool `pulumi:"disabled"`
	// An endpoint IP or hostname can be left blank to allow remote connection from any address.
	EndpointAddress *string `pulumi:"endpointAddress"`
	// An endpoint port can be left blank to allow remote connection from any port.
	EndpointPort *string `pulumi:"endpointPort"`
	// Name of the interface.
	Interface *string `pulumi:"interface"`
	// Time in seconds after the last successful handshake.
	LastHandshake *string `pulumi:"lastHandshake"`
	// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.
	PersistentKeepalive *string `pulumi:"persistentKeepalive"`
	// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
	PresharedKey *string `pulumi:"presharedKey"`
	// The remote peer's calculated public key.
	PublicKey *string `pulumi:"publicKey"`
	// The total amount of bytes received from the peer.
	Rx *string `pulumi:"rx"`
	// The total amount of bytes transmitted to the peer.
	Tx *string `pulumi:"tx"`
}

type ResourceInterfaceWireguardPeerState struct {
	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ pulumi.IntPtrInput
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ pulumi.StringPtrInput
	// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.
	AllowedAddresses pulumi.StringArrayInput
	Comment          pulumi.StringPtrInput
	// The most recent source IP address of correctly authenticated packets from the peer.
	CurrentEndpointAddress pulumi.StringPtrInput
	// The most recent source IP port of correctly authenticated packets from the peer.
	CurrentEndpointPort pulumi.IntPtrInput
	Disabled            pulumi.BoolPtrInput
	// An endpoint IP or hostname can be left blank to allow remote connection from any address.
	EndpointAddress pulumi.StringPtrInput
	// An endpoint port can be left blank to allow remote connection from any port.
	EndpointPort pulumi.StringPtrInput
	// Name of the interface.
	Interface pulumi.StringPtrInput
	// Time in seconds after the last successful handshake.
	LastHandshake pulumi.StringPtrInput
	// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.
	PersistentKeepalive pulumi.StringPtrInput
	// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
	PresharedKey pulumi.StringPtrInput
	// The remote peer's calculated public key.
	PublicKey pulumi.StringPtrInput
	// The total amount of bytes received from the peer.
	Rx pulumi.StringPtrInput
	// The total amount of bytes transmitted to the peer.
	Tx pulumi.StringPtrInput
}

func (ResourceInterfaceWireguardPeerState) ElementType() reflect.Type {
	return reflect.TypeOf((*resourceInterfaceWireguardPeerState)(nil)).Elem()
}

type resourceInterfaceWireguardPeerArgs struct {
	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ *int `pulumi:"___id_"`
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ *string `pulumi:"___path_"`
	// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.
	AllowedAddresses []string `pulumi:"allowedAddresses"`
	Comment          *string  `pulumi:"comment"`
	Disabled         *bool    `pulumi:"disabled"`
	// An endpoint IP or hostname can be left blank to allow remote connection from any address.
	EndpointAddress *string `pulumi:"endpointAddress"`
	// An endpoint port can be left blank to allow remote connection from any port.
	EndpointPort *string `pulumi:"endpointPort"`
	// Name of the interface.
	Interface string `pulumi:"interface"`
	// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.
	PersistentKeepalive *string `pulumi:"persistentKeepalive"`
	// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
	PresharedKey *string `pulumi:"presharedKey"`
	// The remote peer's calculated public key.
	PublicKey string `pulumi:"publicKey"`
}

// The set of arguments for constructing a ResourceInterfaceWireguardPeer resource.
type ResourceInterfaceWireguardPeerArgs struct {
	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ pulumi.IntPtrInput
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ pulumi.StringPtrInput
	// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.
	AllowedAddresses pulumi.StringArrayInput
	Comment          pulumi.StringPtrInput
	Disabled         pulumi.BoolPtrInput
	// An endpoint IP or hostname can be left blank to allow remote connection from any address.
	EndpointAddress pulumi.StringPtrInput
	// An endpoint port can be left blank to allow remote connection from any port.
	EndpointPort pulumi.StringPtrInput
	// Name of the interface.
	Interface pulumi.StringInput
	// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.
	PersistentKeepalive pulumi.StringPtrInput
	// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
	PresharedKey pulumi.StringPtrInput
	// The remote peer's calculated public key.
	PublicKey pulumi.StringInput
}

func (ResourceInterfaceWireguardPeerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*resourceInterfaceWireguardPeerArgs)(nil)).Elem()
}

type ResourceInterfaceWireguardPeerInput interface {
	pulumi.Input

	ToResourceInterfaceWireguardPeerOutput() ResourceInterfaceWireguardPeerOutput
	ToResourceInterfaceWireguardPeerOutputWithContext(ctx context.Context) ResourceInterfaceWireguardPeerOutput
}

func (*ResourceInterfaceWireguardPeer) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceInterfaceWireguardPeer)(nil)).Elem()
}

func (i *ResourceInterfaceWireguardPeer) ToResourceInterfaceWireguardPeerOutput() ResourceInterfaceWireguardPeerOutput {
	return i.ToResourceInterfaceWireguardPeerOutputWithContext(context.Background())
}

func (i *ResourceInterfaceWireguardPeer) ToResourceInterfaceWireguardPeerOutputWithContext(ctx context.Context) ResourceInterfaceWireguardPeerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceInterfaceWireguardPeerOutput)
}

// ResourceInterfaceWireguardPeerArrayInput is an input type that accepts ResourceInterfaceWireguardPeerArray and ResourceInterfaceWireguardPeerArrayOutput values.
// You can construct a concrete instance of `ResourceInterfaceWireguardPeerArrayInput` via:
//
//	ResourceInterfaceWireguardPeerArray{ ResourceInterfaceWireguardPeerArgs{...} }
type ResourceInterfaceWireguardPeerArrayInput interface {
	pulumi.Input

	ToResourceInterfaceWireguardPeerArrayOutput() ResourceInterfaceWireguardPeerArrayOutput
	ToResourceInterfaceWireguardPeerArrayOutputWithContext(context.Context) ResourceInterfaceWireguardPeerArrayOutput
}

type ResourceInterfaceWireguardPeerArray []ResourceInterfaceWireguardPeerInput

func (ResourceInterfaceWireguardPeerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ResourceInterfaceWireguardPeer)(nil)).Elem()
}

func (i ResourceInterfaceWireguardPeerArray) ToResourceInterfaceWireguardPeerArrayOutput() ResourceInterfaceWireguardPeerArrayOutput {
	return i.ToResourceInterfaceWireguardPeerArrayOutputWithContext(context.Background())
}

func (i ResourceInterfaceWireguardPeerArray) ToResourceInterfaceWireguardPeerArrayOutputWithContext(ctx context.Context) ResourceInterfaceWireguardPeerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceInterfaceWireguardPeerArrayOutput)
}

// ResourceInterfaceWireguardPeerMapInput is an input type that accepts ResourceInterfaceWireguardPeerMap and ResourceInterfaceWireguardPeerMapOutput values.
// You can construct a concrete instance of `ResourceInterfaceWireguardPeerMapInput` via:
//
//	ResourceInterfaceWireguardPeerMap{ "key": ResourceInterfaceWireguardPeerArgs{...} }
type ResourceInterfaceWireguardPeerMapInput interface {
	pulumi.Input

	ToResourceInterfaceWireguardPeerMapOutput() ResourceInterfaceWireguardPeerMapOutput
	ToResourceInterfaceWireguardPeerMapOutputWithContext(context.Context) ResourceInterfaceWireguardPeerMapOutput
}

type ResourceInterfaceWireguardPeerMap map[string]ResourceInterfaceWireguardPeerInput

func (ResourceInterfaceWireguardPeerMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ResourceInterfaceWireguardPeer)(nil)).Elem()
}

func (i ResourceInterfaceWireguardPeerMap) ToResourceInterfaceWireguardPeerMapOutput() ResourceInterfaceWireguardPeerMapOutput {
	return i.ToResourceInterfaceWireguardPeerMapOutputWithContext(context.Background())
}

func (i ResourceInterfaceWireguardPeerMap) ToResourceInterfaceWireguardPeerMapOutputWithContext(ctx context.Context) ResourceInterfaceWireguardPeerMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ResourceInterfaceWireguardPeerMapOutput)
}

type ResourceInterfaceWireguardPeerOutput struct{ *pulumi.OutputState }

func (ResourceInterfaceWireguardPeerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ResourceInterfaceWireguardPeer)(nil)).Elem()
}

func (o ResourceInterfaceWireguardPeerOutput) ToResourceInterfaceWireguardPeerOutput() ResourceInterfaceWireguardPeerOutput {
	return o
}

func (o ResourceInterfaceWireguardPeerOutput) ToResourceInterfaceWireguardPeerOutputWithContext(ctx context.Context) ResourceInterfaceWireguardPeerOutput {
	return o
}

// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
func (o ResourceInterfaceWireguardPeerOutput) ___id_() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.IntPtrOutput { return v.___id_ }).(pulumi.IntPtrOutput)
}

// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
func (o ResourceInterfaceWireguardPeerOutput) ___path_() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.StringPtrOutput { return v.___path_ }).(pulumi.StringPtrOutput)
}

// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.
func (o ResourceInterfaceWireguardPeerOutput) AllowedAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.StringArrayOutput { return v.AllowedAddresses }).(pulumi.StringArrayOutput)
}

func (o ResourceInterfaceWireguardPeerOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

// The most recent source IP address of correctly authenticated packets from the peer.
func (o ResourceInterfaceWireguardPeerOutput) CurrentEndpointAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.StringOutput { return v.CurrentEndpointAddress }).(pulumi.StringOutput)
}

// The most recent source IP port of correctly authenticated packets from the peer.
func (o ResourceInterfaceWireguardPeerOutput) CurrentEndpointPort() pulumi.IntOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.IntOutput { return v.CurrentEndpointPort }).(pulumi.IntOutput)
}

func (o ResourceInterfaceWireguardPeerOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.BoolPtrOutput { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// An endpoint IP or hostname can be left blank to allow remote connection from any address.
func (o ResourceInterfaceWireguardPeerOutput) EndpointAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.StringOutput { return v.EndpointAddress }).(pulumi.StringOutput)
}

// An endpoint port can be left blank to allow remote connection from any port.
func (o ResourceInterfaceWireguardPeerOutput) EndpointPort() pulumi.StringOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.StringOutput { return v.EndpointPort }).(pulumi.StringOutput)
}

// Name of the interface.
func (o ResourceInterfaceWireguardPeerOutput) Interface() pulumi.StringOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.StringOutput { return v.Interface }).(pulumi.StringOutput)
}

// Time in seconds after the last successful handshake.
func (o ResourceInterfaceWireguardPeerOutput) LastHandshake() pulumi.StringOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.StringOutput { return v.LastHandshake }).(pulumi.StringOutput)
}

// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.
func (o ResourceInterfaceWireguardPeerOutput) PersistentKeepalive() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.StringPtrOutput { return v.PersistentKeepalive }).(pulumi.StringPtrOutput)
}

// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
func (o ResourceInterfaceWireguardPeerOutput) PresharedKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.StringPtrOutput { return v.PresharedKey }).(pulumi.StringPtrOutput)
}

// The remote peer's calculated public key.
func (o ResourceInterfaceWireguardPeerOutput) PublicKey() pulumi.StringOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.StringOutput { return v.PublicKey }).(pulumi.StringOutput)
}

// The total amount of bytes received from the peer.
func (o ResourceInterfaceWireguardPeerOutput) Rx() pulumi.StringOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.StringOutput { return v.Rx }).(pulumi.StringOutput)
}

// The total amount of bytes transmitted to the peer.
func (o ResourceInterfaceWireguardPeerOutput) Tx() pulumi.StringOutput {
	return o.ApplyT(func(v *ResourceInterfaceWireguardPeer) pulumi.StringOutput { return v.Tx }).(pulumi.StringOutput)
}

type ResourceInterfaceWireguardPeerArrayOutput struct{ *pulumi.OutputState }

func (ResourceInterfaceWireguardPeerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ResourceInterfaceWireguardPeer)(nil)).Elem()
}

func (o ResourceInterfaceWireguardPeerArrayOutput) ToResourceInterfaceWireguardPeerArrayOutput() ResourceInterfaceWireguardPeerArrayOutput {
	return o
}

func (o ResourceInterfaceWireguardPeerArrayOutput) ToResourceInterfaceWireguardPeerArrayOutputWithContext(ctx context.Context) ResourceInterfaceWireguardPeerArrayOutput {
	return o
}

func (o ResourceInterfaceWireguardPeerArrayOutput) Index(i pulumi.IntInput) ResourceInterfaceWireguardPeerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ResourceInterfaceWireguardPeer {
		return vs[0].([]*ResourceInterfaceWireguardPeer)[vs[1].(int)]
	}).(ResourceInterfaceWireguardPeerOutput)
}

type ResourceInterfaceWireguardPeerMapOutput struct{ *pulumi.OutputState }

func (ResourceInterfaceWireguardPeerMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ResourceInterfaceWireguardPeer)(nil)).Elem()
}

func (o ResourceInterfaceWireguardPeerMapOutput) ToResourceInterfaceWireguardPeerMapOutput() ResourceInterfaceWireguardPeerMapOutput {
	return o
}

func (o ResourceInterfaceWireguardPeerMapOutput) ToResourceInterfaceWireguardPeerMapOutputWithContext(ctx context.Context) ResourceInterfaceWireguardPeerMapOutput {
	return o
}

func (o ResourceInterfaceWireguardPeerMapOutput) MapIndex(k pulumi.StringInput) ResourceInterfaceWireguardPeerOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ResourceInterfaceWireguardPeer {
		return vs[0].(map[string]*ResourceInterfaceWireguardPeer)[vs[1].(string)]
	}).(ResourceInterfaceWireguardPeerOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceInterfaceWireguardPeerInput)(nil)).Elem(), &ResourceInterfaceWireguardPeer{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceInterfaceWireguardPeerArrayInput)(nil)).Elem(), ResourceInterfaceWireguardPeerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ResourceInterfaceWireguardPeerMapInput)(nil)).Elem(), ResourceInterfaceWireguardPeerMap{})
	pulumi.RegisterOutputType(ResourceInterfaceWireguardPeerOutput{})
	pulumi.RegisterOutputType(ResourceInterfaceWireguardPeerArrayOutput{})
	pulumi.RegisterOutputType(ResourceInterfaceWireguardPeerMapOutput{})
}
