// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package iface

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## # Iface.WireguardPeer (Resource)
//
// ***
//
// #### This is an alias for backwards compatibility between plugin versions.
// Please see documentation for Iface.InterfaceWireguardPeer
type WireguardPeer struct {
	pulumi.CustomResourceState

	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ pulumi.IntPtrOutput `pulumi:"___id_"`
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ pulumi.StringPtrOutput `pulumi:"___path_"`
	// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which
	// outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
	// and ::/0 may be specified for matching all IPv6 addresses.
	AllowedAddresses pulumi.StringArrayOutput `pulumi:"allowedAddresses"`
	Comment          pulumi.StringPtrOutput   `pulumi:"comment"`
	// The most recent source IP address of correctly authenticated packets from the peer.
	CurrentEndpointAddress pulumi.StringOutput `pulumi:"currentEndpointAddress"`
	// The most recent source IP port of correctly authenticated packets from the peer.
	CurrentEndpointPort pulumi.IntOutput     `pulumi:"currentEndpointPort"`
	Disabled            pulumi.BoolPtrOutput `pulumi:"disabled"`
	// An endpoint IP or hostname can be left blank to allow remote connection from any address.
	EndpointAddress pulumi.StringOutput `pulumi:"endpointAddress"`
	// An endpoint port can be left blank to allow remote connection from any port.
	EndpointPort pulumi.StringOutput `pulumi:"endpointPort"`
	// Name of the interface.
	Interface pulumi.StringOutput `pulumi:"interface"`
	// Time in seconds after the last successful handshake.
	LastHandshake pulumi.StringOutput `pulumi:"lastHandshake"`
	// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for
	// the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely
	// sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit
	// from having a persistent keepalive interval of 25 seconds.
	PersistentKeepalive pulumi.StringPtrOutput `pulumi:"persistentKeepalive"`
	// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key
	// cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
	PresharedKey pulumi.StringPtrOutput `pulumi:"presharedKey"`
	// The remote peer's calculated public key.
	PublicKey pulumi.StringOutput `pulumi:"publicKey"`
	// The total amount of bytes received from the peer.
	Rx pulumi.StringOutput `pulumi:"rx"`
	// The total amount of bytes transmitted to the peer.
	Tx pulumi.StringOutput `pulumi:"tx"`
}

// NewWireguardPeer registers a new resource with the given unique name, arguments, and options.
func NewWireguardPeer(ctx *pulumi.Context,
	name string, args *WireguardPeerArgs, opts ...pulumi.ResourceOption) (*WireguardPeer, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Interface == nil {
		return nil, errors.New("invalid value for required argument 'Interface'")
	}
	if args.PublicKey == nil {
		return nil, errors.New("invalid value for required argument 'PublicKey'")
	}
	if args.PresharedKey != nil {
		args.PresharedKey = pulumi.ToSecret(args.PresharedKey).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"presharedKey",
	})
	opts = append(opts, secrets)
	var resource WireguardPeer
	err := ctx.RegisterResource("routeros:Iface/wireguardPeer:WireguardPeer", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetWireguardPeer gets an existing WireguardPeer resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetWireguardPeer(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *WireguardPeerState, opts ...pulumi.ResourceOption) (*WireguardPeer, error) {
	var resource WireguardPeer
	err := ctx.ReadResource("routeros:Iface/wireguardPeer:WireguardPeer", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering WireguardPeer resources.
type wireguardPeerState struct {
	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ *int `pulumi:"___id_"`
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ *string `pulumi:"___path_"`
	// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which
	// outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
	// and ::/0 may be specified for matching all IPv6 addresses.
	AllowedAddresses []string `pulumi:"allowedAddresses"`
	Comment          *string  `pulumi:"comment"`
	// The most recent source IP address of correctly authenticated packets from the peer.
	CurrentEndpointAddress *string `pulumi:"currentEndpointAddress"`
	// The most recent source IP port of correctly authenticated packets from the peer.
	CurrentEndpointPort *int  `pulumi:"currentEndpointPort"`
	Disabled            *bool `pulumi:"disabled"`
	// An endpoint IP or hostname can be left blank to allow remote connection from any address.
	EndpointAddress *string `pulumi:"endpointAddress"`
	// An endpoint port can be left blank to allow remote connection from any port.
	EndpointPort *string `pulumi:"endpointPort"`
	// Name of the interface.
	Interface *string `pulumi:"interface"`
	// Time in seconds after the last successful handshake.
	LastHandshake *string `pulumi:"lastHandshake"`
	// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for
	// the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely
	// sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit
	// from having a persistent keepalive interval of 25 seconds.
	PersistentKeepalive *string `pulumi:"persistentKeepalive"`
	// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key
	// cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
	PresharedKey *string `pulumi:"presharedKey"`
	// The remote peer's calculated public key.
	PublicKey *string `pulumi:"publicKey"`
	// The total amount of bytes received from the peer.
	Rx *string `pulumi:"rx"`
	// The total amount of bytes transmitted to the peer.
	Tx *string `pulumi:"tx"`
}

type WireguardPeerState struct {
	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ pulumi.IntPtrInput
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ pulumi.StringPtrInput
	// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which
	// outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
	// and ::/0 may be specified for matching all IPv6 addresses.
	AllowedAddresses pulumi.StringArrayInput
	Comment          pulumi.StringPtrInput
	// The most recent source IP address of correctly authenticated packets from the peer.
	CurrentEndpointAddress pulumi.StringPtrInput
	// The most recent source IP port of correctly authenticated packets from the peer.
	CurrentEndpointPort pulumi.IntPtrInput
	Disabled            pulumi.BoolPtrInput
	// An endpoint IP or hostname can be left blank to allow remote connection from any address.
	EndpointAddress pulumi.StringPtrInput
	// An endpoint port can be left blank to allow remote connection from any port.
	EndpointPort pulumi.StringPtrInput
	// Name of the interface.
	Interface pulumi.StringPtrInput
	// Time in seconds after the last successful handshake.
	LastHandshake pulumi.StringPtrInput
	// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for
	// the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely
	// sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit
	// from having a persistent keepalive interval of 25 seconds.
	PersistentKeepalive pulumi.StringPtrInput
	// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key
	// cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
	PresharedKey pulumi.StringPtrInput
	// The remote peer's calculated public key.
	PublicKey pulumi.StringPtrInput
	// The total amount of bytes received from the peer.
	Rx pulumi.StringPtrInput
	// The total amount of bytes transmitted to the peer.
	Tx pulumi.StringPtrInput
}

func (WireguardPeerState) ElementType() reflect.Type {
	return reflect.TypeOf((*wireguardPeerState)(nil)).Elem()
}

type wireguardPeerArgs struct {
	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ *int `pulumi:"___id_"`
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ *string `pulumi:"___path_"`
	// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which
	// outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
	// and ::/0 may be specified for matching all IPv6 addresses.
	AllowedAddresses []string `pulumi:"allowedAddresses"`
	Comment          *string  `pulumi:"comment"`
	Disabled         *bool    `pulumi:"disabled"`
	// An endpoint IP or hostname can be left blank to allow remote connection from any address.
	EndpointAddress *string `pulumi:"endpointAddress"`
	// An endpoint port can be left blank to allow remote connection from any port.
	EndpointPort *string `pulumi:"endpointPort"`
	// Name of the interface.
	Interface string `pulumi:"interface"`
	// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for
	// the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely
	// sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit
	// from having a persistent keepalive interval of 25 seconds.
	PersistentKeepalive *string `pulumi:"persistentKeepalive"`
	// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key
	// cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
	PresharedKey *string `pulumi:"presharedKey"`
	// The remote peer's calculated public key.
	PublicKey string `pulumi:"publicKey"`
}

// The set of arguments for constructing a WireguardPeer resource.
type WireguardPeerArgs struct {
	// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
	___id_ pulumi.IntPtrInput
	// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
	___path_ pulumi.StringPtrInput
	// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which
	// outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
	// and ::/0 may be specified for matching all IPv6 addresses.
	AllowedAddresses pulumi.StringArrayInput
	Comment          pulumi.StringPtrInput
	Disabled         pulumi.BoolPtrInput
	// An endpoint IP or hostname can be left blank to allow remote connection from any address.
	EndpointAddress pulumi.StringPtrInput
	// An endpoint port can be left blank to allow remote connection from any port.
	EndpointPort pulumi.StringPtrInput
	// Name of the interface.
	Interface pulumi.StringInput
	// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for
	// the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely
	// sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit
	// from having a persistent keepalive interval of 25 seconds.
	PersistentKeepalive pulumi.StringPtrInput
	// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key
	// cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
	PresharedKey pulumi.StringPtrInput
	// The remote peer's calculated public key.
	PublicKey pulumi.StringInput
}

func (WireguardPeerArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*wireguardPeerArgs)(nil)).Elem()
}

type WireguardPeerInput interface {
	pulumi.Input

	ToWireguardPeerOutput() WireguardPeerOutput
	ToWireguardPeerOutputWithContext(ctx context.Context) WireguardPeerOutput
}

func (*WireguardPeer) ElementType() reflect.Type {
	return reflect.TypeOf((**WireguardPeer)(nil)).Elem()
}

func (i *WireguardPeer) ToWireguardPeerOutput() WireguardPeerOutput {
	return i.ToWireguardPeerOutputWithContext(context.Background())
}

func (i *WireguardPeer) ToWireguardPeerOutputWithContext(ctx context.Context) WireguardPeerOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WireguardPeerOutput)
}

// WireguardPeerArrayInput is an input type that accepts WireguardPeerArray and WireguardPeerArrayOutput values.
// You can construct a concrete instance of `WireguardPeerArrayInput` via:
//
//	WireguardPeerArray{ WireguardPeerArgs{...} }
type WireguardPeerArrayInput interface {
	pulumi.Input

	ToWireguardPeerArrayOutput() WireguardPeerArrayOutput
	ToWireguardPeerArrayOutputWithContext(context.Context) WireguardPeerArrayOutput
}

type WireguardPeerArray []WireguardPeerInput

func (WireguardPeerArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*WireguardPeer)(nil)).Elem()
}

func (i WireguardPeerArray) ToWireguardPeerArrayOutput() WireguardPeerArrayOutput {
	return i.ToWireguardPeerArrayOutputWithContext(context.Background())
}

func (i WireguardPeerArray) ToWireguardPeerArrayOutputWithContext(ctx context.Context) WireguardPeerArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WireguardPeerArrayOutput)
}

// WireguardPeerMapInput is an input type that accepts WireguardPeerMap and WireguardPeerMapOutput values.
// You can construct a concrete instance of `WireguardPeerMapInput` via:
//
//	WireguardPeerMap{ "key": WireguardPeerArgs{...} }
type WireguardPeerMapInput interface {
	pulumi.Input

	ToWireguardPeerMapOutput() WireguardPeerMapOutput
	ToWireguardPeerMapOutputWithContext(context.Context) WireguardPeerMapOutput
}

type WireguardPeerMap map[string]WireguardPeerInput

func (WireguardPeerMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*WireguardPeer)(nil)).Elem()
}

func (i WireguardPeerMap) ToWireguardPeerMapOutput() WireguardPeerMapOutput {
	return i.ToWireguardPeerMapOutputWithContext(context.Background())
}

func (i WireguardPeerMap) ToWireguardPeerMapOutputWithContext(ctx context.Context) WireguardPeerMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WireguardPeerMapOutput)
}

type WireguardPeerOutput struct{ *pulumi.OutputState }

func (WireguardPeerOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WireguardPeer)(nil)).Elem()
}

func (o WireguardPeerOutput) ToWireguardPeerOutput() WireguardPeerOutput {
	return o
}

func (o WireguardPeerOutput) ToWireguardPeerOutputWithContext(ctx context.Context) WireguardPeerOutput {
	return o
}

// <em>Resource ID type (.id / name). This is an internal service field, setting a value is not required.</em>
func (o WireguardPeerOutput) ___id_() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.IntPtrOutput { return v.___id_ }).(pulumi.IntPtrOutput)
}

// <em>Resource path for CRUD operations. This is an internal service field, setting a value is not required.</em>
func (o WireguardPeerOutput) ___path_() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.StringPtrOutput { return v.___path_ }).(pulumi.StringPtrOutput)
}

// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which
// outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,
// and ::/0 may be specified for matching all IPv6 addresses.
func (o WireguardPeerOutput) AllowedAddresses() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.StringArrayOutput { return v.AllowedAddresses }).(pulumi.StringArrayOutput)
}

func (o WireguardPeerOutput) Comment() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.StringPtrOutput { return v.Comment }).(pulumi.StringPtrOutput)
}

// The most recent source IP address of correctly authenticated packets from the peer.
func (o WireguardPeerOutput) CurrentEndpointAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.StringOutput { return v.CurrentEndpointAddress }).(pulumi.StringOutput)
}

// The most recent source IP port of correctly authenticated packets from the peer.
func (o WireguardPeerOutput) CurrentEndpointPort() pulumi.IntOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.IntOutput { return v.CurrentEndpointPort }).(pulumi.IntOutput)
}

func (o WireguardPeerOutput) Disabled() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.BoolPtrOutput { return v.Disabled }).(pulumi.BoolPtrOutput)
}

// An endpoint IP or hostname can be left blank to allow remote connection from any address.
func (o WireguardPeerOutput) EndpointAddress() pulumi.StringOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.StringOutput { return v.EndpointAddress }).(pulumi.StringOutput)
}

// An endpoint port can be left blank to allow remote connection from any port.
func (o WireguardPeerOutput) EndpointPort() pulumi.StringOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.StringOutput { return v.EndpointPort }).(pulumi.StringOutput)
}

// Name of the interface.
func (o WireguardPeerOutput) Interface() pulumi.StringOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.StringOutput { return v.Interface }).(pulumi.StringOutput)
}

// Time in seconds after the last successful handshake.
func (o WireguardPeerOutput) LastHandshake() pulumi.StringOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.StringOutput { return v.LastHandshake }).(pulumi.StringOutput)
}

// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for
// the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely
// sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit
// from having a persistent keepalive interval of 25 seconds.
func (o WireguardPeerOutput) PersistentKeepalive() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.StringPtrOutput { return v.PersistentKeepalive }).(pulumi.StringPtrOutput)
}

// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key
// cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
func (o WireguardPeerOutput) PresharedKey() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.StringPtrOutput { return v.PresharedKey }).(pulumi.StringPtrOutput)
}

// The remote peer's calculated public key.
func (o WireguardPeerOutput) PublicKey() pulumi.StringOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.StringOutput { return v.PublicKey }).(pulumi.StringOutput)
}

// The total amount of bytes received from the peer.
func (o WireguardPeerOutput) Rx() pulumi.StringOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.StringOutput { return v.Rx }).(pulumi.StringOutput)
}

// The total amount of bytes transmitted to the peer.
func (o WireguardPeerOutput) Tx() pulumi.StringOutput {
	return o.ApplyT(func(v *WireguardPeer) pulumi.StringOutput { return v.Tx }).(pulumi.StringOutput)
}

type WireguardPeerArrayOutput struct{ *pulumi.OutputState }

func (WireguardPeerArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*WireguardPeer)(nil)).Elem()
}

func (o WireguardPeerArrayOutput) ToWireguardPeerArrayOutput() WireguardPeerArrayOutput {
	return o
}

func (o WireguardPeerArrayOutput) ToWireguardPeerArrayOutputWithContext(ctx context.Context) WireguardPeerArrayOutput {
	return o
}

func (o WireguardPeerArrayOutput) Index(i pulumi.IntInput) WireguardPeerOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *WireguardPeer {
		return vs[0].([]*WireguardPeer)[vs[1].(int)]
	}).(WireguardPeerOutput)
}

type WireguardPeerMapOutput struct{ *pulumi.OutputState }

func (WireguardPeerMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*WireguardPeer)(nil)).Elem()
}

func (o WireguardPeerMapOutput) ToWireguardPeerMapOutput() WireguardPeerMapOutput {
	return o
}

func (o WireguardPeerMapOutput) ToWireguardPeerMapOutputWithContext(ctx context.Context) WireguardPeerMapOutput {
	return o
}

func (o WireguardPeerMapOutput) MapIndex(k pulumi.StringInput) WireguardPeerOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *WireguardPeer {
		return vs[0].(map[string]*WireguardPeer)[vs[1].(string)]
	}).(WireguardPeerOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*WireguardPeerInput)(nil)).Elem(), &WireguardPeer{})
	pulumi.RegisterInputType(reflect.TypeOf((*WireguardPeerArrayInput)(nil)).Elem(), WireguardPeerArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WireguardPeerMapInput)(nil)).Elem(), WireguardPeerMap{})
	pulumi.RegisterOutputType(WireguardPeerOutput{})
	pulumi.RegisterOutputType(WireguardPeerArrayOutput{})
	pulumi.RegisterOutputType(WireguardPeerMapOutput{})
}
