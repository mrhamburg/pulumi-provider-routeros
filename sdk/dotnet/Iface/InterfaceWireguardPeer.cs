// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Routeros.Iface
{
    /// <summary>
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Routeros = Pulumi.Routeros;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var testWgInterface = new Routeros.Iface.InterfaceWireguard("testWgInterface", new()
    ///     {
    ///         ListenPort = 13231,
    ///     });
    /// 
    ///     var wgPeer = new Routeros.Iface.InterfaceWireguardPeer("wgPeer", new()
    ///     {
    ///         Interface = testWgInterface.Name,
    ///         PublicKey = "MY_BASE_64_PUBLIC_KEY",
    ///         AllowedAddresses = new[]
    ///         {
    ///             "192.168.0.0/16",
    ///             "172.16.0.0/12",
    ///             "10.0.0.0/8",
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// #The ID can be found via API or the terminal #The command for the terminal is -&gt; :put [/interface/wireguard/peers get [print show-ids]]
    /// 
    /// ```sh
    ///  $ pulumi import routeros:Iface/interfaceWireguardPeer:InterfaceWireguardPeer wg_peer "*0"
    /// ```
    /// </summary>
    [RouterosResourceType("routeros:Iface/interfaceWireguardPeer:InterfaceWireguardPeer")]
    public partial class InterfaceWireguardPeer : global::Pulumi.CustomResource
    {
        /// <summary>
        /// &lt;em&gt;Resource ID type (.id / name). This is an internal service field, setting a value is not required.&lt;/em&gt;
        /// </summary>
        [Output("___id_")]
        public Output<int?> ___id_ { get; private set; } = null!;

        /// <summary>
        /// &lt;em&gt;Resource path for CRUD operations. This is an internal service field, setting a value is not required.&lt;/em&gt;
        /// </summary>
        [Output("___path_")]
        public Output<string?> ___path_ { get; private set; } = null!;

        /// <summary>
        /// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.
        /// </summary>
        [Output("allowedAddresses")]
        public Output<ImmutableArray<string>> AllowedAddresses { get; private set; } = null!;

        [Output("comment")]
        public Output<string?> Comment { get; private set; } = null!;

        /// <summary>
        /// The most recent source IP address of correctly authenticated packets from the peer.
        /// </summary>
        [Output("currentEndpointAddress")]
        public Output<string> CurrentEndpointAddress { get; private set; } = null!;

        /// <summary>
        /// The most recent source IP port of correctly authenticated packets from the peer.
        /// </summary>
        [Output("currentEndpointPort")]
        public Output<int> CurrentEndpointPort { get; private set; } = null!;

        [Output("disabled")]
        public Output<bool?> Disabled { get; private set; } = null!;

        /// <summary>
        /// An endpoint IP or hostname can be left blank to allow remote connection from any address.
        /// </summary>
        [Output("endpointAddress")]
        public Output<string> EndpointAddress { get; private set; } = null!;

        /// <summary>
        /// An endpoint port can be left blank to allow remote connection from any port.
        /// </summary>
        [Output("endpointPort")]
        public Output<string> EndpointPort { get; private set; } = null!;

        /// <summary>
        /// Name of the interface.
        /// </summary>
        [Output("interface")]
        public Output<string> Interface { get; private set; } = null!;

        /// <summary>
        /// Time in seconds after the last successful handshake.
        /// </summary>
        [Output("lastHandshake")]
        public Output<string> LastHandshake { get; private set; } = null!;

        /// <summary>
        /// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.
        /// </summary>
        [Output("persistentKeepalive")]
        public Output<string?> PersistentKeepalive { get; private set; } = null!;

        /// <summary>
        /// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
        /// </summary>
        [Output("presharedKey")]
        public Output<string?> PresharedKey { get; private set; } = null!;

        /// <summary>
        /// The remote peer's calculated public key.
        /// </summary>
        [Output("publicKey")]
        public Output<string> PublicKey { get; private set; } = null!;

        /// <summary>
        /// The total amount of bytes received from the peer.
        /// </summary>
        [Output("rx")]
        public Output<string> Rx { get; private set; } = null!;

        /// <summary>
        /// The total amount of bytes transmitted to the peer.
        /// </summary>
        [Output("tx")]
        public Output<string> Tx { get; private set; } = null!;


        /// <summary>
        /// Create a InterfaceWireguardPeer resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public InterfaceWireguardPeer(string name, InterfaceWireguardPeerArgs args, CustomResourceOptions? options = null)
            : base("routeros:Iface/interfaceWireguardPeer:InterfaceWireguardPeer", name, args ?? new InterfaceWireguardPeerArgs(), MakeResourceOptions(options, ""))
        {
        }

        private InterfaceWireguardPeer(string name, Input<string> id, InterfaceWireguardPeerState? state = null, CustomResourceOptions? options = null)
            : base("routeros:Iface/interfaceWireguardPeer:InterfaceWireguardPeer", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                AdditionalSecretOutputs =
                {
                    "presharedKey",
                },
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing InterfaceWireguardPeer resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static InterfaceWireguardPeer Get(string name, Input<string> id, InterfaceWireguardPeerState? state = null, CustomResourceOptions? options = null)
        {
            return new InterfaceWireguardPeer(name, id, state, options);
        }
    }

    public sealed class InterfaceWireguardPeerArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// &lt;em&gt;Resource ID type (.id / name). This is an internal service field, setting a value is not required.&lt;/em&gt;
        /// </summary>
        [Input("___id_")]
        public Input<int>? ___id_ { get; set; }

        /// <summary>
        /// &lt;em&gt;Resource path for CRUD operations. This is an internal service field, setting a value is not required.&lt;/em&gt;
        /// </summary>
        [Input("___path_")]
        public Input<string>? ___path_ { get; set; }

        [Input("allowedAddresses")]
        private InputList<string>? _allowedAddresses;

        /// <summary>
        /// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.
        /// </summary>
        public InputList<string> AllowedAddresses
        {
            get => _allowedAddresses ?? (_allowedAddresses = new InputList<string>());
            set => _allowedAddresses = value;
        }

        [Input("comment")]
        public Input<string>? Comment { get; set; }

        [Input("disabled")]
        public Input<bool>? Disabled { get; set; }

        /// <summary>
        /// An endpoint IP or hostname can be left blank to allow remote connection from any address.
        /// </summary>
        [Input("endpointAddress")]
        public Input<string>? EndpointAddress { get; set; }

        /// <summary>
        /// An endpoint port can be left blank to allow remote connection from any port.
        /// </summary>
        [Input("endpointPort")]
        public Input<string>? EndpointPort { get; set; }

        /// <summary>
        /// Name of the interface.
        /// </summary>
        [Input("interface", required: true)]
        public Input<string> Interface { get; set; } = null!;

        /// <summary>
        /// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.
        /// </summary>
        [Input("persistentKeepalive")]
        public Input<string>? PersistentKeepalive { get; set; }

        [Input("presharedKey")]
        private Input<string>? _presharedKey;

        /// <summary>
        /// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
        /// </summary>
        public Input<string>? PresharedKey
        {
            get => _presharedKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _presharedKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// The remote peer's calculated public key.
        /// </summary>
        [Input("publicKey", required: true)]
        public Input<string> PublicKey { get; set; } = null!;

        public InterfaceWireguardPeerArgs()
        {
        }
        public static new InterfaceWireguardPeerArgs Empty => new InterfaceWireguardPeerArgs();
    }

    public sealed class InterfaceWireguardPeerState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// &lt;em&gt;Resource ID type (.id / name). This is an internal service field, setting a value is not required.&lt;/em&gt;
        /// </summary>
        [Input("___id_")]
        public Input<int>? ___id_ { get; set; }

        /// <summary>
        /// &lt;em&gt;Resource path for CRUD operations. This is an internal service field, setting a value is not required.&lt;/em&gt;
        /// </summary>
        [Input("___path_")]
        public Input<string>? ___path_ { get; set; }

        [Input("allowedAddresses")]
        private InputList<string>? _allowedAddresses;

        /// <summary>
        /// List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.
        /// </summary>
        public InputList<string> AllowedAddresses
        {
            get => _allowedAddresses ?? (_allowedAddresses = new InputList<string>());
            set => _allowedAddresses = value;
        }

        [Input("comment")]
        public Input<string>? Comment { get; set; }

        /// <summary>
        /// The most recent source IP address of correctly authenticated packets from the peer.
        /// </summary>
        [Input("currentEndpointAddress")]
        public Input<string>? CurrentEndpointAddress { get; set; }

        /// <summary>
        /// The most recent source IP port of correctly authenticated packets from the peer.
        /// </summary>
        [Input("currentEndpointPort")]
        public Input<int>? CurrentEndpointPort { get; set; }

        [Input("disabled")]
        public Input<bool>? Disabled { get; set; }

        /// <summary>
        /// An endpoint IP or hostname can be left blank to allow remote connection from any address.
        /// </summary>
        [Input("endpointAddress")]
        public Input<string>? EndpointAddress { get; set; }

        /// <summary>
        /// An endpoint port can be left blank to allow remote connection from any port.
        /// </summary>
        [Input("endpointPort")]
        public Input<string>? EndpointPort { get; set; }

        /// <summary>
        /// Name of the interface.
        /// </summary>
        [Input("interface")]
        public Input<string>? Interface { get; set; }

        /// <summary>
        /// Time in seconds after the last successful handshake.
        /// </summary>
        [Input("lastHandshake")]
        public Input<string>? LastHandshake { get; set; }

        /// <summary>
        /// A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.
        /// </summary>
        [Input("persistentKeepalive")]
        public Input<string>? PersistentKeepalive { get; set; }

        [Input("presharedKey")]
        private Input<string>? _presharedKey;

        /// <summary>
        /// A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.
        /// </summary>
        public Input<string>? PresharedKey
        {
            get => _presharedKey;
            set
            {
                var emptySecret = Output.CreateSecret(0);
                _presharedKey = Output.Tuple<Input<string>?, int>(value, emptySecret).Apply(t => t.Item1);
            }
        }

        /// <summary>
        /// The remote peer's calculated public key.
        /// </summary>
        [Input("publicKey")]
        public Input<string>? PublicKey { get; set; }

        /// <summary>
        /// The total amount of bytes received from the peer.
        /// </summary>
        [Input("rx")]
        public Input<string>? Rx { get; set; }

        /// <summary>
        /// The total amount of bytes transmitted to the peer.
        /// </summary>
        [Input("tx")]
        public Input<string>? Tx { get; set; }

        public InterfaceWireguardPeerState()
        {
        }
        public static new InterfaceWireguardPeerState Empty => new InterfaceWireguardPeerState();
    }
}
