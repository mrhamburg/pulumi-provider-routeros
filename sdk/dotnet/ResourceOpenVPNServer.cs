// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Routeros
{
    /// <summary>
    /// ## # routeros.ResourceOpenVPNServer (Resource)
    /// 
    /// ##### *&lt;span style="color:red"&gt;This resource requires a minimum version of RouterOS 7.8!&lt;/span&gt;*
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Routeros = Pulumi.Routeros;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var ovpn_pool = new Routeros.ResourceIPPool("ovpn-pool", new()
    ///     {
    ///         Ranges = new[]
    ///         {
    ///             "192.168.77.2-192.168.77.254",
    ///         },
    ///     });
    /// 
    ///     var ovpnCa = new Routeros.ResourceSystemCertificate("ovpnCa", new()
    ///     {
    ///         CommonName = "OpenVPN Root CA",
    ///         KeySize = "prime256v1",
    ///         KeyUsages = new[]
    ///         {
    ///             "key-cert-sign",
    ///             "crl-sign",
    ///         },
    ///         Trusted = true,
    ///         Signs = new[]
    ///         {
    ///             null,
    ///         },
    ///     });
    /// 
    ///     var ovpnServerCrt = new Routeros.ResourceSystemCertificate("ovpnServerCrt", new()
    ///     {
    ///         CommonName = "Mikrotik OpenVPN",
    ///         KeySize = "prime256v1",
    ///         KeyUsages = new[]
    ///         {
    ///             "digital-signature",
    ///             "key-encipherment",
    ///             "tls-server",
    ///         },
    ///         Signs = new[]
    ///         {
    ///             new Routeros.Inputs.ResourceSystemCertificateSignArgs
    ///             {
    ///                 Ca = ovpnCa.Name,
    ///             },
    ///         },
    ///     });
    /// 
    ///     var testResourcePPPProfile = new Routeros.ResourcePPPProfile("testResourcePPPProfile", new()
    ///     {
    ///         LocalAddress = "192.168.77.1",
    ///         RemoteAddress = "ovpn-pool",
    ///         UseUpnp = "no",
    ///     });
    /// 
    ///     var testResourcePPPSecret = new Routeros.ResourcePPPSecret("testResourcePPPSecret", new()
    ///     {
    ///         Password = "123",
    ///         Profile = testResourcePPPProfile.Name,
    ///     });
    /// 
    ///     var server = new Routeros.ResourceOpenVPNServer("server", new()
    ///     {
    ///         Enabled = true,
    ///         Certificate = ovpnServerCrt.Name,
    ///         Auth = "sha256,sha512",
    ///         TlsVersion = "only-1.2",
    ///         DefaultProfile = testResourcePPPProfile.Name,
    ///     });
    /// 
    ///     // The resource should be created only after the OpenVPN server is enabled!
    ///     var user1 = new Routeros.ResourceInterfaceOpenVPNServer("user1", new()
    ///     {
    ///         User = "user1",
    ///     }, new CustomResourceOptions
    ///     {
    ///         DependsOn = new[]
    ///         {
    ///             server,
    ///         },
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// ```sh
    ///  $ pulumi import routeros:index/resourceOpenVPNServer:ResourceOpenVPNServer server .
    /// ```
    /// </summary>
    [RouterosResourceType("routeros:index/resourceOpenVPNServer:ResourceOpenVPNServer")]
    public partial class ResourceOpenVPNServer : global::Pulumi.CustomResource
    {
        /// <summary>
        /// &lt;em&gt;Resource ID type (.id / name). This is an internal service field, setting a value is not required.&lt;/em&gt;
        /// </summary>
        [Output("___id_")]
        public Output<int?> ___id_ { get; private set; } = null!;

        /// <summary>
        /// &lt;em&gt;Resource path for CRUD operations. This is an internal service field, setting a value is not required.&lt;/em&gt;
        /// </summary>
        [Output("___path_")]
        public Output<string?> ___path_ { get; private set; } = null!;

        /// <summary>
        /// Authentication methods that the server will accept.
        /// </summary>
        [Output("auth")]
        public Output<string?> Auth { get; private set; } = null!;

        /// <summary>
        /// Name of the certificate that the OVPN server will use.
        /// </summary>
        [Output("certificate")]
        public Output<string> Certificate { get; private set; } = null!;

        /// <summary>
        /// Allowed ciphers.
        /// </summary>
        [Output("cipher")]
        public Output<string?> Cipher { get; private set; } = null!;

        /// <summary>
        /// Default profile to use.
        /// </summary>
        [Output("defaultProfile")]
        public Output<string?> DefaultProfile { get; private set; } = null!;

        /// <summary>
        /// Specifies if IPv6 IP tunneling mode should be possible with this OVPN server.
        /// </summary>
        [Output("enableTunIpv6")]
        public Output<bool?> EnableTunIpv6 { get; private set; } = null!;

        /// <summary>
        /// Defines whether the OVPN server is enabled or not.
        /// </summary>
        [Output("enabled")]
        public Output<bool?> Enabled { get; private set; } = null!;

        /// <summary>
        /// Length of IPv6 prefix for IPv6 address which will be used when generating OVPN interface on the server side.
        /// </summary>
        [Output("ipv6PrefixLen")]
        public Output<int?> Ipv6PrefixLen { get; private set; } = null!;

        /// <summary>
        /// Defines  the time period (in seconds) after which the router is starting to send  keepalive packets every second. If no traffic and no keepalive  responses have come for that period of time (i.e. 2 *  keepalive-timeout), not responding client is proclaimed disconnected
        /// </summary>
        [Output("keepaliveTimeout")]
        public Output<string?> KeepaliveTimeout { get; private set; } = null!;

        /// <summary>
        /// Automatically generated MAC address of the server.
        /// </summary>
        [Output("macAddress")]
        public Output<string> MacAddress { get; private set; } = null!;

        /// <summary>
        /// Maximum Transmission Unit. Max packet size that the OVPN interface will be able to send without packet fragmentation.
        /// </summary>
        [Output("maxMtu")]
        public Output<int?> MaxMtu { get; private set; } = null!;

        /// <summary>
        /// Layer3 or layer2 tunnel mode (alternatively tun, tap)
        /// </summary>
        [Output("mode")]
        public Output<string?> Mode { get; private set; } = null!;

        /// <summary>
        /// Subnet mask to be applied to the client.
        /// </summary>
        [Output("netmask")]
        public Output<int?> Netmask { get; private set; } = null!;

        /// <summary>
        /// Port to run the server on.
        /// </summary>
        [Output("port")]
        public Output<int?> Port { get; private set; } = null!;

        /// <summary>
        /// indicates the protocol to use when connecting with the remote endpoint.
        /// </summary>
        [Output("protocol")]
        public Output<string?> Protocol { get; private set; } = null!;

        /// <summary>
        /// Specifies what kind of routes the OVPN client must add to the routing table. def1 – Use this flag to override the default gateway by using 0.0.0.0/1 and  128.0.0.0/1 rather than 0.0.0.0/0. This has the benefit of overriding  but not wiping out the original default gateway. disabled - Do not send redirect-gateway flags to the OVPN client. ipv6 - Redirect IPv6 routing into the tunnel on the client side. This works  similarly to the def1 flag, that is, more specific IPv6 routes are added  (2000::/4 and 3000::/4), covering the whole IPv6 unicast space.
        /// </summary>
        [Output("redirectGateway")]
        public Output<string?> RedirectGateway { get; private set; } = null!;

        /// <summary>
        /// Renegotiate data channel key after n seconds (default=3600).
        /// </summary>
        [Output("renegSec")]
        public Output<int?> RenegSec { get; private set; } = null!;

        /// <summary>
        /// If set to yes, then the server checks whether the client's certificate belongs to the same certificate chain.
        /// </summary>
        [Output("requireClientCertificate")]
        public Output<bool?> RequireClientCertificate { get; private set; } = null!;

        /// <summary>
        /// Specifies which TLS versions to allow.
        /// </summary>
        [Output("tlsVersion")]
        public Output<string?> TlsVersion { get; private set; } = null!;

        /// <summary>
        /// IPv6 prefix address which will be used when generating the OVPN interface on the server side.
        /// </summary>
        [Output("tunServerIpv6")]
        public Output<string?> TunServerIpv6 { get; private set; } = null!;


        /// <summary>
        /// Create a ResourceOpenVPNServer resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public ResourceOpenVPNServer(string name, ResourceOpenVPNServerArgs args, CustomResourceOptions? options = null)
            : base("routeros:index/resourceOpenVPNServer:ResourceOpenVPNServer", name, args ?? new ResourceOpenVPNServerArgs(), MakeResourceOptions(options, ""))
        {
        }

        private ResourceOpenVPNServer(string name, Input<string> id, ResourceOpenVPNServerState? state = null, CustomResourceOptions? options = null)
            : base("routeros:index/resourceOpenVPNServer:ResourceOpenVPNServer", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing ResourceOpenVPNServer resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static ResourceOpenVPNServer Get(string name, Input<string> id, ResourceOpenVPNServerState? state = null, CustomResourceOptions? options = null)
        {
            return new ResourceOpenVPNServer(name, id, state, options);
        }
    }

    public sealed class ResourceOpenVPNServerArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// &lt;em&gt;Resource ID type (.id / name). This is an internal service field, setting a value is not required.&lt;/em&gt;
        /// </summary>
        [Input("___id_")]
        public Input<int>? ___id_ { get; set; }

        /// <summary>
        /// &lt;em&gt;Resource path for CRUD operations. This is an internal service field, setting a value is not required.&lt;/em&gt;
        /// </summary>
        [Input("___path_")]
        public Input<string>? ___path_ { get; set; }

        /// <summary>
        /// Authentication methods that the server will accept.
        /// </summary>
        [Input("auth")]
        public Input<string>? Auth { get; set; }

        /// <summary>
        /// Name of the certificate that the OVPN server will use.
        /// </summary>
        [Input("certificate", required: true)]
        public Input<string> Certificate { get; set; } = null!;

        /// <summary>
        /// Allowed ciphers.
        /// </summary>
        [Input("cipher")]
        public Input<string>? Cipher { get; set; }

        /// <summary>
        /// Default profile to use.
        /// </summary>
        [Input("defaultProfile")]
        public Input<string>? DefaultProfile { get; set; }

        /// <summary>
        /// Specifies if IPv6 IP tunneling mode should be possible with this OVPN server.
        /// </summary>
        [Input("enableTunIpv6")]
        public Input<bool>? EnableTunIpv6 { get; set; }

        /// <summary>
        /// Defines whether the OVPN server is enabled or not.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Length of IPv6 prefix for IPv6 address which will be used when generating OVPN interface on the server side.
        /// </summary>
        [Input("ipv6PrefixLen")]
        public Input<int>? Ipv6PrefixLen { get; set; }

        /// <summary>
        /// Defines  the time period (in seconds) after which the router is starting to send  keepalive packets every second. If no traffic and no keepalive  responses have come for that period of time (i.e. 2 *  keepalive-timeout), not responding client is proclaimed disconnected
        /// </summary>
        [Input("keepaliveTimeout")]
        public Input<string>? KeepaliveTimeout { get; set; }

        /// <summary>
        /// Automatically generated MAC address of the server.
        /// </summary>
        [Input("macAddress")]
        public Input<string>? MacAddress { get; set; }

        /// <summary>
        /// Maximum Transmission Unit. Max packet size that the OVPN interface will be able to send without packet fragmentation.
        /// </summary>
        [Input("maxMtu")]
        public Input<int>? MaxMtu { get; set; }

        /// <summary>
        /// Layer3 or layer2 tunnel mode (alternatively tun, tap)
        /// </summary>
        [Input("mode")]
        public Input<string>? Mode { get; set; }

        /// <summary>
        /// Subnet mask to be applied to the client.
        /// </summary>
        [Input("netmask")]
        public Input<int>? Netmask { get; set; }

        /// <summary>
        /// Port to run the server on.
        /// </summary>
        [Input("port")]
        public Input<int>? Port { get; set; }

        /// <summary>
        /// indicates the protocol to use when connecting with the remote endpoint.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        /// <summary>
        /// Specifies what kind of routes the OVPN client must add to the routing table. def1 – Use this flag to override the default gateway by using 0.0.0.0/1 and  128.0.0.0/1 rather than 0.0.0.0/0. This has the benefit of overriding  but not wiping out the original default gateway. disabled - Do not send redirect-gateway flags to the OVPN client. ipv6 - Redirect IPv6 routing into the tunnel on the client side. This works  similarly to the def1 flag, that is, more specific IPv6 routes are added  (2000::/4 and 3000::/4), covering the whole IPv6 unicast space.
        /// </summary>
        [Input("redirectGateway")]
        public Input<string>? RedirectGateway { get; set; }

        /// <summary>
        /// Renegotiate data channel key after n seconds (default=3600).
        /// </summary>
        [Input("renegSec")]
        public Input<int>? RenegSec { get; set; }

        /// <summary>
        /// If set to yes, then the server checks whether the client's certificate belongs to the same certificate chain.
        /// </summary>
        [Input("requireClientCertificate")]
        public Input<bool>? RequireClientCertificate { get; set; }

        /// <summary>
        /// Specifies which TLS versions to allow.
        /// </summary>
        [Input("tlsVersion")]
        public Input<string>? TlsVersion { get; set; }

        /// <summary>
        /// IPv6 prefix address which will be used when generating the OVPN interface on the server side.
        /// </summary>
        [Input("tunServerIpv6")]
        public Input<string>? TunServerIpv6 { get; set; }

        public ResourceOpenVPNServerArgs()
        {
        }
        public static new ResourceOpenVPNServerArgs Empty => new ResourceOpenVPNServerArgs();
    }

    public sealed class ResourceOpenVPNServerState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// &lt;em&gt;Resource ID type (.id / name). This is an internal service field, setting a value is not required.&lt;/em&gt;
        /// </summary>
        [Input("___id_")]
        public Input<int>? ___id_ { get; set; }

        /// <summary>
        /// &lt;em&gt;Resource path for CRUD operations. This is an internal service field, setting a value is not required.&lt;/em&gt;
        /// </summary>
        [Input("___path_")]
        public Input<string>? ___path_ { get; set; }

        /// <summary>
        /// Authentication methods that the server will accept.
        /// </summary>
        [Input("auth")]
        public Input<string>? Auth { get; set; }

        /// <summary>
        /// Name of the certificate that the OVPN server will use.
        /// </summary>
        [Input("certificate")]
        public Input<string>? Certificate { get; set; }

        /// <summary>
        /// Allowed ciphers.
        /// </summary>
        [Input("cipher")]
        public Input<string>? Cipher { get; set; }

        /// <summary>
        /// Default profile to use.
        /// </summary>
        [Input("defaultProfile")]
        public Input<string>? DefaultProfile { get; set; }

        /// <summary>
        /// Specifies if IPv6 IP tunneling mode should be possible with this OVPN server.
        /// </summary>
        [Input("enableTunIpv6")]
        public Input<bool>? EnableTunIpv6 { get; set; }

        /// <summary>
        /// Defines whether the OVPN server is enabled or not.
        /// </summary>
        [Input("enabled")]
        public Input<bool>? Enabled { get; set; }

        /// <summary>
        /// Length of IPv6 prefix for IPv6 address which will be used when generating OVPN interface on the server side.
        /// </summary>
        [Input("ipv6PrefixLen")]
        public Input<int>? Ipv6PrefixLen { get; set; }

        /// <summary>
        /// Defines  the time period (in seconds) after which the router is starting to send  keepalive packets every second. If no traffic and no keepalive  responses have come for that period of time (i.e. 2 *  keepalive-timeout), not responding client is proclaimed disconnected
        /// </summary>
        [Input("keepaliveTimeout")]
        public Input<string>? KeepaliveTimeout { get; set; }

        /// <summary>
        /// Automatically generated MAC address of the server.
        /// </summary>
        [Input("macAddress")]
        public Input<string>? MacAddress { get; set; }

        /// <summary>
        /// Maximum Transmission Unit. Max packet size that the OVPN interface will be able to send without packet fragmentation.
        /// </summary>
        [Input("maxMtu")]
        public Input<int>? MaxMtu { get; set; }

        /// <summary>
        /// Layer3 or layer2 tunnel mode (alternatively tun, tap)
        /// </summary>
        [Input("mode")]
        public Input<string>? Mode { get; set; }

        /// <summary>
        /// Subnet mask to be applied to the client.
        /// </summary>
        [Input("netmask")]
        public Input<int>? Netmask { get; set; }

        /// <summary>
        /// Port to run the server on.
        /// </summary>
        [Input("port")]
        public Input<int>? Port { get; set; }

        /// <summary>
        /// indicates the protocol to use when connecting with the remote endpoint.
        /// </summary>
        [Input("protocol")]
        public Input<string>? Protocol { get; set; }

        /// <summary>
        /// Specifies what kind of routes the OVPN client must add to the routing table. def1 – Use this flag to override the default gateway by using 0.0.0.0/1 and  128.0.0.0/1 rather than 0.0.0.0/0. This has the benefit of overriding  but not wiping out the original default gateway. disabled - Do not send redirect-gateway flags to the OVPN client. ipv6 - Redirect IPv6 routing into the tunnel on the client side. This works  similarly to the def1 flag, that is, more specific IPv6 routes are added  (2000::/4 and 3000::/4), covering the whole IPv6 unicast space.
        /// </summary>
        [Input("redirectGateway")]
        public Input<string>? RedirectGateway { get; set; }

        /// <summary>
        /// Renegotiate data channel key after n seconds (default=3600).
        /// </summary>
        [Input("renegSec")]
        public Input<int>? RenegSec { get; set; }

        /// <summary>
        /// If set to yes, then the server checks whether the client's certificate belongs to the same certificate chain.
        /// </summary>
        [Input("requireClientCertificate")]
        public Input<bool>? RequireClientCertificate { get; set; }

        /// <summary>
        /// Specifies which TLS versions to allow.
        /// </summary>
        [Input("tlsVersion")]
        public Input<string>? TlsVersion { get; set; }

        /// <summary>
        /// IPv6 prefix address which will be used when generating the OVPN interface on the server side.
        /// </summary>
        [Input("tunServerIpv6")]
        public Input<string>? TunServerIpv6 { get; set; }

        public ResourceOpenVPNServerState()
        {
        }
        public static new ResourceOpenVPNServerState Empty => new ResourceOpenVPNServerState();
    }
}
