{
    "name": "routeros",
    "description": "A Pulumi package for creating and managing routeros cloud resources.",
    "keywords": [
        "pulumi",
        "routeros",
        "category/cloud"
    ],
    "homepage": "https://www.pulumi.com",
    "license": "Apache-2.0",
    "attribution": "This Pulumi package is based on the [`routeros` Terraform Provider](https://github.com/terraform-routeros/terraform-provider-routeros).",
    "repository": "https://github.com/mrhamburg/pulumi-provider-routeros",
    "publisher": "Pulumi",
    "meta": {
        "moduleFormat": "(.*)(?:/[^/]*)"
    },
    "language": {
        "csharp": {
            "compatibility": "tfbridge20",
            "namespaces": null,
            "packageReferences": {
                "Pulumi": "3.*"
            }
        },
        "go": {
            "generateExtraInputTypes": true,
            "generateResourceContainerTypes": true,
            "importBasePath": "github.com/pulumi/pulumi-routeros/sdk/go/routeros"
        },
        "nodejs": {
            "compatibility": "tfbridge20",
            "dependencies": {
                "@pulumi/pulumi": "^3.0.0"
            },
            "devDependencies": {
                "@types/mime": "^2.0.0",
                "@types/node": "^10.0.0"
            },
            "disableUnionOutputTypes": true,
            "packageDescription": "A Pulumi package for creating and managing routeros cloud resources.",
            "packageName": "",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/terraform-routeros/terraform-provider-routeros)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-routeros` repo](https://github.com/mrhamburg/pulumi-provider-routeros/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-routeros` repo](https://github.com/terraform-routeros/terraform-provider-routeros/issues).",
            "typescriptVersion": ""
        },
        "python": {
            "compatibility": "tfbridge20",
            "readme": "\u003e This provider is a derived work of the [Terraform Provider](https://github.com/terraform-routeros/terraform-provider-routeros)\n\u003e distributed under [MPL 2.0](https://www.mozilla.org/en-US/MPL/2.0/). If you encounter a bug or missing feature,\n\u003e first check the [`pulumi-routeros` repo](https://github.com/mrhamburg/pulumi-provider-routeros/issues); however, if that doesn't turn up anything,\n\u003e please consult the source [`terraform-provider-routeros` repo](https://github.com/terraform-routeros/terraform-provider-routeros/issues).",
            "requires": {
                "pulumi": "\u003e=3.0.0,\u003c4.0.0"
            }
        }
    },
    "config": {
        "variables": {
            "caCertificate": {
                "type": "string",
                "description": "Path to MikroTik's certificate authority file.\n",
                "defaultInfo": {
                    "environment": [
                        "ROS_CA_CERTIFICATE"
                    ]
                },
                "secret": true
            },
            "hosturl": {
                "type": "string",
                "description": "URL of the MikroTik router, default is TLS connection to REST. * API: api[s]://host[:port] * api://router.local *\napis://router.local:8729 * REST: https://host * https://router.local * router.local * 127.0.0.1 export\nROS_HOSTURL=router.local or export MIKROTIK_HOST=router.local\n",
                "defaultInfo": {
                    "environment": [
                        "ROS_HOSTURL"
                    ]
                }
            },
            "insecure": {
                "type": "boolean",
                "description": "Whether to verify the SSL certificate or not.\n",
                "defaultInfo": {
                    "environment": [
                        "ROS_INSECURE"
                    ]
                }
            },
            "password": {
                "type": "string",
                "description": "Password for the MikroTik user.\n",
                "defaultInfo": {
                    "environment": [
                        "ROS_PASSWORD"
                    ]
                },
                "secret": true
            },
            "username": {
                "type": "string",
                "description": "Username for the MikroTik WEB/Winbox. export ROS_USERNAME=admin or export MIKROTIK_USER=admin\n",
                "defaultInfo": {
                    "environment": [
                        "ROS_USERNAME"
                    ]
                }
            }
        },
        "defaults": [
            "hosturl",
            "username"
        ]
    },
    "types": {
        "routeros:Iface/getInterfacesInterface:getInterfacesInterface": {
            "properties": {
                "actualMtu": {
                    "type": "integer"
                },
                "comment": {
                    "type": "string"
                },
                "defaultName": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "fpRxByte": {
                    "type": "integer"
                },
                "fpRxPacket": {
                    "type": "integer"
                },
                "fpTxByte": {
                    "type": "integer"
                },
                "fpTxPacket": {
                    "type": "integer"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "l2mtu": {
                    "type": "integer"
                },
                "lastLinkDownTime": {
                    "type": "string"
                },
                "lastLinkUpTime": {
                    "type": "string"
                },
                "linkDowns": {
                    "type": "integer"
                },
                "macAddress": {
                    "type": "string"
                },
                "maxL2mtu": {
                    "type": "integer"
                },
                "mtu": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                },
                "running": {
                    "type": "boolean"
                },
                "rxByte": {
                    "type": "integer"
                },
                "rxDrop": {
                    "type": "integer"
                },
                "rxError": {
                    "type": "integer"
                },
                "rxPacket": {
                    "type": "integer"
                },
                "slave": {
                    "type": "boolean"
                },
                "txByte": {
                    "type": "integer"
                },
                "txDrop": {
                    "type": "integer"
                },
                "txError": {
                    "type": "integer"
                },
                "txPacket": {
                    "type": "integer"
                },
                "txQueueDrop": {
                    "type": "integer"
                },
                "type": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "actualMtu",
                "comment",
                "defaultName",
                "disabled",
                "fpRxByte",
                "fpRxPacket",
                "fpTxByte",
                "fpTxPacket",
                "id",
                "l2mtu",
                "lastLinkDownTime",
                "lastLinkUpTime",
                "linkDowns",
                "macAddress",
                "maxL2mtu",
                "mtu",
                "name",
                "running",
                "rxByte",
                "rxDrop",
                "rxError",
                "rxPacket",
                "slave",
                "txByte",
                "txDrop",
                "txError",
                "txPacket",
                "txQueueDrop",
                "type"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "routeros:Ip/getAddressesAddress:getAddressesAddress": {
            "properties": {
                "actualInterface": {
                    "type": "string"
                },
                "address": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "interface": {
                    "type": "string"
                },
                "invalid": {
                    "type": "boolean"
                },
                "network": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "actualInterface",
                "address",
                "disabled",
                "dynamic",
                "id",
                "interface",
                "invalid",
                "network"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "routeros:Ip/getFirewallAddressList:getFirewallAddressList": {
            "properties": {
                "address": {
                    "type": "string"
                },
                "comment": {
                    "type": "string"
                },
                "creationTime": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean"
                },
                "filter": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Additional request filtering options.\n"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "list": {
                    "type": "string"
                },
                "timeout": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "address",
                "comment",
                "creationTime",
                "disabled",
                "dynamic",
                "id",
                "list",
                "timeout"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "routeros:Ip/getFirewallMangle:getFirewallMangle": {
            "properties": {
                "action": {
                    "type": "string"
                },
                "addressList": {
                    "type": "string"
                },
                "addressListTimeout": {
                    "type": "string"
                },
                "bytes": {
                    "type": "integer"
                },
                "chain": {
                    "type": "string"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string"
                },
                "connectionLimit": {
                    "type": "string"
                },
                "connectionMark": {
                    "type": "string"
                },
                "connectionNatState": {
                    "type": "string"
                },
                "connectionRate": {
                    "type": "string"
                },
                "connectionState": {
                    "type": "string"
                },
                "connectionType": {
                    "type": "string"
                },
                "content": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer"
                },
                "dstAddress": {
                    "type": "string"
                },
                "dstAddressList": {
                    "type": "string"
                },
                "dstAddressType": {
                    "type": "string"
                },
                "dstLimit": {
                    "type": "string"
                },
                "dstPort": {
                    "type": "string"
                },
                "dynamic": {
                    "type": "boolean"
                },
                "filter": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Additional request filtering options.\n"
                },
                "fragment": {
                    "type": "boolean"
                },
                "hotspot": {
                    "type": "string"
                },
                "icmpOptions": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "inBridgePort": {
                    "type": "string"
                },
                "inBridgePortList": {
                    "type": "string"
                },
                "inInterface": {
                    "type": "string"
                },
                "inInterfaceList": {
                    "type": "string"
                },
                "ingressPriority": {
                    "type": "integer"
                },
                "invalid": {
                    "type": "boolean"
                },
                "ipsecPolicy": {
                    "type": "string"
                },
                "ipv4Options": {
                    "type": "string"
                },
                "jumpTarget": {
                    "type": "string"
                },
                "layer7Protocol": {
                    "type": "string"
                },
                "limit": {
                    "type": "string"
                },
                "log": {
                    "type": "boolean"
                },
                "logPrefix": {
                    "type": "string"
                },
                "newConnectionMark": {
                    "type": "string"
                },
                "newDscp": {
                    "type": "integer"
                },
                "newMss": {
                    "type": "integer"
                },
                "newPacketMark": {
                    "type": "string"
                },
                "newPriority": {
                    "type": "string"
                },
                "newRoutingMark": {
                    "type": "string"
                },
                "newTtl": {
                    "type": "string"
                },
                "nth": {
                    "type": "string"
                },
                "outBridgePort": {
                    "type": "string"
                },
                "outBridgePortList": {
                    "type": "string"
                },
                "outInterface": {
                    "type": "string"
                },
                "outInterfaceList": {
                    "type": "string"
                },
                "packetMark": {
                    "type": "string"
                },
                "packetSize": {
                    "type": "string"
                },
                "packets": {
                    "type": "integer"
                },
                "passthrough": {
                    "type": "boolean"
                },
                "perConnectionClassifier": {
                    "type": "string"
                },
                "port": {
                    "type": "string"
                },
                "protocol": {
                    "type": "string"
                },
                "psd": {
                    "type": "string"
                },
                "random": {
                    "type": "integer"
                },
                "routeDst": {
                    "type": "string"
                },
                "routingMark": {
                    "type": "string"
                },
                "srcAddress": {
                    "type": "string"
                },
                "srcAddressList": {
                    "type": "string"
                },
                "srcAddressType": {
                    "type": "string"
                },
                "srcMacAddress": {
                    "type": "string"
                },
                "srcPort": {
                    "type": "string"
                },
                "tcpFlags": {
                    "type": "string"
                },
                "tcpMss": {
                    "type": "string"
                },
                "time": {
                    "type": "string"
                },
                "tlsHost": {
                    "type": "string"
                },
                "ttl": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "action",
                "addressList",
                "addressListTimeout",
                "bytes",
                "chain",
                "comment",
                "connectionBytes",
                "connectionLimit",
                "connectionMark",
                "connectionNatState",
                "connectionRate",
                "connectionState",
                "connectionType",
                "content",
                "disabled",
                "dscp",
                "dstAddress",
                "dstAddressList",
                "dstAddressType",
                "dstLimit",
                "dstPort",
                "dynamic",
                "fragment",
                "hotspot",
                "icmpOptions",
                "id",
                "inBridgePort",
                "inBridgePortList",
                "inInterface",
                "inInterfaceList",
                "ingressPriority",
                "invalid",
                "ipsecPolicy",
                "ipv4Options",
                "jumpTarget",
                "layer7Protocol",
                "limit",
                "log",
                "logPrefix",
                "newConnectionMark",
                "newDscp",
                "newMss",
                "newPacketMark",
                "newPriority",
                "newRoutingMark",
                "newTtl",
                "nth",
                "outBridgePort",
                "outBridgePortList",
                "outInterface",
                "outInterfaceList",
                "packetMark",
                "packetSize",
                "packets",
                "passthrough",
                "perConnectionClassifier",
                "port",
                "protocol",
                "psd",
                "random",
                "routeDst",
                "routingMark",
                "srcAddress",
                "srcAddressList",
                "srcAddressType",
                "srcMacAddress",
                "srcPort",
                "tcpFlags",
                "tcpMss",
                "time",
                "tlsHost",
                "ttl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "routeros:Ip/getFirewallNat:getFirewallNat": {
            "properties": {
                "action": {
                    "type": "string"
                },
                "addressList": {
                    "type": "string"
                },
                "addressListTimeout": {
                    "type": "string"
                },
                "bytes": {
                    "type": "integer"
                },
                "chain": {
                    "type": "string"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string"
                },
                "connectionLimit": {
                    "type": "string"
                },
                "connectionMark": {
                    "type": "string"
                },
                "connectionRate": {
                    "type": "string"
                },
                "connectionType": {
                    "type": "string"
                },
                "content": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer"
                },
                "dstAddress": {
                    "type": "string"
                },
                "dstAddressList": {
                    "type": "string"
                },
                "dstAddressType": {
                    "type": "string"
                },
                "dstLimit": {
                    "type": "string"
                },
                "dstPort": {
                    "type": "string"
                },
                "dynamic": {
                    "type": "boolean"
                },
                "filter": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Additional request filtering options.\n"
                },
                "fragment": {
                    "type": "boolean"
                },
                "hotspot": {
                    "type": "string"
                },
                "icmpOptions": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "inBridgePort": {
                    "type": "string"
                },
                "inBridgePortList": {
                    "type": "string"
                },
                "inInterface": {
                    "type": "string"
                },
                "inInterfaceList": {
                    "type": "string"
                },
                "ingressPriority": {
                    "type": "integer"
                },
                "invalid": {
                    "type": "boolean"
                },
                "ipsecPolicy": {
                    "type": "string"
                },
                "ipv4Options": {
                    "type": "string"
                },
                "jumpTarget": {
                    "type": "string"
                },
                "layer7Protocol": {
                    "type": "string"
                },
                "limit": {
                    "type": "string"
                },
                "log": {
                    "type": "boolean"
                },
                "logPrefix": {
                    "type": "string"
                },
                "nth": {
                    "type": "string"
                },
                "outBridgePort": {
                    "type": "string"
                },
                "outBridgePortList": {
                    "type": "string"
                },
                "outInterface": {
                    "type": "string"
                },
                "outInterfaceList": {
                    "type": "string"
                },
                "packetMark": {
                    "type": "string"
                },
                "packetSize": {
                    "type": "string"
                },
                "packets": {
                    "type": "integer"
                },
                "perConnectionClassifier": {
                    "type": "string"
                },
                "port": {
                    "type": "string"
                },
                "priority": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "string"
                },
                "psd": {
                    "type": "string"
                },
                "random": {
                    "type": "integer"
                },
                "routingMark": {
                    "type": "string"
                },
                "sameNotByDst": {
                    "type": "boolean"
                },
                "srcAddress": {
                    "type": "string"
                },
                "srcAddressList": {
                    "type": "string"
                },
                "srcAddressType": {
                    "type": "string"
                },
                "srcMacAddress": {
                    "type": "string"
                },
                "srcPort": {
                    "type": "string"
                },
                "tcpMss": {
                    "type": "string"
                },
                "time": {
                    "type": "string"
                },
                "toAddresses": {
                    "type": "string"
                },
                "toPorts": {
                    "type": "string"
                },
                "ttl": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "action",
                "addressList",
                "addressListTimeout",
                "bytes",
                "chain",
                "comment",
                "connectionBytes",
                "connectionLimit",
                "connectionMark",
                "connectionRate",
                "connectionType",
                "content",
                "disabled",
                "dscp",
                "dstAddress",
                "dstAddressList",
                "dstAddressType",
                "dstLimit",
                "dstPort",
                "dynamic",
                "fragment",
                "hotspot",
                "icmpOptions",
                "id",
                "inBridgePort",
                "inBridgePortList",
                "inInterface",
                "inInterfaceList",
                "ingressPriority",
                "invalid",
                "ipsecPolicy",
                "ipv4Options",
                "jumpTarget",
                "layer7Protocol",
                "limit",
                "log",
                "logPrefix",
                "nth",
                "outBridgePort",
                "outBridgePortList",
                "outInterface",
                "outInterfaceList",
                "packetMark",
                "packetSize",
                "packets",
                "perConnectionClassifier",
                "port",
                "priority",
                "protocol",
                "psd",
                "random",
                "routingMark",
                "sameNotByDst",
                "srcAddress",
                "srcAddressList",
                "srcAddressType",
                "srcMacAddress",
                "srcPort",
                "tcpMss",
                "time",
                "toAddresses",
                "toPorts",
                "ttl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "routeros:Ip/getFirewallRule:getFirewallRule": {
            "properties": {
                "action": {
                    "type": "string"
                },
                "addressListTimeout": {
                    "type": "string"
                },
                "bytes": {
                    "type": "integer"
                },
                "chain": {
                    "type": "string"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string"
                },
                "connectionLimit": {
                    "type": "string"
                },
                "connectionMark": {
                    "type": "string"
                },
                "connectionNatState": {
                    "type": "string"
                },
                "connectionRate": {
                    "type": "string"
                },
                "connectionState": {
                    "type": "string"
                },
                "connectionType": {
                    "type": "string"
                },
                "content": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer"
                },
                "dstAddress": {
                    "type": "string"
                },
                "dstAddressList": {
                    "type": "string"
                },
                "dstAddressType": {
                    "type": "string"
                },
                "dstLimit": {
                    "type": "string"
                },
                "dstPort": {
                    "type": "string"
                },
                "dynamic": {
                    "type": "boolean"
                },
                "filter": {
                    "type": "object",
                    "additionalProperties": {
                        "$ref": "pulumi.json#/Any"
                    },
                    "description": "Additional request filtering options.\n"
                },
                "fragment": {
                    "type": "boolean"
                },
                "hotspot": {
                    "type": "string"
                },
                "hwOffload": {
                    "type": "boolean"
                },
                "icmpOptions": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "inBridgePort": {
                    "type": "string"
                },
                "inBridgePortList": {
                    "type": "string"
                },
                "inInterface": {
                    "type": "string"
                },
                "inInterfaceList": {
                    "type": "string"
                },
                "ingressPriority": {
                    "type": "integer"
                },
                "invalid": {
                    "type": "boolean"
                },
                "ipsecPolicy": {
                    "type": "string"
                },
                "ipv4Options": {
                    "type": "string"
                },
                "jumpTarget": {
                    "type": "string"
                },
                "layer7Protocol": {
                    "type": "string"
                },
                "limit": {
                    "type": "string"
                },
                "log": {
                    "type": "boolean"
                },
                "logPrefix": {
                    "type": "string"
                },
                "nth": {
                    "type": "string"
                },
                "outBridgePort": {
                    "type": "string"
                },
                "outBridgePortList": {
                    "type": "string"
                },
                "outInterface": {
                    "type": "string"
                },
                "outInterfaceList": {
                    "type": "string"
                },
                "packetMark": {
                    "type": "string"
                },
                "packetSize": {
                    "type": "string"
                },
                "packets": {
                    "type": "integer"
                },
                "perConnectionClassifier": {
                    "type": "string"
                },
                "port": {
                    "type": "string"
                },
                "priority": {
                    "type": "integer"
                },
                "protocol": {
                    "type": "string"
                },
                "psd": {
                    "type": "string"
                },
                "random": {
                    "type": "integer"
                },
                "rejectWith": {
                    "type": "string"
                },
                "routingMark": {
                    "type": "string"
                },
                "routingTable": {
                    "type": "string"
                },
                "srcAddress": {
                    "type": "string"
                },
                "srcAddressList": {
                    "type": "string"
                },
                "srcAddressType": {
                    "type": "string"
                },
                "srcMacAddress": {
                    "type": "string"
                },
                "srcPort": {
                    "type": "string"
                },
                "tcpFlags": {
                    "type": "string"
                },
                "tcpMss": {
                    "type": "string"
                },
                "time": {
                    "type": "string"
                },
                "tlsHost": {
                    "type": "string"
                },
                "ttl": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "action",
                "addressListTimeout",
                "bytes",
                "chain",
                "comment",
                "connectionBytes",
                "connectionLimit",
                "connectionMark",
                "connectionNatState",
                "connectionRate",
                "connectionState",
                "connectionType",
                "content",
                "disabled",
                "dscp",
                "dstAddress",
                "dstAddressList",
                "dstAddressType",
                "dstLimit",
                "dstPort",
                "dynamic",
                "fragment",
                "hotspot",
                "hwOffload",
                "icmpOptions",
                "id",
                "inBridgePort",
                "inBridgePortList",
                "inInterface",
                "inInterfaceList",
                "ingressPriority",
                "invalid",
                "ipsecPolicy",
                "ipv4Options",
                "jumpTarget",
                "layer7Protocol",
                "limit",
                "log",
                "logPrefix",
                "nth",
                "outBridgePort",
                "outBridgePortList",
                "outInterface",
                "outInterfaceList",
                "packetMark",
                "packetSize",
                "packets",
                "perConnectionClassifier",
                "port",
                "priority",
                "protocol",
                "psd",
                "random",
                "rejectWith",
                "routingMark",
                "routingTable",
                "srcAddress",
                "srcAddressList",
                "srcAddressType",
                "srcMacAddress",
                "srcPort",
                "tcpFlags",
                "tcpMss",
                "time",
                "tlsHost",
                "ttl"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "routeros:Ip/getRoutesRoute:getRoutesRoute": {
            "properties": {
                "active": {
                    "type": "boolean"
                },
                "blackhole": {
                    "type": "boolean"
                },
                "connect": {
                    "type": "boolean"
                },
                "dhcp": {
                    "type": "boolean"
                },
                "disabled": {
                    "type": "boolean"
                },
                "distance": {
                    "type": "integer"
                },
                "dstAddress": {
                    "type": "string"
                },
                "dynamic": {
                    "type": "boolean"
                },
                "ecmp": {
                    "type": "boolean"
                },
                "gateway": {
                    "type": "string"
                },
                "hwOffloaded": {
                    "type": "boolean"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "immediateGw": {
                    "type": "string"
                },
                "inactive": {
                    "type": "boolean"
                },
                "localAddress": {
                    "type": "string"
                },
                "prefSrc": {
                    "type": "string"
                },
                "routingTable": {
                    "type": "string"
                },
                "scope": {
                    "type": "integer"
                },
                "static": {
                    "type": "boolean"
                },
                "suppressHwOffload": {
                    "type": "boolean"
                },
                "targetScope": {
                    "type": "integer"
                },
                "vrfInterface": {
                    "type": "string"
                }
            },
            "type": "object",
            "required": [
                "active",
                "blackhole",
                "connect",
                "dhcp",
                "disabled",
                "distance",
                "dstAddress",
                "dynamic",
                "ecmp",
                "gateway",
                "hwOffloaded",
                "id",
                "immediateGw",
                "inactive",
                "localAddress",
                "prefSrc",
                "routingTable",
                "scope",
                "static",
                "suppressHwOffload",
                "targetScope",
                "vrfInterface"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "routeros:Ipv6/getIpv6AddressesAddress:getIpv6AddressesAddress": {
            "properties": {
                "actualInterface": {
                    "type": "string"
                },
                "address": {
                    "type": "string"
                },
                "advertise": {
                    "type": "boolean"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean"
                },
                "eui64": {
                    "type": "boolean"
                },
                "fromPool": {
                    "type": "string"
                },
                "id": {
                    "type": "string",
                    "description": "The ID of this resource.\n"
                },
                "interface": {
                    "type": "string"
                },
                "invalid": {
                    "type": "boolean"
                },
                "linkLocal": {
                    "type": "boolean"
                },
                "noDad": {
                    "type": "boolean"
                }
            },
            "type": "object",
            "required": [
                "actualInterface",
                "address",
                "advertise",
                "comment",
                "disabled",
                "dynamic",
                "eui64",
                "fromPool",
                "id",
                "interface",
                "invalid",
                "linkLocal",
                "noDad"
            ],
            "language": {
                "nodejs": {
                    "requiredInputs": []
                }
            }
        },
        "routeros:System/CertificateSign:CertificateSign": {
            "properties": {
                "ca": {
                    "type": "string",
                    "description": "Which CA to use if signing issued certificates.\n"
                },
                "caCrlHost": {
                    "type": "string",
                    "description": "CRL host if issuing CA certificate.\n"
                }
            },
            "type": "object",
            "language": {
                "nodejs": {
                    "requiredOutputs": [
                        "ca",
                        "caCrlHost"
                    ]
                }
            }
        }
    },
    "provider": {
        "description": "The provider type for the routeros package. By default, resources use package-wide configuration\nsettings, however an explicit `Provider` instance may be created and passed during resource\nconstruction to achieve fine-grained programmatic control over provider settings. See the\n[documentation](https://www.pulumi.com/docs/reference/programming-model/#providers) for more information.\n",
        "properties": {
            "caCertificate": {
                "type": "string",
                "description": "Path to MikroTik's certificate authority file.\n",
                "secret": true
            },
            "hosturl": {
                "type": "string",
                "description": "URL of the MikroTik router, default is TLS connection to REST. * API: api[s]://host[:port] * api://router.local *\napis://router.local:8729 * REST: https://host * https://router.local * router.local * 127.0.0.1 export\nROS_HOSTURL=router.local or export MIKROTIK_HOST=router.local\n"
            },
            "insecure": {
                "type": "boolean",
                "description": "Whether to verify the SSL certificate or not.\n"
            },
            "password": {
                "type": "string",
                "description": "Password for the MikroTik user.\n",
                "secret": true
            },
            "username": {
                "type": "string",
                "description": "Username for the MikroTik WEB/Winbox. export ROS_USERNAME=admin or export MIKROTIK_USER=admin\n"
            }
        },
        "inputProperties": {
            "caCertificate": {
                "type": "string",
                "description": "Path to MikroTik's certificate authority file.\n",
                "defaultInfo": {
                    "environment": [
                        "ROS_CA_CERTIFICATE"
                    ]
                },
                "secret": true
            },
            "hosturl": {
                "type": "string",
                "description": "URL of the MikroTik router, default is TLS connection to REST. * API: api[s]://host[:port] * api://router.local *\napis://router.local:8729 * REST: https://host * https://router.local * router.local * 127.0.0.1 export\nROS_HOSTURL=router.local or export MIKROTIK_HOST=router.local\n",
                "defaultInfo": {
                    "environment": [
                        "ROS_HOSTURL"
                    ]
                }
            },
            "insecure": {
                "type": "boolean",
                "description": "Whether to verify the SSL certificate or not.\n",
                "defaultInfo": {
                    "environment": [
                        "ROS_INSECURE"
                    ]
                }
            },
            "password": {
                "type": "string",
                "description": "Password for the MikroTik user.\n",
                "defaultInfo": {
                    "environment": [
                        "ROS_PASSWORD"
                    ]
                },
                "secret": true
            },
            "username": {
                "type": "string",
                "description": "Username for the MikroTik WEB/Winbox. export ROS_USERNAME=admin or export MIKROTIK_USER=admin\n",
                "defaultInfo": {
                    "environment": [
                        "ROS_USERNAME"
                    ]
                }
            }
        }
    },
    "resources": {
        "routeros:CapsMan/aaa:Aaa": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst test3a = new routeros.capsman.Aaa(\"test3a\", {\n    calledFormat: \"ssid\",\n    macMode: \"as-username-and-password\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest3a = routeros.caps_man.Aaa(\"test3a\",\n    called_format=\"ssid\",\n    mac_mode=\"as-username-and-password\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test3a = new Routeros.CapsMan.Aaa(\"test3a\", new()\n    {\n        CalledFormat = \"ssid\",\n        MacMode = \"as-username-and-password\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/CapsMan\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := CapsMan.NewAaa(ctx, \"test3a\", \u0026CapsMan.AaaArgs{\n\t\t\tCalledFormat: pulumi.String(\"ssid\"),\n\t\t\tMacMode:      pulumi.String(\"as-username-and-password\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.CapsMan.Aaa;\nimport com.pulumi.routeros.CapsMan.AaaArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test3a = new Aaa(\"test3a\", AaaArgs.builder()        \n            .calledFormat(\"ssid\")\n            .macMode(\"as-username-and-password\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test3a:\n    type: routeros:CapsMan:Aaa\n    properties:\n      calledFormat: ssid\n      macMode: as-username-and-password\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import routeros:CapsMan/aaa:Aaa test_3a .\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "calledFormat": {
                    "type": "string",
                    "description": "Format of how the 'called-id' identifier will be passed to RADIUS. When configuring radius server clients, you can specify 'called-id' in order to separate multiple entires.\n"
                },
                "interimUpdate": {
                    "type": "string",
                    "description": "When RADIUS accounting is used, Access Point periodically sends accounting information updates to the RADIUS server. This property specifies the default update interval that can be overridden by the RADIUS server using the Acct-Interim-Interval attribute.\n"
                },
                "macCaching": {
                    "type": "string",
                    "description": "If this value is set to a time interval, the Access Point will cache RADIUS MAC authentication responses for a specified time, and will not contact the RADIUS server if matching cache entry already exists. The value disabled will disable the cache, Access Point will always contact the RADIUS server.\n"
                },
                "macFormat": {
                    "type": "string",
                    "description": "Controls how the MAC address of the client is encoded by Access Point in the User-Name attribute of the MAC authentication and MAC accounting RADIUS requests.\n"
                },
                "macMode": {
                    "type": "string",
                    "description": "By default Access Point uses an empty password, when sending Access-Request during MAC authentication. When this property is set to as-username-and-password, Access Point will use the same value for the User-Password attribute as for the User-Name attribute.\n"
                }
            },
            "required": [
                "interimUpdate",
                "macCaching"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "calledFormat": {
                    "type": "string",
                    "description": "Format of how the 'called-id' identifier will be passed to RADIUS. When configuring radius server clients, you can specify 'called-id' in order to separate multiple entires.\n"
                },
                "interimUpdate": {
                    "type": "string",
                    "description": "When RADIUS accounting is used, Access Point periodically sends accounting information updates to the RADIUS server. This property specifies the default update interval that can be overridden by the RADIUS server using the Acct-Interim-Interval attribute.\n"
                },
                "macCaching": {
                    "type": "string",
                    "description": "If this value is set to a time interval, the Access Point will cache RADIUS MAC authentication responses for a specified time, and will not contact the RADIUS server if matching cache entry already exists. The value disabled will disable the cache, Access Point will always contact the RADIUS server.\n"
                },
                "macFormat": {
                    "type": "string",
                    "description": "Controls how the MAC address of the client is encoded by Access Point in the User-Name attribute of the MAC authentication and MAC accounting RADIUS requests.\n"
                },
                "macMode": {
                    "type": "string",
                    "description": "By default Access Point uses an empty password, when sending Access-Request during MAC authentication. When this property is set to as-username-and-password, Access Point will use the same value for the User-Password attribute as for the User-Name attribute.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Aaa resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "calledFormat": {
                        "type": "string",
                        "description": "Format of how the 'called-id' identifier will be passed to RADIUS. When configuring radius server clients, you can specify 'called-id' in order to separate multiple entires.\n"
                    },
                    "interimUpdate": {
                        "type": "string",
                        "description": "When RADIUS accounting is used, Access Point periodically sends accounting information updates to the RADIUS server. This property specifies the default update interval that can be overridden by the RADIUS server using the Acct-Interim-Interval attribute.\n"
                    },
                    "macCaching": {
                        "type": "string",
                        "description": "If this value is set to a time interval, the Access Point will cache RADIUS MAC authentication responses for a specified time, and will not contact the RADIUS server if matching cache entry already exists. The value disabled will disable the cache, Access Point will always contact the RADIUS server.\n"
                    },
                    "macFormat": {
                        "type": "string",
                        "description": "Controls how the MAC address of the client is encoded by Access Point in the User-Name attribute of the MAC authentication and MAC accounting RADIUS requests.\n"
                    },
                    "macMode": {
                        "type": "string",
                        "description": "By default Access Point uses an empty password, when sending Access-Request during MAC authentication. When this property is set to as-username-and-password, Access Point will use the same value for the User-Password attribute as for the User-Name attribute.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:CapsMan/channel:Channel": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst testChannel = new routeros.capsman.Channel(\"testChannel\", {\n    band: \"2ghz-b/g/n\",\n    comment: \"test_channel\",\n    controlChannelWidth: \"10mhz\",\n    extensionChannel: \"eCee\",\n    frequency: 2412,\n    reselectInterval: \"1h\",\n    saveSelected: true,\n    secondaryFrequency: \"disabled\",\n    skipDfsChannels: true,\n    txPower: 20,\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest_channel = routeros.caps_man.Channel(\"testChannel\",\n    band=\"2ghz-b/g/n\",\n    comment=\"test_channel\",\n    control_channel_width=\"10mhz\",\n    extension_channel=\"eCee\",\n    frequency=2412,\n    reselect_interval=\"1h\",\n    save_selected=True,\n    secondary_frequency=\"disabled\",\n    skip_dfs_channels=True,\n    tx_power=20)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testChannel = new Routeros.CapsMan.Channel(\"testChannel\", new()\n    {\n        Band = \"2ghz-b/g/n\",\n        Comment = \"test_channel\",\n        ControlChannelWidth = \"10mhz\",\n        ExtensionChannel = \"eCee\",\n        Frequency = 2412,\n        ReselectInterval = \"1h\",\n        SaveSelected = true,\n        SecondaryFrequency = \"disabled\",\n        SkipDfsChannels = true,\n        TxPower = 20,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/CapsMan\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := CapsMan.NewChannel(ctx, \"testChannel\", \u0026CapsMan.ChannelArgs{\n\t\t\tBand:                pulumi.String(\"2ghz-b/g/n\"),\n\t\t\tComment:             pulumi.String(\"test_channel\"),\n\t\t\tControlChannelWidth: pulumi.String(\"10mhz\"),\n\t\t\tExtensionChannel:    pulumi.String(\"eCee\"),\n\t\t\tFrequency:           pulumi.Int(2412),\n\t\t\tReselectInterval:    pulumi.String(\"1h\"),\n\t\t\tSaveSelected:        pulumi.Bool(true),\n\t\t\tSecondaryFrequency:  pulumi.String(\"disabled\"),\n\t\t\tSkipDfsChannels:     pulumi.Bool(true),\n\t\t\tTxPower:             pulumi.Int(20),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.CapsMan.Channel;\nimport com.pulumi.routeros.CapsMan.ChannelArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testChannel = new Channel(\"testChannel\", ChannelArgs.builder()        \n            .band(\"2ghz-b/g/n\")\n            .comment(\"test_channel\")\n            .controlChannelWidth(\"10mhz\")\n            .extensionChannel(\"eCee\")\n            .frequency(2412)\n            .reselectInterval(\"1h\")\n            .saveSelected(true)\n            .secondaryFrequency(\"disabled\")\n            .skipDfsChannels(true)\n            .txPower(20)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testChannel:\n    type: routeros:CapsMan:Channel\n    properties:\n      band: 2ghz-b/g/n\n      comment: test_channel\n      controlChannelWidth: 10mhz\n      extensionChannel: eCee\n      frequency: 2412\n      reselectInterval: 1h\n      saveSelected: true\n      secondaryFrequency: disabled\n      skipDfsChannels: true\n      txPower: 20\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport with the name of the CAPsMAN channel configuration in case of the example use test-channel-config\n\n```sh\n $ pulumi import routeros:CapsMan/channel:Channel test_channel test-channel-config\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "band": {
                    "type": "string",
                    "description": "Define operational radio frequency band and mode taken from hardware capability of wireless card.\n"
                },
                "comment": {
                    "type": "string"
                },
                "controlChannelWidth": {
                    "type": "string",
                    "description": "Control channel width.\n"
                },
                "extensionChannel": {
                    "type": "string",
                    "description": "Extension channel configuration. (E.g. Ce = extension channel is above Control channel, eC = extension channel is below Control channel)\n"
                },
                "frequency": {
                    "type": "integer",
                    "description": "Channel frequency value in MHz on which AP will operate. If left blank, CAPsMAN will automatically determine the best frequency that is least occupied.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "reselectInterval": {
                    "type": "string",
                    "description": "The interval after which the least occupied frequency is chosen, can be defined as a random interval, ex. as '30m..60m'. Works only if channel.frequency is left blank.\n"
                },
                "saveSelected": {
                    "type": "boolean",
                    "description": "If channel frequency is chosen automatically and channel.reselect-interval is used, then saves the last picked frequency.\n"
                },
                "secondaryFrequency": {
                    "type": "string",
                    "description": "Specifies the second frequency that will be used for 80+80MHz configuration. Set it to Disabled in order to disable 80+80MHz capability.\n"
                },
                "skipDfsChannels": {
                    "type": "boolean",
                    "description": "If channel.frequency is left blank, the selection will skip DFS channels.\n"
                },
                "txPower": {
                    "type": "integer",
                    "description": "TX  Power for CAP interface (for the whole interface not for individual  chains) in dBm. It is not possible to set higher than allowed by country  regulations or interface. By default max allowed by country or  interface is used.\n"
                },
                "width": {
                    "type": "string",
                    "description": "Channel Width in MHz.\n"
                }
            },
            "required": [
                "frequency",
                "name"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "band": {
                    "type": "string",
                    "description": "Define operational radio frequency band and mode taken from hardware capability of wireless card.\n"
                },
                "comment": {
                    "type": "string"
                },
                "controlChannelWidth": {
                    "type": "string",
                    "description": "Control channel width.\n"
                },
                "extensionChannel": {
                    "type": "string",
                    "description": "Extension channel configuration. (E.g. Ce = extension channel is above Control channel, eC = extension channel is below Control channel)\n"
                },
                "frequency": {
                    "type": "integer",
                    "description": "Channel frequency value in MHz on which AP will operate. If left blank, CAPsMAN will automatically determine the best frequency that is least occupied.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "reselectInterval": {
                    "type": "string",
                    "description": "The interval after which the least occupied frequency is chosen, can be defined as a random interval, ex. as '30m..60m'. Works only if channel.frequency is left blank.\n"
                },
                "saveSelected": {
                    "type": "boolean",
                    "description": "If channel frequency is chosen automatically and channel.reselect-interval is used, then saves the last picked frequency.\n"
                },
                "secondaryFrequency": {
                    "type": "string",
                    "description": "Specifies the second frequency that will be used for 80+80MHz configuration. Set it to Disabled in order to disable 80+80MHz capability.\n"
                },
                "skipDfsChannels": {
                    "type": "boolean",
                    "description": "If channel.frequency is left blank, the selection will skip DFS channels.\n"
                },
                "txPower": {
                    "type": "integer",
                    "description": "TX  Power for CAP interface (for the whole interface not for individual  chains) in dBm. It is not possible to set higher than allowed by country  regulations or interface. By default max allowed by country or  interface is used.\n"
                },
                "width": {
                    "type": "string",
                    "description": "Channel Width in MHz.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Channel resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "band": {
                        "type": "string",
                        "description": "Define operational radio frequency band and mode taken from hardware capability of wireless card.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "controlChannelWidth": {
                        "type": "string",
                        "description": "Control channel width.\n"
                    },
                    "extensionChannel": {
                        "type": "string",
                        "description": "Extension channel configuration. (E.g. Ce = extension channel is above Control channel, eC = extension channel is below Control channel)\n"
                    },
                    "frequency": {
                        "type": "integer",
                        "description": "Channel frequency value in MHz on which AP will operate. If left blank, CAPsMAN will automatically determine the best frequency that is least occupied.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "reselectInterval": {
                        "type": "string",
                        "description": "The interval after which the least occupied frequency is chosen, can be defined as a random interval, ex. as '30m..60m'. Works only if channel.frequency is left blank.\n"
                    },
                    "saveSelected": {
                        "type": "boolean",
                        "description": "If channel frequency is chosen automatically and channel.reselect-interval is used, then saves the last picked frequency.\n"
                    },
                    "secondaryFrequency": {
                        "type": "string",
                        "description": "Specifies the second frequency that will be used for 80+80MHz configuration. Set it to Disabled in order to disable 80+80MHz capability.\n"
                    },
                    "skipDfsChannels": {
                        "type": "boolean",
                        "description": "If channel.frequency is left blank, the selection will skip DFS channels.\n"
                    },
                    "txPower": {
                        "type": "integer",
                        "description": "TX  Power for CAP interface (for the whole interface not for individual  chains) in dBm. It is not possible to set higher than allowed by country  regulations or interface. By default max allowed by country or  interface is used.\n"
                    },
                    "width": {
                        "type": "string",
                        "description": "Channel Width in MHz.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:CapsMan/configuration:Configuration": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst testConfiguration = new routeros.capsman.Configuration(\"testConfiguration\", {\n    comment: \"Comment\",\n    country: \"no_country_set\",\n    disconnectTimeout: \"1s150ms\",\n    distance: \"indoors\",\n    frameLifetime: \"0.12\",\n    guardInterval: \"long\",\n    hideSsid: true,\n    hwProtectionMode: \"rts-cts\",\n    hwRetries: 1,\n    installation: \"indoor\",\n    keepaliveFrames: \"enabled\",\n    loadBalancingGroup: \"\",\n    maxStaCount: 1,\n    mode: \"ap\",\n    multicastHelper: \"full\",\n    rxChains: [\n        1,\n        3,\n    ],\n    ssid: \"SSID\",\n    txChains: [\n        0,\n        2,\n    ],\n});\nconst testChannel = new routeros.capsman.Channel(\"testChannel\", {});\nconst testDatapath = new routeros.capsman.Datapath(\"testDatapath\", {});\nconst testRates = new routeros.capsman.Rates(\"testRates\", {});\nconst testSecurity = new routeros.capsman.Security(\"testSecurity\", {});\nconst testConfiguration2 = new routeros.capsman.Configuration(\"testConfiguration2\", {\n    channel: {\n        config: testChannel.name,\n        band: \"2ghz-b/g/n\",\n        control_channel_width: \"10mhz\",\n        extension_channel: \"eCee\",\n        frequency: \"2412\",\n        reselect_interval: \"1h\",\n        save_selected: \"true\",\n        secondary_frequency: \"disabled\",\n        skip_dfs_channels: \"true\",\n        tx_power: \"20\",\n    },\n    datapath: {\n        config: testDatapath.name,\n        arp: \"local-proxy-arp\",\n        bridge: \"bridge\",\n        bridge_cost: \"100\",\n        bridge_horizon: \"200\",\n        client_to_client_forwarding: \"true\",\n        interface_list: \"static\",\n        l2mtu: \"1450\",\n        local_forwarding: \"true\",\n        mtu: \"1500\",\n        vlan_id: \"101\",\n        vlan_mode: \"no-tag\",\n    },\n    rates: {\n        config: testRates.name,\n        basic: \"1Mbps,5.5Mbps,6Mbps,18Mbps,36Mbps,54Mbps\",\n        ht_basic_mcs: \"mcs-0,mcs-7,mcs-11,mcs-14,mcs-16,mcs-21\",\n        ht_supported_mcs: \"mcs-3,mcs-8,mcs-10,mcs-13,mcs-17,mcs-18\",\n        supported: \"2Mbps,11Mbps,9Mbps,12Mbps,24Mbps,48Mbps\",\n        vht_basic_mcs: \"none\",\n        vht_supported_mcs: \"mcs0-9,mcs0-7\",\n    },\n    security: {\n        config: testSecurity.name,\n        authentication_types: \"wpa-psk,wpa-eap\",\n        disable_pmkid: \"true\",\n        eap_methods: \"eap-tls,passthrough\",\n        eap_radius_accounting: \"true\",\n        encryption: \"aes-ccm,tkip\",\n        group_encryption: \"aes-ccm\",\n        group_key_update: \"1h\",\n        passphrase: \"AAAAAAAAA\",\n        tls_certificate: \"none\",\n        tls_mode: \"verify-certificate\",\n    },\n}, {\n    dependsOn: [\n        testChannel,\n        testDatapath,\n        testRates,\n        testSecurity,\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest_configuration = routeros.caps_man.Configuration(\"testConfiguration\",\n    comment=\"Comment\",\n    country=\"no_country_set\",\n    disconnect_timeout=\"1s150ms\",\n    distance=\"indoors\",\n    frame_lifetime=\"0.12\",\n    guard_interval=\"long\",\n    hide_ssid=True,\n    hw_protection_mode=\"rts-cts\",\n    hw_retries=1,\n    installation=\"indoor\",\n    keepalive_frames=\"enabled\",\n    load_balancing_group=\"\",\n    max_sta_count=1,\n    mode=\"ap\",\n    multicast_helper=\"full\",\n    rx_chains=[\n        1,\n        3,\n    ],\n    ssid=\"SSID\",\n    tx_chains=[\n        0,\n        2,\n    ])\ntest_channel = routeros.caps_man.Channel(\"testChannel\")\ntest_datapath = routeros.caps_man.Datapath(\"testDatapath\")\ntest_rates = routeros.caps_man.Rates(\"testRates\")\ntest_security = routeros.caps_man.Security(\"testSecurity\")\ntest_configuration2 = routeros.caps_man.Configuration(\"testConfiguration2\",\n    channel={\n        \"config\": test_channel.name,\n        \"band\": \"2ghz-b/g/n\",\n        \"control_channel_width\": \"10mhz\",\n        \"extension_channel\": \"eCee\",\n        \"frequency\": \"2412\",\n        \"reselect_interval\": \"1h\",\n        \"save_selected\": \"true\",\n        \"secondary_frequency\": \"disabled\",\n        \"skip_dfs_channels\": \"true\",\n        \"tx_power\": \"20\",\n    },\n    datapath={\n        \"config\": test_datapath.name,\n        \"arp\": \"local-proxy-arp\",\n        \"bridge\": \"bridge\",\n        \"bridge_cost\": \"100\",\n        \"bridge_horizon\": \"200\",\n        \"client_to_client_forwarding\": \"true\",\n        \"interface_list\": \"static\",\n        \"l2mtu\": \"1450\",\n        \"local_forwarding\": \"true\",\n        \"mtu\": \"1500\",\n        \"vlan_id\": \"101\",\n        \"vlan_mode\": \"no-tag\",\n    },\n    rates={\n        \"config\": test_rates.name,\n        \"basic\": \"1Mbps,5.5Mbps,6Mbps,18Mbps,36Mbps,54Mbps\",\n        \"ht_basic_mcs\": \"mcs-0,mcs-7,mcs-11,mcs-14,mcs-16,mcs-21\",\n        \"ht_supported_mcs\": \"mcs-3,mcs-8,mcs-10,mcs-13,mcs-17,mcs-18\",\n        \"supported\": \"2Mbps,11Mbps,9Mbps,12Mbps,24Mbps,48Mbps\",\n        \"vht_basic_mcs\": \"none\",\n        \"vht_supported_mcs\": \"mcs0-9,mcs0-7\",\n    },\n    security={\n        \"config\": test_security.name,\n        \"authentication_types\": \"wpa-psk,wpa-eap\",\n        \"disable_pmkid\": \"true\",\n        \"eap_methods\": \"eap-tls,passthrough\",\n        \"eap_radius_accounting\": \"true\",\n        \"encryption\": \"aes-ccm,tkip\",\n        \"group_encryption\": \"aes-ccm\",\n        \"group_key_update\": \"1h\",\n        \"passphrase\": \"AAAAAAAAA\",\n        \"tls_certificate\": \"none\",\n        \"tls_mode\": \"verify-certificate\",\n    },\n    opts=pulumi.ResourceOptions(depends_on=[\n            test_channel,\n            test_datapath,\n            test_rates,\n            test_security,\n        ]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testConfiguration = new Routeros.CapsMan.Configuration(\"testConfiguration\", new()\n    {\n        Comment = \"Comment\",\n        Country = \"no_country_set\",\n        DisconnectTimeout = \"1s150ms\",\n        Distance = \"indoors\",\n        FrameLifetime = \"0.12\",\n        GuardInterval = \"long\",\n        HideSsid = true,\n        HwProtectionMode = \"rts-cts\",\n        HwRetries = 1,\n        Installation = \"indoor\",\n        KeepaliveFrames = \"enabled\",\n        LoadBalancingGroup = \"\",\n        MaxStaCount = 1,\n        Mode = \"ap\",\n        MulticastHelper = \"full\",\n        RxChains = new[]\n        {\n            1,\n            3,\n        },\n        Ssid = \"SSID\",\n        TxChains = new[]\n        {\n            0,\n            2,\n        },\n    });\n\n    var testChannel = new Routeros.CapsMan.Channel(\"testChannel\");\n\n    var testDatapath = new Routeros.CapsMan.Datapath(\"testDatapath\");\n\n    var testRates = new Routeros.CapsMan.Rates(\"testRates\");\n\n    var testSecurity = new Routeros.CapsMan.Security(\"testSecurity\");\n\n    var testConfiguration2 = new Routeros.CapsMan.Configuration(\"testConfiguration2\", new()\n    {\n        Channel = \n        {\n            { \"config\", testChannel.Name },\n            { \"band\", \"2ghz-b/g/n\" },\n            { \"control_channel_width\", \"10mhz\" },\n            { \"extension_channel\", \"eCee\" },\n            { \"frequency\", \"2412\" },\n            { \"reselect_interval\", \"1h\" },\n            { \"save_selected\", \"true\" },\n            { \"secondary_frequency\", \"disabled\" },\n            { \"skip_dfs_channels\", \"true\" },\n            { \"tx_power\", \"20\" },\n        },\n        Datapath = \n        {\n            { \"config\", testDatapath.Name },\n            { \"arp\", \"local-proxy-arp\" },\n            { \"bridge\", \"bridge\" },\n            { \"bridge_cost\", \"100\" },\n            { \"bridge_horizon\", \"200\" },\n            { \"client_to_client_forwarding\", \"true\" },\n            { \"interface_list\", \"static\" },\n            { \"l2mtu\", \"1450\" },\n            { \"local_forwarding\", \"true\" },\n            { \"mtu\", \"1500\" },\n            { \"vlan_id\", \"101\" },\n            { \"vlan_mode\", \"no-tag\" },\n        },\n        Rates = \n        {\n            { \"config\", testRates.Name },\n            { \"basic\", \"1Mbps,5.5Mbps,6Mbps,18Mbps,36Mbps,54Mbps\" },\n            { \"ht_basic_mcs\", \"mcs-0,mcs-7,mcs-11,mcs-14,mcs-16,mcs-21\" },\n            { \"ht_supported_mcs\", \"mcs-3,mcs-8,mcs-10,mcs-13,mcs-17,mcs-18\" },\n            { \"supported\", \"2Mbps,11Mbps,9Mbps,12Mbps,24Mbps,48Mbps\" },\n            { \"vht_basic_mcs\", \"none\" },\n            { \"vht_supported_mcs\", \"mcs0-9,mcs0-7\" },\n        },\n        Security = \n        {\n            { \"config\", testSecurity.Name },\n            { \"authentication_types\", \"wpa-psk,wpa-eap\" },\n            { \"disable_pmkid\", \"true\" },\n            { \"eap_methods\", \"eap-tls,passthrough\" },\n            { \"eap_radius_accounting\", \"true\" },\n            { \"encryption\", \"aes-ccm,tkip\" },\n            { \"group_encryption\", \"aes-ccm\" },\n            { \"group_key_update\", \"1h\" },\n            { \"passphrase\", \"AAAAAAAAA\" },\n            { \"tls_certificate\", \"none\" },\n            { \"tls_mode\", \"verify-certificate\" },\n        },\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            testChannel,\n            testDatapath,\n            testRates,\n            testSecurity,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/CapsMan\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := CapsMan.NewConfiguration(ctx, \"testConfiguration\", \u0026CapsMan.ConfigurationArgs{\n\t\t\tComment:            pulumi.String(\"Comment\"),\n\t\t\tCountry:            pulumi.String(\"no_country_set\"),\n\t\t\tDisconnectTimeout:  pulumi.String(\"1s150ms\"),\n\t\t\tDistance:           pulumi.String(\"indoors\"),\n\t\t\tFrameLifetime:      pulumi.String(\"0.12\"),\n\t\t\tGuardInterval:      pulumi.String(\"long\"),\n\t\t\tHideSsid:           pulumi.Bool(true),\n\t\t\tHwProtectionMode:   pulumi.String(\"rts-cts\"),\n\t\t\tHwRetries:          pulumi.Int(1),\n\t\t\tInstallation:       pulumi.String(\"indoor\"),\n\t\t\tKeepaliveFrames:    pulumi.String(\"enabled\"),\n\t\t\tLoadBalancingGroup: pulumi.String(\"\"),\n\t\t\tMaxStaCount:        pulumi.Int(1),\n\t\t\tMode:               pulumi.String(\"ap\"),\n\t\t\tMulticastHelper:    pulumi.String(\"full\"),\n\t\t\tRxChains: pulumi.IntArray{\n\t\t\t\tpulumi.Int(1),\n\t\t\t\tpulumi.Int(3),\n\t\t\t},\n\t\t\tSsid: pulumi.String(\"SSID\"),\n\t\t\tTxChains: pulumi.IntArray{\n\t\t\t\tpulumi.Int(0),\n\t\t\t\tpulumi.Int(2),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestChannel, err := CapsMan.NewChannel(ctx, \"testChannel\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestDatapath, err := CapsMan.NewDatapath(ctx, \"testDatapath\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestRates, err := CapsMan.NewRates(ctx, \"testRates\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestSecurity, err := CapsMan.NewSecurity(ctx, \"testSecurity\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = CapsMan.NewConfiguration(ctx, \"testConfiguration2\", \u0026CapsMan.ConfigurationArgs{\n\t\t\tChannel: pulumi.StringMap{\n\t\t\t\t\"config\":                testChannel.Name,\n\t\t\t\t\"band\":                  pulumi.String(\"2ghz-b/g/n\"),\n\t\t\t\t\"control_channel_width\": pulumi.String(\"10mhz\"),\n\t\t\t\t\"extension_channel\":     pulumi.String(\"eCee\"),\n\t\t\t\t\"frequency\":             pulumi.String(\"2412\"),\n\t\t\t\t\"reselect_interval\":     pulumi.String(\"1h\"),\n\t\t\t\t\"save_selected\":         pulumi.String(\"true\"),\n\t\t\t\t\"secondary_frequency\":   pulumi.String(\"disabled\"),\n\t\t\t\t\"skip_dfs_channels\":     pulumi.String(\"true\"),\n\t\t\t\t\"tx_power\":              pulumi.String(\"20\"),\n\t\t\t},\n\t\t\tDatapath: pulumi.StringMap{\n\t\t\t\t\"config\":                      testDatapath.Name,\n\t\t\t\t\"arp\":                         pulumi.String(\"local-proxy-arp\"),\n\t\t\t\t\"bridge\":                      pulumi.String(\"bridge\"),\n\t\t\t\t\"bridge_cost\":                 pulumi.String(\"100\"),\n\t\t\t\t\"bridge_horizon\":              pulumi.String(\"200\"),\n\t\t\t\t\"client_to_client_forwarding\": pulumi.String(\"true\"),\n\t\t\t\t\"interface_list\":              pulumi.String(\"static\"),\n\t\t\t\t\"l2mtu\":                       pulumi.String(\"1450\"),\n\t\t\t\t\"local_forwarding\":            pulumi.String(\"true\"),\n\t\t\t\t\"mtu\":                         pulumi.String(\"1500\"),\n\t\t\t\t\"vlan_id\":                     pulumi.String(\"101\"),\n\t\t\t\t\"vlan_mode\":                   pulumi.String(\"no-tag\"),\n\t\t\t},\n\t\t\tRates: pulumi.StringMap{\n\t\t\t\t\"config\":            testRates.Name,\n\t\t\t\t\"basic\":             pulumi.String(\"1Mbps,5.5Mbps,6Mbps,18Mbps,36Mbps,54Mbps\"),\n\t\t\t\t\"ht_basic_mcs\":      pulumi.String(\"mcs-0,mcs-7,mcs-11,mcs-14,mcs-16,mcs-21\"),\n\t\t\t\t\"ht_supported_mcs\":  pulumi.String(\"mcs-3,mcs-8,mcs-10,mcs-13,mcs-17,mcs-18\"),\n\t\t\t\t\"supported\":         pulumi.String(\"2Mbps,11Mbps,9Mbps,12Mbps,24Mbps,48Mbps\"),\n\t\t\t\t\"vht_basic_mcs\":     pulumi.String(\"none\"),\n\t\t\t\t\"vht_supported_mcs\": pulumi.String(\"mcs0-9,mcs0-7\"),\n\t\t\t},\n\t\t\tSecurity: pulumi.StringMap{\n\t\t\t\t\"config\":                testSecurity.Name,\n\t\t\t\t\"authentication_types\":  pulumi.String(\"wpa-psk,wpa-eap\"),\n\t\t\t\t\"disable_pmkid\":         pulumi.String(\"true\"),\n\t\t\t\t\"eap_methods\":           pulumi.String(\"eap-tls,passthrough\"),\n\t\t\t\t\"eap_radius_accounting\": pulumi.String(\"true\"),\n\t\t\t\t\"encryption\":            pulumi.String(\"aes-ccm,tkip\"),\n\t\t\t\t\"group_encryption\":      pulumi.String(\"aes-ccm\"),\n\t\t\t\t\"group_key_update\":      pulumi.String(\"1h\"),\n\t\t\t\t\"passphrase\":            pulumi.String(\"AAAAAAAAA\"),\n\t\t\t\t\"tls_certificate\":       pulumi.String(\"none\"),\n\t\t\t\t\"tls_mode\":              pulumi.String(\"verify-certificate\"),\n\t\t\t},\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\ttestChannel,\n\t\t\ttestDatapath,\n\t\t\ttestRates,\n\t\t\ttestSecurity,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.CapsMan.Configuration;\nimport com.pulumi.routeros.CapsMan.ConfigurationArgs;\nimport com.pulumi.routeros.CapsMan.Channel;\nimport com.pulumi.routeros.CapsMan.Datapath;\nimport com.pulumi.routeros.CapsMan.Rates;\nimport com.pulumi.routeros.CapsMan.Security;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testConfiguration = new Configuration(\"testConfiguration\", ConfigurationArgs.builder()        \n            .comment(\"Comment\")\n            .country(\"no_country_set\")\n            .disconnectTimeout(\"1s150ms\")\n            .distance(\"indoors\")\n            .frameLifetime(\"0.12\")\n            .guardInterval(\"long\")\n            .hideSsid(true)\n            .hwProtectionMode(\"rts-cts\")\n            .hwRetries(1)\n            .installation(\"indoor\")\n            .keepaliveFrames(\"enabled\")\n            .loadBalancingGroup(\"\")\n            .maxStaCount(1)\n            .mode(\"ap\")\n            .multicastHelper(\"full\")\n            .rxChains(            \n                1,\n                3)\n            .ssid(\"SSID\")\n            .txChains(            \n                0,\n                2)\n            .build());\n\n        var testChannel = new Channel(\"testChannel\");\n\n        var testDatapath = new Datapath(\"testDatapath\");\n\n        var testRates = new Rates(\"testRates\");\n\n        var testSecurity = new Security(\"testSecurity\");\n\n        var testConfiguration2 = new Configuration(\"testConfiguration2\", ConfigurationArgs.builder()        \n            .channel(Map.ofEntries(\n                Map.entry(\"config\", testChannel.name()),\n                Map.entry(\"band\", \"2ghz-b/g/n\"),\n                Map.entry(\"control_channel_width\", \"10mhz\"),\n                Map.entry(\"extension_channel\", \"eCee\"),\n                Map.entry(\"frequency\", 2412),\n                Map.entry(\"reselect_interval\", \"1h\"),\n                Map.entry(\"save_selected\", \"true\"),\n                Map.entry(\"secondary_frequency\", \"disabled\"),\n                Map.entry(\"skip_dfs_channels\", \"true\"),\n                Map.entry(\"tx_power\", 20)\n            ))\n            .datapath(Map.ofEntries(\n                Map.entry(\"config\", testDatapath.name()),\n                Map.entry(\"arp\", \"local-proxy-arp\"),\n                Map.entry(\"bridge\", \"bridge\"),\n                Map.entry(\"bridge_cost\", \"100\"),\n                Map.entry(\"bridge_horizon\", \"200\"),\n                Map.entry(\"client_to_client_forwarding\", \"true\"),\n                Map.entry(\"interface_list\", \"static\"),\n                Map.entry(\"l2mtu\", \"1450\"),\n                Map.entry(\"local_forwarding\", \"true\"),\n                Map.entry(\"mtu\", \"1500\"),\n                Map.entry(\"vlan_id\", \"101\"),\n                Map.entry(\"vlan_mode\", \"no-tag\")\n            ))\n            .rates(Map.ofEntries(\n                Map.entry(\"config\", testRates.name()),\n                Map.entry(\"basic\", \"1Mbps,5.5Mbps,6Mbps,18Mbps,36Mbps,54Mbps\"),\n                Map.entry(\"ht_basic_mcs\", \"mcs-0,mcs-7,mcs-11,mcs-14,mcs-16,mcs-21\"),\n                Map.entry(\"ht_supported_mcs\", \"mcs-3,mcs-8,mcs-10,mcs-13,mcs-17,mcs-18\"),\n                Map.entry(\"supported\", \"2Mbps,11Mbps,9Mbps,12Mbps,24Mbps,48Mbps\"),\n                Map.entry(\"vht_basic_mcs\", \"none\"),\n                Map.entry(\"vht_supported_mcs\", \"mcs0-9,mcs0-7\")\n            ))\n            .security(Map.ofEntries(\n                Map.entry(\"config\", testSecurity.name()),\n                Map.entry(\"authentication_types\", \"wpa-psk,wpa-eap\"),\n                Map.entry(\"disable_pmkid\", \"true\"),\n                Map.entry(\"eap_methods\", \"eap-tls,passthrough\"),\n                Map.entry(\"eap_radius_accounting\", \"true\"),\n                Map.entry(\"encryption\", \"aes-ccm,tkip\"),\n                Map.entry(\"group_encryption\", \"aes-ccm\"),\n                Map.entry(\"group_key_update\", \"1h\"),\n                Map.entry(\"passphrase\", \"AAAAAAAAA\"),\n                Map.entry(\"tls_certificate\", \"none\"),\n                Map.entry(\"tls_mode\", \"verify-certificate\")\n            ))\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(                \n                    testChannel,\n                    testDatapath,\n                    testRates,\n                    testSecurity)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testConfiguration:\n    type: routeros:CapsMan:Configuration\n    properties:\n      comment: Comment\n      country: no_country_set\n      disconnectTimeout: 1s150ms\n      distance: indoors\n      frameLifetime: '0.12'\n      # 120ms\n      guardInterval: long\n      hideSsid: true\n      hwProtectionMode: rts-cts\n      hwRetries: 1\n      installation: indoor\n      keepaliveFrames: enabled\n      loadBalancingGroup:\n      maxStaCount: 1\n      mode: ap\n      multicastHelper: full\n      rxChains:\n        - 1\n        - 3\n      ssid: SSID\n      txChains:\n        - 0\n        - 2\n  testChannel:\n    type: routeros:CapsMan:Channel\n  testDatapath:\n    type: routeros:CapsMan:Datapath\n  testRates:\n    type: routeros:CapsMan:Rates\n  testSecurity:\n    type: routeros:CapsMan:Security\n  testConfiguration2:\n    type: routeros:CapsMan:Configuration\n    properties:\n      channel:\n        config: ${testChannel.name}\n        band: 2ghz-b/g/n\n        control_channel_width: 10mhz\n        extension_channel: eCee\n        frequency: 2412\n        reselect_interval: 1h\n        save_selected: 'true'\n        secondary_frequency: disabled\n        skip_dfs_channels: 'true'\n        tx_power: 20\n      datapath:\n        config: ${testDatapath.name}\n        arp: local-proxy-arp\n        bridge: bridge\n        bridge_cost: '100'\n        bridge_horizon: '200'\n        client_to_client_forwarding: 'true'\n        interface_list: static\n        l2mtu: '1450'\n        local_forwarding: 'true'\n        mtu: '1500'\n        vlan_id: '101'\n        vlan_mode: no-tag\n      rates:\n        config: ${testRates.name}\n        basic: 1Mbps,5.5Mbps,6Mbps,18Mbps,36Mbps,54Mbps\n        ht_basic_mcs: mcs-0,mcs-7,mcs-11,mcs-14,mcs-16,mcs-21\n        ht_supported_mcs: mcs-3,mcs-8,mcs-10,mcs-13,mcs-17,mcs-18\n        supported: 2Mbps,11Mbps,9Mbps,12Mbps,24Mbps,48Mbps\n        vht_basic_mcs: none\n        vht_supported_mcs: mcs0-9,mcs0-7\n      security:\n        config: ${testSecurity.name}\n        authentication_types: wpa-psk,wpa-eap\n        disable_pmkid: 'true'\n        eap_methods: eap-tls,passthrough\n        eap_radius_accounting: 'true'\n        encryption: aes-ccm,tkip\n        group_encryption: aes-ccm\n        group_key_update: 1h\n        passphrase: AAAAAAAAA\n        tls_certificate: none\n        tls_mode: verify-certificate\n    options:\n      dependson:\n        - ${testChannel}\n        - ${testDatapath}\n        - ${testRates}\n        - ${testSecurity}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport with the name of the CAPsMAN configuration in case of the example use test_configuration_name\n\n```sh\n $ pulumi import routeros:CapsMan/configuration:Configuration test_configuration_2 test_configuration_name\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___ts_": {
                    "type": "string",
                    "description": "\u003cem\u003eA set of transformations for field names. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "channel": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Channel inline settings.\n"
                },
                "comment": {
                    "type": "string"
                },
                "country": {
                    "type": "string",
                    "description": "Limits available bands, frequencies and maximum transmit power for each frequency. Also specifies default value of scan-list. Value no*country*set is an FCC compliant set of channels.\n"
                },
                "datapath": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Datapath inline settings.\n"
                },
                "disconnectTimeout": {
                    "type": "string",
                    "description": "This interval is measured from third sending failure on the lowest data rate. At this point 3 * (hw-retries + 1) frame transmits on the lowest data rate had failed. During disconnect-timeout packet transmission will be retried with on-fail-retry-time interval. If no frame can be transmitted successfully during disconnect-timeout, the connection is closed, and this event is logged as \"extensive data loss\". Successful frame transmission resets this timer.\n"
                },
                "distance": {
                    "type": "string",
                    "description": "How long to wait for confirmation of unicast frames (ACKs) before considering transmission unsuccessful, or in short ACK-Timeout.\n"
                },
                "frameLifetime": {
                    "type": "string",
                    "description": "Discard frames that have been queued for sending longer than frame-lifetime. By default, when value of this property is 0, frames are discarded only after connection is closed (format: 0.00 sec).\n"
                },
                "guardInterval": {
                    "type": "string",
                    "description": "Whether to allow use of short guard interval (refer to 802.11n MCS specification to see how this may affect throughput). \"any\" will use either short or long, depending on data rate, \"long\" will use long.\n"
                },
                "hideSsid": {
                    "type": "boolean",
                    "description": "This property has effect only in AP mode. Setting it to yes can remove this network from the list of wireless networks that are shown by some client software. Changing this setting does not improve the security of the wireless network, because SSID is included in other frames sent by the AP.\n"
                },
                "hwProtectionMode": {
                    "type": "string",
                    "description": "Frame protection support property. [See docs](https://wiki.mikrotik.com/wiki/Manual:Interface/Wireless#Frame_protection_support_(RTS/CTS)).\n"
                },
                "hwRetries": {
                    "type": "integer",
                    "description": "Number of times sending frame is retried without considering it a transmission failure. [See docs](https://wiki.mikrotik.com/wiki/Manual:Interface/Wireless)\n"
                },
                "installation": {
                    "type": "string",
                    "description": "Adjusts scan-list to use indoor, outdoor or all frequencies for the country that is set.\n"
                },
                "keepaliveFrames": {
                    "type": "string",
                    "description": "If a client has not communicated for around 20 seconds, AP sends a \"keepalive-frame\".\n"
                },
                "loadBalancingGroup": {
                    "type": "string",
                    "description": "Tags the interface to the load balancing group. For a client to connect to interface in this group, the interface should have the same number of already connected clients as all other interfaces in the group or smaller. Useful in setups where ranges of CAPs mostly overlap.\n"
                },
                "maxStaCount": {
                    "type": "integer",
                    "description": "Maximum number of associated clients.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Set operational mode. Only **ap** currently supported.\n"
                },
                "multicastHelper": {
                    "type": "string",
                    "description": "When set to full multicast packets will be sent with unicast destination MAC address, resolving multicast problem on a wireless link. This option should be enabled only on the access point, clients should be configured in station-bridge mode.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "rates": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Rates inline settings.\n"
                },
                "rxChains": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Which antennas to use for receive.\n"
                },
                "security": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Security inline settings.\n"
                },
                "ssid": {
                    "type": "string",
                    "description": "SSID (service set identifier) is a name broadcast in the beacons that identifies wireless network.\n"
                },
                "txChains": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Which antennas to use for transmit.\n"
                }
            },
            "required": [
                "hideSsid",
                "name"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___ts_": {
                    "type": "string",
                    "description": "\u003cem\u003eA set of transformations for field names. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "channel": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Channel inline settings.\n"
                },
                "comment": {
                    "type": "string"
                },
                "country": {
                    "type": "string",
                    "description": "Limits available bands, frequencies and maximum transmit power for each frequency. Also specifies default value of scan-list. Value no*country*set is an FCC compliant set of channels.\n"
                },
                "datapath": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Datapath inline settings.\n"
                },
                "disconnectTimeout": {
                    "type": "string",
                    "description": "This interval is measured from third sending failure on the lowest data rate. At this point 3 * (hw-retries + 1) frame transmits on the lowest data rate had failed. During disconnect-timeout packet transmission will be retried with on-fail-retry-time interval. If no frame can be transmitted successfully during disconnect-timeout, the connection is closed, and this event is logged as \"extensive data loss\". Successful frame transmission resets this timer.\n"
                },
                "distance": {
                    "type": "string",
                    "description": "How long to wait for confirmation of unicast frames (ACKs) before considering transmission unsuccessful, or in short ACK-Timeout.\n"
                },
                "frameLifetime": {
                    "type": "string",
                    "description": "Discard frames that have been queued for sending longer than frame-lifetime. By default, when value of this property is 0, frames are discarded only after connection is closed (format: 0.00 sec).\n"
                },
                "guardInterval": {
                    "type": "string",
                    "description": "Whether to allow use of short guard interval (refer to 802.11n MCS specification to see how this may affect throughput). \"any\" will use either short or long, depending on data rate, \"long\" will use long.\n"
                },
                "hideSsid": {
                    "type": "boolean",
                    "description": "This property has effect only in AP mode. Setting it to yes can remove this network from the list of wireless networks that are shown by some client software. Changing this setting does not improve the security of the wireless network, because SSID is included in other frames sent by the AP.\n"
                },
                "hwProtectionMode": {
                    "type": "string",
                    "description": "Frame protection support property. [See docs](https://wiki.mikrotik.com/wiki/Manual:Interface/Wireless#Frame_protection_support_(RTS/CTS)).\n"
                },
                "hwRetries": {
                    "type": "integer",
                    "description": "Number of times sending frame is retried without considering it a transmission failure. [See docs](https://wiki.mikrotik.com/wiki/Manual:Interface/Wireless)\n"
                },
                "installation": {
                    "type": "string",
                    "description": "Adjusts scan-list to use indoor, outdoor or all frequencies for the country that is set.\n"
                },
                "keepaliveFrames": {
                    "type": "string",
                    "description": "If a client has not communicated for around 20 seconds, AP sends a \"keepalive-frame\".\n"
                },
                "loadBalancingGroup": {
                    "type": "string",
                    "description": "Tags the interface to the load balancing group. For a client to connect to interface in this group, the interface should have the same number of already connected clients as all other interfaces in the group or smaller. Useful in setups where ranges of CAPs mostly overlap.\n"
                },
                "maxStaCount": {
                    "type": "integer",
                    "description": "Maximum number of associated clients.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Set operational mode. Only **ap** currently supported.\n"
                },
                "multicastHelper": {
                    "type": "string",
                    "description": "When set to full multicast packets will be sent with unicast destination MAC address, resolving multicast problem on a wireless link. This option should be enabled only on the access point, clients should be configured in station-bridge mode.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "rates": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Rates inline settings.\n"
                },
                "rxChains": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Which antennas to use for receive.\n"
                },
                "security": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    },
                    "description": "Security inline settings.\n"
                },
                "ssid": {
                    "type": "string",
                    "description": "SSID (service set identifier) is a name broadcast in the beacons that identifies wireless network.\n"
                },
                "txChains": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    },
                    "description": "Which antennas to use for transmit.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Configuration resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___ts_": {
                        "type": "string",
                        "description": "\u003cem\u003eA set of transformations for field names. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "channel": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Channel inline settings.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "country": {
                        "type": "string",
                        "description": "Limits available bands, frequencies and maximum transmit power for each frequency. Also specifies default value of scan-list. Value no*country*set is an FCC compliant set of channels.\n"
                    },
                    "datapath": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Datapath inline settings.\n"
                    },
                    "disconnectTimeout": {
                        "type": "string",
                        "description": "This interval is measured from third sending failure on the lowest data rate. At this point 3 * (hw-retries + 1) frame transmits on the lowest data rate had failed. During disconnect-timeout packet transmission will be retried with on-fail-retry-time interval. If no frame can be transmitted successfully during disconnect-timeout, the connection is closed, and this event is logged as \"extensive data loss\". Successful frame transmission resets this timer.\n"
                    },
                    "distance": {
                        "type": "string",
                        "description": "How long to wait for confirmation of unicast frames (ACKs) before considering transmission unsuccessful, or in short ACK-Timeout.\n"
                    },
                    "frameLifetime": {
                        "type": "string",
                        "description": "Discard frames that have been queued for sending longer than frame-lifetime. By default, when value of this property is 0, frames are discarded only after connection is closed (format: 0.00 sec).\n"
                    },
                    "guardInterval": {
                        "type": "string",
                        "description": "Whether to allow use of short guard interval (refer to 802.11n MCS specification to see how this may affect throughput). \"any\" will use either short or long, depending on data rate, \"long\" will use long.\n"
                    },
                    "hideSsid": {
                        "type": "boolean",
                        "description": "This property has effect only in AP mode. Setting it to yes can remove this network from the list of wireless networks that are shown by some client software. Changing this setting does not improve the security of the wireless network, because SSID is included in other frames sent by the AP.\n"
                    },
                    "hwProtectionMode": {
                        "type": "string",
                        "description": "Frame protection support property. [See docs](https://wiki.mikrotik.com/wiki/Manual:Interface/Wireless#Frame_protection_support_(RTS/CTS)).\n"
                    },
                    "hwRetries": {
                        "type": "integer",
                        "description": "Number of times sending frame is retried without considering it a transmission failure. [See docs](https://wiki.mikrotik.com/wiki/Manual:Interface/Wireless)\n"
                    },
                    "installation": {
                        "type": "string",
                        "description": "Adjusts scan-list to use indoor, outdoor or all frequencies for the country that is set.\n"
                    },
                    "keepaliveFrames": {
                        "type": "string",
                        "description": "If a client has not communicated for around 20 seconds, AP sends a \"keepalive-frame\".\n"
                    },
                    "loadBalancingGroup": {
                        "type": "string",
                        "description": "Tags the interface to the load balancing group. For a client to connect to interface in this group, the interface should have the same number of already connected clients as all other interfaces in the group or smaller. Useful in setups where ranges of CAPs mostly overlap.\n"
                    },
                    "maxStaCount": {
                        "type": "integer",
                        "description": "Maximum number of associated clients.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "Set operational mode. Only **ap** currently supported.\n"
                    },
                    "multicastHelper": {
                        "type": "string",
                        "description": "When set to full multicast packets will be sent with unicast destination MAC address, resolving multicast problem on a wireless link. This option should be enabled only on the access point, clients should be configured in station-bridge mode.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "rates": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Rates inline settings.\n"
                    },
                    "rxChains": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Which antennas to use for receive.\n"
                    },
                    "security": {
                        "type": "object",
                        "additionalProperties": {
                            "type": "string"
                        },
                        "description": "Security inline settings.\n"
                    },
                    "ssid": {
                        "type": "string",
                        "description": "SSID (service set identifier) is a name broadcast in the beacons that identifies wireless network.\n"
                    },
                    "txChains": {
                        "type": "array",
                        "items": {
                            "type": "integer"
                        },
                        "description": "Which antennas to use for transmit.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:CapsMan/datapath:Datapath": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst testDatapath = new routeros.capsman.Datapath(\"testDatapath\", {\n    arp: \"local-proxy-arp\",\n    bridge: \"bridge\",\n    bridgeCost: 100,\n    bridgeHorizon: 200,\n    clientToClientForwarding: true,\n    comment: \"test_datapath\",\n    interfaceList: \"static\",\n    l2mtu: 1450,\n    localForwarding: true,\n    mtu: 1500,\n    vlanId: 101,\n    vlanMode: \"no-tag\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest_datapath = routeros.caps_man.Datapath(\"testDatapath\",\n    arp=\"local-proxy-arp\",\n    bridge=\"bridge\",\n    bridge_cost=100,\n    bridge_horizon=200,\n    client_to_client_forwarding=True,\n    comment=\"test_datapath\",\n    interface_list=\"static\",\n    l2mtu=1450,\n    local_forwarding=True,\n    mtu=1500,\n    vlan_id=101,\n    vlan_mode=\"no-tag\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testDatapath = new Routeros.CapsMan.Datapath(\"testDatapath\", new()\n    {\n        Arp = \"local-proxy-arp\",\n        Bridge = \"bridge\",\n        BridgeCost = 100,\n        BridgeHorizon = 200,\n        ClientToClientForwarding = true,\n        Comment = \"test_datapath\",\n        InterfaceList = \"static\",\n        L2mtu = 1450,\n        LocalForwarding = true,\n        Mtu = 1500,\n        VlanId = 101,\n        VlanMode = \"no-tag\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/CapsMan\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := CapsMan.NewDatapath(ctx, \"testDatapath\", \u0026CapsMan.DatapathArgs{\n\t\t\tArp:                      pulumi.String(\"local-proxy-arp\"),\n\t\t\tBridge:                   pulumi.String(\"bridge\"),\n\t\t\tBridgeCost:               pulumi.Int(100),\n\t\t\tBridgeHorizon:            pulumi.Int(200),\n\t\t\tClientToClientForwarding: pulumi.Bool(true),\n\t\t\tComment:                  pulumi.String(\"test_datapath\"),\n\t\t\tInterfaceList:            pulumi.String(\"static\"),\n\t\t\tL2mtu:                    pulumi.Int(1450),\n\t\t\tLocalForwarding:          pulumi.Bool(true),\n\t\t\tMtu:                      pulumi.Int(1500),\n\t\t\tVlanId:                   pulumi.Int(101),\n\t\t\tVlanMode:                 pulumi.String(\"no-tag\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.CapsMan.Datapath;\nimport com.pulumi.routeros.CapsMan.DatapathArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testDatapath = new Datapath(\"testDatapath\", DatapathArgs.builder()        \n            .arp(\"local-proxy-arp\")\n            .bridge(\"bridge\")\n            .bridgeCost(100)\n            .bridgeHorizon(200)\n            .clientToClientForwarding(true)\n            .comment(\"test_datapath\")\n            .interfaceList(\"static\")\n            .l2mtu(1450)\n            .localForwarding(true)\n            .mtu(1500)\n            .vlanId(101)\n            .vlanMode(\"no-tag\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testDatapath:\n    type: routeros:CapsMan:Datapath\n    properties:\n      arp: local-proxy-arp\n      bridge: bridge\n      bridgeCost: 100\n      bridgeHorizon: 200\n      clientToClientForwarding: true\n      comment: test_datapath\n      interfaceList: static\n      l2mtu: 1450\n      localForwarding: true\n      mtu: 1500\n      vlanId: 101\n      vlanMode: no-tag\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport with the name of the CAPsMAN datapath configuration in case of the example use test-datapath-config\n\n```sh\n $ pulumi import routeros:CapsMan/datapath:Datapath test_datapath test-datapath-config\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP mode. See [docs](https://wiki.mikrotik.com/wiki/Manual:IP/ARP#ARP_Modes) for info.\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "Bridge to which particular interface should be automatically added as port. Required only when local-forwarding is not used.\n"
                },
                "bridgeCost": {
                    "type": "integer",
                    "description": "Bridge port cost to use when adding as bridge port.\n"
                },
                "bridgeHorizon": {
                    "type": "integer",
                    "description": "Bridge horizon to use when adding as bridge port.\n"
                },
                "clientToClientForwarding": {
                    "type": "boolean",
                    "description": "Controls if client-to-client forwarding between wireless clients connected to interface should be allowed, in local forwarding mode this function is performed by CAP, otherwise it is performed by CAPsMAN.\n"
                },
                "comment": {
                    "type": "string"
                },
                "interfaceList": {
                    "type": "string",
                    "description": "Interface list name.\n"
                },
                "l2mtu": {
                    "type": "integer",
                    "description": "Layer2 MTU size.\n"
                },
                "localForwarding": {
                    "type": "boolean",
                    "description": "Controls forwarding mode. If disabled, all L2 and L3 data will be forwarded to CAPsMAN, and further forwarding decisions will be made only then. See [docs](https://wiki.mikrotik.com/wiki/Manual:CAPsMAN#Local_Forwarding_Mode) for info.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "MTU size.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "openflowSwitch": {
                    "type": "string",
                    "description": "OpenFlow switch to add interface to, as port when enabled.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "VLAN ID to assign to interface if vlan-mode enables use of VLAN tagging.\n"
                },
                "vlanMode": {
                    "type": "string",
                    "description": "VLAN tagging mode specifies if VLAN tag should be assigned to interface (causes all received data to get tagged with VLAN tag and allows interface to only send out data tagged with given tag)\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP mode. See [docs](https://wiki.mikrotik.com/wiki/Manual:IP/ARP#ARP_Modes) for info.\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "Bridge to which particular interface should be automatically added as port. Required only when local-forwarding is not used.\n"
                },
                "bridgeCost": {
                    "type": "integer",
                    "description": "Bridge port cost to use when adding as bridge port.\n"
                },
                "bridgeHorizon": {
                    "type": "integer",
                    "description": "Bridge horizon to use when adding as bridge port.\n"
                },
                "clientToClientForwarding": {
                    "type": "boolean",
                    "description": "Controls if client-to-client forwarding between wireless clients connected to interface should be allowed, in local forwarding mode this function is performed by CAP, otherwise it is performed by CAPsMAN.\n"
                },
                "comment": {
                    "type": "string"
                },
                "interfaceList": {
                    "type": "string",
                    "description": "Interface list name.\n"
                },
                "l2mtu": {
                    "type": "integer",
                    "description": "Layer2 MTU size.\n"
                },
                "localForwarding": {
                    "type": "boolean",
                    "description": "Controls forwarding mode. If disabled, all L2 and L3 data will be forwarded to CAPsMAN, and further forwarding decisions will be made only then. See [docs](https://wiki.mikrotik.com/wiki/Manual:CAPsMAN#Local_Forwarding_Mode) for info.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "MTU size.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "openflowSwitch": {
                    "type": "string",
                    "description": "OpenFlow switch to add interface to, as port when enabled.\n"
                },
                "vlanId": {
                    "type": "integer",
                    "description": "VLAN ID to assign to interface if vlan-mode enables use of VLAN tagging.\n"
                },
                "vlanMode": {
                    "type": "string",
                    "description": "VLAN tagging mode specifies if VLAN tag should be assigned to interface (causes all received data to get tagged with VLAN tag and allows interface to only send out data tagged with given tag)\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Datapath resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "arp": {
                        "type": "string",
                        "description": "ARP mode. See [docs](https://wiki.mikrotik.com/wiki/Manual:IP/ARP#ARP_Modes) for info.\n"
                    },
                    "bridge": {
                        "type": "string",
                        "description": "Bridge to which particular interface should be automatically added as port. Required only when local-forwarding is not used.\n"
                    },
                    "bridgeCost": {
                        "type": "integer",
                        "description": "Bridge port cost to use when adding as bridge port.\n"
                    },
                    "bridgeHorizon": {
                        "type": "integer",
                        "description": "Bridge horizon to use when adding as bridge port.\n"
                    },
                    "clientToClientForwarding": {
                        "type": "boolean",
                        "description": "Controls if client-to-client forwarding between wireless clients connected to interface should be allowed, in local forwarding mode this function is performed by CAP, otherwise it is performed by CAPsMAN.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "interfaceList": {
                        "type": "string",
                        "description": "Interface list name.\n"
                    },
                    "l2mtu": {
                        "type": "integer",
                        "description": "Layer2 MTU size.\n"
                    },
                    "localForwarding": {
                        "type": "boolean",
                        "description": "Controls forwarding mode. If disabled, all L2 and L3 data will be forwarded to CAPsMAN, and further forwarding decisions will be made only then. See [docs](https://wiki.mikrotik.com/wiki/Manual:CAPsMAN#Local_Forwarding_Mode) for info.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "MTU size.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "openflowSwitch": {
                        "type": "string",
                        "description": "OpenFlow switch to add interface to, as port when enabled.\n"
                    },
                    "vlanId": {
                        "type": "integer",
                        "description": "VLAN ID to assign to interface if vlan-mode enables use of VLAN tagging.\n"
                    },
                    "vlanMode": {
                        "type": "string",
                        "description": "VLAN tagging mode specifies if VLAN tag should be assigned to interface (causes all received data to get tagged with VLAN tag and allows interface to only send out data tagged with given tag)\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:CapsMan/manager:Manager": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst testManager = new routeros.capsman.Manager(\"testManager\", {\n    enabled: true,\n    upgradePolicy: \"require-same-version\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest_manager = routeros.caps_man.Manager(\"testManager\",\n    enabled=True,\n    upgrade_policy=\"require-same-version\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testManager = new Routeros.CapsMan.Manager(\"testManager\", new()\n    {\n        Enabled = true,\n        UpgradePolicy = \"require-same-version\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/CapsMan\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := CapsMan.NewManager(ctx, \"testManager\", \u0026CapsMan.ManagerArgs{\n\t\t\tEnabled:       pulumi.Bool(true),\n\t\t\tUpgradePolicy: pulumi.String(\"require-same-version\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.CapsMan.Manager;\nimport com.pulumi.routeros.CapsMan.ManagerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testManager = new Manager(\"testManager\", ManagerArgs.builder()        \n            .enabled(true)\n            .upgradePolicy(\"require-same-version\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testManager:\n    type: routeros:CapsMan:Manager\n    properties:\n      enabled: true\n      upgradePolicy: require-same-version\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import routeros:CapsMan/manager:Manager test_manager .\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "caCertificate": {
                    "type": "string",
                    "description": "Device CA certificate.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Device certificate.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Disable or enable CAPsMAN functionality.\n"
                },
                "packagePath": {
                    "type": "string",
                    "description": "Folder location for the RouterOS packages. For example, use '/upgrade' to specify the upgrade folder from the files section. If empty string is set, CAPsMAN can use built-in RouterOS packages, note that in this case only CAPs with the same architecture as CAPsMAN will be upgraded.\n"
                },
                "requirePeerCertificate": {
                    "type": "boolean",
                    "description": "Require all connecting CAPs to have a valid certificate.\n"
                },
                "upgradePolicy": {
                    "type": "string",
                    "description": "Upgrade policy options.\n"
                }
            },
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "caCertificate": {
                    "type": "string",
                    "description": "Device CA certificate.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Device certificate.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Disable or enable CAPsMAN functionality.\n"
                },
                "packagePath": {
                    "type": "string",
                    "description": "Folder location for the RouterOS packages. For example, use '/upgrade' to specify the upgrade folder from the files section. If empty string is set, CAPsMAN can use built-in RouterOS packages, note that in this case only CAPs with the same architecture as CAPsMAN will be upgraded.\n"
                },
                "requirePeerCertificate": {
                    "type": "boolean",
                    "description": "Require all connecting CAPs to have a valid certificate.\n"
                },
                "upgradePolicy": {
                    "type": "string",
                    "description": "Upgrade policy options.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Manager resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "caCertificate": {
                        "type": "string",
                        "description": "Device CA certificate.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "Device certificate.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Disable or enable CAPsMAN functionality.\n"
                    },
                    "packagePath": {
                        "type": "string",
                        "description": "Folder location for the RouterOS packages. For example, use '/upgrade' to specify the upgrade folder from the files section. If empty string is set, CAPsMAN can use built-in RouterOS packages, note that in this case only CAPs with the same architecture as CAPsMAN will be upgraded.\n"
                    },
                    "requirePeerCertificate": {
                        "type": "boolean",
                        "description": "Require all connecting CAPs to have a valid certificate.\n"
                    },
                    "upgradePolicy": {
                        "type": "string",
                        "description": "Upgrade policy options.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:CapsMan/managerInterface:ManagerInterface": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst testManagerInterface = new routeros.capsman.ManagerInterface(\"testManagerInterface\", {\n    forbid: true,\n    \"interface\": \"ether1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest_manager_interface = routeros.caps_man.ManagerInterface(\"testManagerInterface\",\n    forbid=True,\n    interface=\"ether1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testManagerInterface = new Routeros.CapsMan.ManagerInterface(\"testManagerInterface\", new()\n    {\n        Forbid = true,\n        Interface = \"ether1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/CapsMan\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := CapsMan.NewManagerInterface(ctx, \"testManagerInterface\", \u0026CapsMan.ManagerInterfaceArgs{\n\t\t\tForbid:    pulumi.Bool(true),\n\t\t\tInterface: pulumi.String(\"ether1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.CapsMan.ManagerInterface;\nimport com.pulumi.routeros.CapsMan.ManagerInterfaceArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testManagerInterface = new ManagerInterface(\"testManagerInterface\", ManagerInterfaceArgs.builder()        \n            .forbid(true)\n            .interface_(\"ether1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testManagerInterface:\n    type: routeros:CapsMan:ManagerInterface\n    properties:\n      forbid: true\n      interface: ether1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e\n\n:put [/caps-man/manager/interface get [print show-ids]]\n\n```sh\n $ pulumi import routeros:CapsMan/managerInterface:ManagerInterface test_manager_interface \"*6\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "default": {
                    "type": "boolean"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                },
                "forbid": {
                    "type": "boolean",
                    "description": "Disable interface listening.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                }
            },
            "required": [
                "default",
                "dynamic",
                "interface"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "forbid": {
                    "type": "boolean",
                    "description": "Disable interface listening.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                }
            },
            "requiredInputs": [
                "interface"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ManagerInterface resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "default": {
                        "type": "boolean"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                    },
                    "forbid": {
                        "type": "boolean",
                        "description": "Disable interface listening.\n"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:CapsMan/provisioning:Provisioning": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst testConfiguration = new routeros.capsman.Configuration(\"testConfiguration\", {});\nconst testProvisioning = new routeros.capsman.Provisioning(\"testProvisioning\", {\n    masterConfiguration: \"cfg1\",\n    action: \"create-disabled\",\n    namePrefix: \"cap-\",\n}, {\n    dependsOn: [testConfiguration],\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest_configuration = routeros.caps_man.Configuration(\"testConfiguration\")\ntest_provisioning = routeros.caps_man.Provisioning(\"testProvisioning\",\n    master_configuration=\"cfg1\",\n    action=\"create-disabled\",\n    name_prefix=\"cap-\",\n    opts=pulumi.ResourceOptions(depends_on=[test_configuration]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testConfiguration = new Routeros.CapsMan.Configuration(\"testConfiguration\");\n\n    var testProvisioning = new Routeros.CapsMan.Provisioning(\"testProvisioning\", new()\n    {\n        MasterConfiguration = \"cfg1\",\n        Action = \"create-disabled\",\n        NamePrefix = \"cap-\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            testConfiguration,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/CapsMan\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestConfiguration, err := CapsMan.NewConfiguration(ctx, \"testConfiguration\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = CapsMan.NewProvisioning(ctx, \"testProvisioning\", \u0026CapsMan.ProvisioningArgs{\n\t\t\tMasterConfiguration: pulumi.String(\"cfg1\"),\n\t\t\tAction:              pulumi.String(\"create-disabled\"),\n\t\t\tNamePrefix:          pulumi.String(\"cap-\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\ttestConfiguration,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.CapsMan.Configuration;\nimport com.pulumi.routeros.CapsMan.Provisioning;\nimport com.pulumi.routeros.CapsMan.ProvisioningArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testConfiguration = new Configuration(\"testConfiguration\");\n\n        var testProvisioning = new Provisioning(\"testProvisioning\", ProvisioningArgs.builder()        \n            .masterConfiguration(\"cfg1\")\n            .action(\"create-disabled\")\n            .namePrefix(\"cap-\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(testConfiguration)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testConfiguration:\n    type: routeros:CapsMan:Configuration\n  testProvisioning:\n    type: routeros:CapsMan:Provisioning\n    properties:\n      masterConfiguration: cfg1\n      action: create-disabled\n      namePrefix: cap-\n    options:\n      dependson:\n        - ${testConfiguration}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e\n\n:put [/caps-man/provisioning get [print show-ids]]\n\n```sh\n $ pulumi import routeros:CapsMan/provisioning:Provisioning test_provisioning \"*B\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Provisioning action.\n"
                },
                "comment": {
                    "type": "string"
                },
                "commonNameRegexp": {
                    "type": "string",
                    "description": "Regular expression to match radios by common name. Each CAP's common name identifier can be found under \"/caps-man radio\" as value \"REMOTE-CAP-NAME\"\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "hwSupportedModes": {
                    "type": "string",
                    "description": "Match radios by supported wireless modes.\n"
                },
                "identityRegexp": {
                    "type": "string",
                    "description": "Regular expression to match radios by router identity.\n"
                },
                "ipAddressRanges": {
                    "type": "string",
                    "description": "Match CAPs with IPs within configured address range.\n"
                },
                "masterConfiguration": {
                    "type": "string",
                    "description": "If action specifies to create interfaces, then a new master interface with its configuration set to this configuration profile will be created\n"
                },
                "nameFormat": {
                    "type": "string",
                    "description": "Specify the syntax of the CAP interface name creation.\n"
                },
                "namePrefix": {
                    "type": "string",
                    "description": "Name prefix which can be used in the name-format for creating the CAP interface names.\n"
                },
                "radioMac": {
                    "type": "string",
                    "description": "MAC address of radio to be matched, empty MAC (00:00:00:00:00:00) means match all MAC addresses.\n"
                },
                "slaveConfigurations": {
                    "type": "string",
                    "description": "If action specifies to create interfaces, then a new slave interface for each configuration profile in this list is created.\n"
                }
            },
            "required": [
                "masterConfiguration"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Provisioning action.\n"
                },
                "comment": {
                    "type": "string"
                },
                "commonNameRegexp": {
                    "type": "string",
                    "description": "Regular expression to match radios by common name. Each CAP's common name identifier can be found under \"/caps-man radio\" as value \"REMOTE-CAP-NAME\"\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "hwSupportedModes": {
                    "type": "string",
                    "description": "Match radios by supported wireless modes.\n"
                },
                "identityRegexp": {
                    "type": "string",
                    "description": "Regular expression to match radios by router identity.\n"
                },
                "ipAddressRanges": {
                    "type": "string",
                    "description": "Match CAPs with IPs within configured address range.\n"
                },
                "masterConfiguration": {
                    "type": "string",
                    "description": "If action specifies to create interfaces, then a new master interface with its configuration set to this configuration profile will be created\n"
                },
                "nameFormat": {
                    "type": "string",
                    "description": "Specify the syntax of the CAP interface name creation.\n"
                },
                "namePrefix": {
                    "type": "string",
                    "description": "Name prefix which can be used in the name-format for creating the CAP interface names.\n"
                },
                "radioMac": {
                    "type": "string",
                    "description": "MAC address of radio to be matched, empty MAC (00:00:00:00:00:00) means match all MAC addresses.\n"
                },
                "slaveConfigurations": {
                    "type": "string",
                    "description": "If action specifies to create interfaces, then a new slave interface for each configuration profile in this list is created.\n"
                }
            },
            "requiredInputs": [
                "masterConfiguration"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Provisioning resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "action": {
                        "type": "string",
                        "description": "Provisioning action.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "commonNameRegexp": {
                        "type": "string",
                        "description": "Regular expression to match radios by common name. Each CAP's common name identifier can be found under \"/caps-man radio\" as value \"REMOTE-CAP-NAME\"\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "hwSupportedModes": {
                        "type": "string",
                        "description": "Match radios by supported wireless modes.\n"
                    },
                    "identityRegexp": {
                        "type": "string",
                        "description": "Regular expression to match radios by router identity.\n"
                    },
                    "ipAddressRanges": {
                        "type": "string",
                        "description": "Match CAPs with IPs within configured address range.\n"
                    },
                    "masterConfiguration": {
                        "type": "string",
                        "description": "If action specifies to create interfaces, then a new master interface with its configuration set to this configuration profile will be created\n"
                    },
                    "nameFormat": {
                        "type": "string",
                        "description": "Specify the syntax of the CAP interface name creation.\n"
                    },
                    "namePrefix": {
                        "type": "string",
                        "description": "Name prefix which can be used in the name-format for creating the CAP interface names.\n"
                    },
                    "radioMac": {
                        "type": "string",
                        "description": "MAC address of radio to be matched, empty MAC (00:00:00:00:00:00) means match all MAC addresses.\n"
                    },
                    "slaveConfigurations": {
                        "type": "string",
                        "description": "If action specifies to create interfaces, then a new slave interface for each configuration profile in this list is created.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:CapsMan/rates:Rates": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst testRates = new routeros.capsman.Rates(\"testRates\", {\n    basics: [\n        \"1Mbps\",\n        \"5.5Mbps\",\n        \"6Mbps\",\n        \"18Mbps\",\n        \"36Mbps\",\n        \"54Mbps\",\n    ],\n    comment: \"test_rates\",\n    htBasicMcs: [\n        \"mcs-0\",\n        \"mcs-7\",\n        \"mcs-11\",\n        \"mcs-14\",\n        \"mcs-16\",\n        \"mcs-21\",\n    ],\n    htSupportedMcs: [\n        \"mcs-3\",\n        \"mcs-8\",\n        \"mcs-10\",\n        \"mcs-13\",\n        \"mcs-17\",\n        \"mcs-18\",\n    ],\n    supporteds: [\n        \"2Mbps\",\n        \"11Mbps\",\n        \"9Mbps\",\n        \"12Mbps\",\n        \"24Mbps\",\n        \"48Mbps\",\n    ],\n    vhtBasicMcs: \"none\",\n    vhtSupportedMcs: \"mcs0-9,mcs0-7\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest_rates = routeros.caps_man.Rates(\"testRates\",\n    basics=[\n        \"1Mbps\",\n        \"5.5Mbps\",\n        \"6Mbps\",\n        \"18Mbps\",\n        \"36Mbps\",\n        \"54Mbps\",\n    ],\n    comment=\"test_rates\",\n    ht_basic_mcs=[\n        \"mcs-0\",\n        \"mcs-7\",\n        \"mcs-11\",\n        \"mcs-14\",\n        \"mcs-16\",\n        \"mcs-21\",\n    ],\n    ht_supported_mcs=[\n        \"mcs-3\",\n        \"mcs-8\",\n        \"mcs-10\",\n        \"mcs-13\",\n        \"mcs-17\",\n        \"mcs-18\",\n    ],\n    supporteds=[\n        \"2Mbps\",\n        \"11Mbps\",\n        \"9Mbps\",\n        \"12Mbps\",\n        \"24Mbps\",\n        \"48Mbps\",\n    ],\n    vht_basic_mcs=\"none\",\n    vht_supported_mcs=\"mcs0-9,mcs0-7\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testRates = new Routeros.CapsMan.Rates(\"testRates\", new()\n    {\n        Basics = new[]\n        {\n            \"1Mbps\",\n            \"5.5Mbps\",\n            \"6Mbps\",\n            \"18Mbps\",\n            \"36Mbps\",\n            \"54Mbps\",\n        },\n        Comment = \"test_rates\",\n        HtBasicMcs = new[]\n        {\n            \"mcs-0\",\n            \"mcs-7\",\n            \"mcs-11\",\n            \"mcs-14\",\n            \"mcs-16\",\n            \"mcs-21\",\n        },\n        HtSupportedMcs = new[]\n        {\n            \"mcs-3\",\n            \"mcs-8\",\n            \"mcs-10\",\n            \"mcs-13\",\n            \"mcs-17\",\n            \"mcs-18\",\n        },\n        Supporteds = new[]\n        {\n            \"2Mbps\",\n            \"11Mbps\",\n            \"9Mbps\",\n            \"12Mbps\",\n            \"24Mbps\",\n            \"48Mbps\",\n        },\n        VhtBasicMcs = \"none\",\n        VhtSupportedMcs = \"mcs0-9,mcs0-7\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/CapsMan\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := CapsMan.NewRates(ctx, \"testRates\", \u0026CapsMan.RatesArgs{\n\t\t\tBasics: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"1Mbps\"),\n\t\t\t\tpulumi.String(\"5.5Mbps\"),\n\t\t\t\tpulumi.String(\"6Mbps\"),\n\t\t\t\tpulumi.String(\"18Mbps\"),\n\t\t\t\tpulumi.String(\"36Mbps\"),\n\t\t\t\tpulumi.String(\"54Mbps\"),\n\t\t\t},\n\t\t\tComment: pulumi.String(\"test_rates\"),\n\t\t\tHtBasicMcs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"mcs-0\"),\n\t\t\t\tpulumi.String(\"mcs-7\"),\n\t\t\t\tpulumi.String(\"mcs-11\"),\n\t\t\t\tpulumi.String(\"mcs-14\"),\n\t\t\t\tpulumi.String(\"mcs-16\"),\n\t\t\t\tpulumi.String(\"mcs-21\"),\n\t\t\t},\n\t\t\tHtSupportedMcs: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"mcs-3\"),\n\t\t\t\tpulumi.String(\"mcs-8\"),\n\t\t\t\tpulumi.String(\"mcs-10\"),\n\t\t\t\tpulumi.String(\"mcs-13\"),\n\t\t\t\tpulumi.String(\"mcs-17\"),\n\t\t\t\tpulumi.String(\"mcs-18\"),\n\t\t\t},\n\t\t\tSupporteds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"2Mbps\"),\n\t\t\t\tpulumi.String(\"11Mbps\"),\n\t\t\t\tpulumi.String(\"9Mbps\"),\n\t\t\t\tpulumi.String(\"12Mbps\"),\n\t\t\t\tpulumi.String(\"24Mbps\"),\n\t\t\t\tpulumi.String(\"48Mbps\"),\n\t\t\t},\n\t\t\tVhtBasicMcs:     pulumi.String(\"none\"),\n\t\t\tVhtSupportedMcs: pulumi.String(\"mcs0-9,mcs0-7\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.CapsMan.Rates;\nimport com.pulumi.routeros.CapsMan.RatesArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testRates = new Rates(\"testRates\", RatesArgs.builder()        \n            .basics(            \n                \"1Mbps\",\n                \"5.5Mbps\",\n                \"6Mbps\",\n                \"18Mbps\",\n                \"36Mbps\",\n                \"54Mbps\")\n            .comment(\"test_rates\")\n            .htBasicMcs(            \n                \"mcs-0\",\n                \"mcs-7\",\n                \"mcs-11\",\n                \"mcs-14\",\n                \"mcs-16\",\n                \"mcs-21\")\n            .htSupportedMcs(            \n                \"mcs-3\",\n                \"mcs-8\",\n                \"mcs-10\",\n                \"mcs-13\",\n                \"mcs-17\",\n                \"mcs-18\")\n            .supporteds(            \n                \"2Mbps\",\n                \"11Mbps\",\n                \"9Mbps\",\n                \"12Mbps\",\n                \"24Mbps\",\n                \"48Mbps\")\n            .vhtBasicMcs(\"none\")\n            .vhtSupportedMcs(\"mcs0-9,mcs0-7\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testRates:\n    type: routeros:CapsMan:Rates\n    properties:\n      basics:\n        - 1Mbps\n        - 5.5Mbps\n        - 6Mbps\n        - 18Mbps\n        - 36Mbps\n        - 54Mbps\n      comment: test_rates\n      htBasicMcs:\n        - mcs-0\n        - mcs-7\n        - mcs-11\n        - mcs-14\n        - mcs-16\n        - mcs-21\n      htSupportedMcs:\n        - mcs-3\n        - mcs-8\n        - mcs-10\n        - mcs-13\n        - mcs-17\n        - mcs-18\n      supporteds:\n        - 2Mbps\n        - 11Mbps\n        - 9Mbps\n        - 12Mbps\n        - 24Mbps\n        - 48Mbps\n      vhtBasicMcs: none\n      vhtSupportedMcs: mcs0-9,mcs0-7\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport with the name of the CAPsMAN rates configuration in case of the example use test-rates-config\n\n```sh\n $ pulumi import routeros:CapsMan/rates:Rates test_rates test-rates-config\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "basics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of basic rates. Client will connect to AP only if it supports all basic rates announced by the AP. AP will establish WDS link only if it supports all basic rates of the other AP.\n"
                },
                "comment": {
                    "type": "string"
                },
                "htBasicMcs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Modulation and Coding Schemes that every connecting client must support. Refer to 802.11n for MCS specification.\n"
                },
                "htSupportedMcs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Modulation and Coding Schemes that this device advertises as supported. Refer to 802.11n for MCS specification.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "supporteds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of supported rates. Two devices will communicate only using rates that are supported by both devices.\n"
                },
                "vhtBasicMcs": {
                    "type": "string",
                    "description": "Modulation and Coding Schemes that every connecting client must support. Refer to 802.11ac for MCS specification. You can set MCS interval for each of Spatial Stream none - will not use selected Spatial Stream MCS 0-7 - client must support MCS-0 to MCS-7 MCS 0-8 - client must support MCS-0 to MCS-8 MCS 0-9 - client must support MCS-0 to MCS-9\n"
                },
                "vhtSupportedMcs": {
                    "type": "string",
                    "description": "Modulation and Coding Schemes that this device advertises as supported. Refer to 802.11ac for MCS specification. You can set MCS interval for each of Spatial Stream none - will not use selected Spatial Stream MCS 0-7 - devices will advertise as supported MCS-0 to MCS-7 MCS 0-8 - devices will advertise as supported MCS-0 to MCS-8 MCS 0-9 - devices will advertise as supported MCS-0 to MCS-9\n"
                }
            },
            "required": [
                "htBasicMcs",
                "htSupportedMcs",
                "name",
                "vhtBasicMcs",
                "vhtSupportedMcs"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "basics": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of basic rates. Client will connect to AP only if it supports all basic rates announced by the AP. AP will establish WDS link only if it supports all basic rates of the other AP.\n"
                },
                "comment": {
                    "type": "string"
                },
                "htBasicMcs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Modulation and Coding Schemes that every connecting client must support. Refer to 802.11n for MCS specification.\n"
                },
                "htSupportedMcs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Modulation and Coding Schemes that this device advertises as supported. Refer to 802.11n for MCS specification.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "supporteds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of supported rates. Two devices will communicate only using rates that are supported by both devices.\n"
                },
                "vhtBasicMcs": {
                    "type": "string",
                    "description": "Modulation and Coding Schemes that every connecting client must support. Refer to 802.11ac for MCS specification. You can set MCS interval for each of Spatial Stream none - will not use selected Spatial Stream MCS 0-7 - client must support MCS-0 to MCS-7 MCS 0-8 - client must support MCS-0 to MCS-8 MCS 0-9 - client must support MCS-0 to MCS-9\n"
                },
                "vhtSupportedMcs": {
                    "type": "string",
                    "description": "Modulation and Coding Schemes that this device advertises as supported. Refer to 802.11ac for MCS specification. You can set MCS interval for each of Spatial Stream none - will not use selected Spatial Stream MCS 0-7 - devices will advertise as supported MCS-0 to MCS-7 MCS 0-8 - devices will advertise as supported MCS-0 to MCS-8 MCS 0-9 - devices will advertise as supported MCS-0 to MCS-9\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Rates resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "basics": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of basic rates. Client will connect to AP only if it supports all basic rates announced by the AP. AP will establish WDS link only if it supports all basic rates of the other AP.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "htBasicMcs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Modulation and Coding Schemes that every connecting client must support. Refer to 802.11n for MCS specification.\n"
                    },
                    "htSupportedMcs": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Modulation and Coding Schemes that this device advertises as supported. Refer to 802.11n for MCS specification.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "supporteds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of supported rates. Two devices will communicate only using rates that are supported by both devices.\n"
                    },
                    "vhtBasicMcs": {
                        "type": "string",
                        "description": "Modulation and Coding Schemes that every connecting client must support. Refer to 802.11ac for MCS specification. You can set MCS interval for each of Spatial Stream none - will not use selected Spatial Stream MCS 0-7 - client must support MCS-0 to MCS-7 MCS 0-8 - client must support MCS-0 to MCS-8 MCS 0-9 - client must support MCS-0 to MCS-9\n"
                    },
                    "vhtSupportedMcs": {
                        "type": "string",
                        "description": "Modulation and Coding Schemes that this device advertises as supported. Refer to 802.11ac for MCS specification. You can set MCS interval for each of Spatial Stream none - will not use selected Spatial Stream MCS 0-7 - devices will advertise as supported MCS-0 to MCS-7 MCS 0-8 - devices will advertise as supported MCS-0 to MCS-8 MCS 0-9 - devices will advertise as supported MCS-0 to MCS-9\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:CapsMan/security:Security": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst testSecurity = new routeros.capsman.Security(\"testSecurity\", {\n    authenticationTypes: [\n        \"wpa-psk\",\n        \"wpa-eap\",\n        \"wpa2-psk\",\n    ],\n    comment: \"test_security\",\n    disablePmkid: true,\n    eapMethods: \"eap-tls,passthrough\",\n    eapRadiusAccounting: true,\n    encryptions: [\n        \"tkip\",\n        \"aes-ccm\",\n    ],\n    groupEncryption: \"aes-ccm\",\n    groupKeyUpdate: \"1h\",\n    passphrase: \"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDE\",\n    tlsCertificate: \"none\",\n    tlsMode: \"verify-certificate\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest_security = routeros.caps_man.Security(\"testSecurity\",\n    authentication_types=[\n        \"wpa-psk\",\n        \"wpa-eap\",\n        \"wpa2-psk\",\n    ],\n    comment=\"test_security\",\n    disable_pmkid=True,\n    eap_methods=\"eap-tls,passthrough\",\n    eap_radius_accounting=True,\n    encryptions=[\n        \"tkip\",\n        \"aes-ccm\",\n    ],\n    group_encryption=\"aes-ccm\",\n    group_key_update=\"1h\",\n    passphrase=\"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDE\",\n    tls_certificate=\"none\",\n    tls_mode=\"verify-certificate\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testSecurity = new Routeros.CapsMan.Security(\"testSecurity\", new()\n    {\n        AuthenticationTypes = new[]\n        {\n            \"wpa-psk\",\n            \"wpa-eap\",\n            \"wpa2-psk\",\n        },\n        Comment = \"test_security\",\n        DisablePmkid = true,\n        EapMethods = \"eap-tls,passthrough\",\n        EapRadiusAccounting = true,\n        Encryptions = new[]\n        {\n            \"tkip\",\n            \"aes-ccm\",\n        },\n        GroupEncryption = \"aes-ccm\",\n        GroupKeyUpdate = \"1h\",\n        Passphrase = \"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDE\",\n        TlsCertificate = \"none\",\n        TlsMode = \"verify-certificate\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/CapsMan\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := CapsMan.NewSecurity(ctx, \"testSecurity\", \u0026CapsMan.SecurityArgs{\n\t\t\tAuthenticationTypes: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"wpa-psk\"),\n\t\t\t\tpulumi.String(\"wpa-eap\"),\n\t\t\t\tpulumi.String(\"wpa2-psk\"),\n\t\t\t},\n\t\t\tComment:             pulumi.String(\"test_security\"),\n\t\t\tDisablePmkid:        pulumi.Bool(true),\n\t\t\tEapMethods:          pulumi.String(\"eap-tls,passthrough\"),\n\t\t\tEapRadiusAccounting: pulumi.Bool(true),\n\t\t\tEncryptions: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"tkip\"),\n\t\t\t\tpulumi.String(\"aes-ccm\"),\n\t\t\t},\n\t\t\tGroupEncryption: pulumi.String(\"aes-ccm\"),\n\t\t\tGroupKeyUpdate:  pulumi.String(\"1h\"),\n\t\t\tPassphrase:      pulumi.String(\"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDE\"),\n\t\t\tTlsCertificate:  pulumi.String(\"none\"),\n\t\t\tTlsMode:         pulumi.String(\"verify-certificate\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.CapsMan.Security;\nimport com.pulumi.routeros.CapsMan.SecurityArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testSecurity = new Security(\"testSecurity\", SecurityArgs.builder()        \n            .authenticationTypes(            \n                \"wpa-psk\",\n                \"wpa-eap\",\n                \"wpa2-psk\")\n            .comment(\"test_security\")\n            .disablePmkid(true)\n            .eapMethods(\"eap-tls,passthrough\")\n            .eapRadiusAccounting(true)\n            .encryptions(            \n                \"tkip\",\n                \"aes-ccm\")\n            .groupEncryption(\"aes-ccm\")\n            .groupKeyUpdate(\"1h\")\n            .passphrase(\"0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDE\")\n            .tlsCertificate(\"none\")\n            .tlsMode(\"verify-certificate\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testSecurity:\n    type: routeros:CapsMan:Security\n    properties:\n      authenticationTypes:\n        - wpa-psk\n        - wpa-eap\n        - wpa2-psk\n      comment: test_security\n      disablePmkid: true\n      eapMethods: eap-tls,passthrough\n      eapRadiusAccounting: true\n      encryptions:\n        - tkip\n        - aes-ccm\n      groupEncryption: aes-ccm\n      groupKeyUpdate: 1h\n      passphrase: 0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDE\n      tlsCertificate: none\n      tlsMode: verify-certificate\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport with the name of the CAPsMAN security profile in case of the example use test-security-config\n\n```sh\n $ pulumi import routeros:CapsMan/security:Security test_security test-security-config\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "authenticationTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the type of Authentication from wpa-psk, wpa2-psk, wpa-eap or wpa2-eap.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disablePmkid": {
                    "type": "boolean",
                    "description": "Whether to include PMKID into the EAPOL frame sent out by the Access Point. Disabling PMKID can cause compatibility issues with devices that use the PMKID to connect to an Access Point.\n"
                },
                "eapMethods": {
                    "type": "string",
                    "description": "eap-tls - Use built-in EAP TLS authentication; passthrough - Access point will relay authentication process to the RADIUS server.\n"
                },
                "eapRadiusAccounting": {
                    "type": "boolean",
                    "description": "Specifies if RADIUS traffic accounting should be used if RADIUS authentication gets done for this client\n"
                },
                "encryptions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set type of unicast encryption algorithm used.\n"
                },
                "groupEncryption": {
                    "type": "string",
                    "description": "Access Point advertises one of these ciphers, multiple values can be selected. Access Point uses it to encrypt all broadcast and multicast frames. Client attempts connection only to Access Points that use one of the specified group ciphers.\n"
                },
                "groupKeyUpdate": {
                    "type": "string",
                    "description": "Controls how often Access Point updates the group key. This key is used to encrypt all broadcast and multicast frames. property only has effect for Access Points. (30s..1h)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "passphrase": {
                    "type": "string",
                    "description": "WPA or WPA2 pre-shared key.\n",
                    "secret": true
                },
                "tlsCertificate": {
                    "type": "string",
                    "description": "Access Point always needs a certificate when security.tls-mode is set to value other than no-certificates.\n"
                },
                "tlsMode": {
                    "type": "string",
                    "description": "This property has effect only when security.eap-methods contains eap-tls.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "authenticationTypes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Specify the type of Authentication from wpa-psk, wpa2-psk, wpa-eap or wpa2-eap.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disablePmkid": {
                    "type": "boolean",
                    "description": "Whether to include PMKID into the EAPOL frame sent out by the Access Point. Disabling PMKID can cause compatibility issues with devices that use the PMKID to connect to an Access Point.\n"
                },
                "eapMethods": {
                    "type": "string",
                    "description": "eap-tls - Use built-in EAP TLS authentication; passthrough - Access point will relay authentication process to the RADIUS server.\n"
                },
                "eapRadiusAccounting": {
                    "type": "boolean",
                    "description": "Specifies if RADIUS traffic accounting should be used if RADIUS authentication gets done for this client\n"
                },
                "encryptions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Set type of unicast encryption algorithm used.\n"
                },
                "groupEncryption": {
                    "type": "string",
                    "description": "Access Point advertises one of these ciphers, multiple values can be selected. Access Point uses it to encrypt all broadcast and multicast frames. Client attempts connection only to Access Points that use one of the specified group ciphers.\n"
                },
                "groupKeyUpdate": {
                    "type": "string",
                    "description": "Controls how often Access Point updates the group key. This key is used to encrypt all broadcast and multicast frames. property only has effect for Access Points. (30s..1h)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "passphrase": {
                    "type": "string",
                    "description": "WPA or WPA2 pre-shared key.\n",
                    "secret": true
                },
                "tlsCertificate": {
                    "type": "string",
                    "description": "Access Point always needs a certificate when security.tls-mode is set to value other than no-certificates.\n"
                },
                "tlsMode": {
                    "type": "string",
                    "description": "This property has effect only when security.eap-methods contains eap-tls.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Security resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "authenticationTypes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Specify the type of Authentication from wpa-psk, wpa2-psk, wpa-eap or wpa2-eap.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disablePmkid": {
                        "type": "boolean",
                        "description": "Whether to include PMKID into the EAPOL frame sent out by the Access Point. Disabling PMKID can cause compatibility issues with devices that use the PMKID to connect to an Access Point.\n"
                    },
                    "eapMethods": {
                        "type": "string",
                        "description": "eap-tls - Use built-in EAP TLS authentication; passthrough - Access point will relay authentication process to the RADIUS server.\n"
                    },
                    "eapRadiusAccounting": {
                        "type": "boolean",
                        "description": "Specifies if RADIUS traffic accounting should be used if RADIUS authentication gets done for this client\n"
                    },
                    "encryptions": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Set type of unicast encryption algorithm used.\n"
                    },
                    "groupEncryption": {
                        "type": "string",
                        "description": "Access Point advertises one of these ciphers, multiple values can be selected. Access Point uses it to encrypt all broadcast and multicast frames. Client attempts connection only to Access Points that use one of the specified group ciphers.\n"
                    },
                    "groupKeyUpdate": {
                        "type": "string",
                        "description": "Controls how often Access Point updates the group key. This key is used to encrypt all broadcast and multicast frames. property only has effect for Access Points. (30s..1h)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "passphrase": {
                        "type": "string",
                        "description": "WPA or WPA2 pre-shared key.\n",
                        "secret": true
                    },
                    "tlsCertificate": {
                        "type": "string",
                        "description": "Access Point always needs a certificate when security.tls-mode is set to value other than no-certificates.\n"
                    },
                    "tlsMode": {
                        "type": "string",
                        "description": "This property has effect only when security.eap-methods contains eap-tls.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/bridge:Bridge": {
            "description": "## # routeros.Iface.Bridge (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Iface.InterfaceBridge\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "actualMtu": {
                    "type": "integer"
                },
                "addDhcpOption82": {
                    "type": "boolean",
                    "description": "Whether to add DHCP Option-82 information (Agent Remote ID and Agent Circuit ID) to DHCP packets. Can be used together\nwith Option-82 capable DHCP server to assign IP addresses and implement policies. This property only has effect when\ndhcp-snooping is set to yes.\n"
                },
                "adminMac": {
                    "type": "string",
                    "description": "Static MAC address of the bridge. This property only has effect when auto-mac is set to no.\n"
                },
                "ageingTime": {
                    "type": "string",
                    "description": "How long a host's information will be kept in the bridge database.\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP resolution protocol mode.\n"
                },
                "arpTimeout": {
                    "type": "string",
                    "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to\nthe value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds,\nminutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                },
                "autoMac": {
                    "type": "boolean",
                    "description": "Automatically select one MAC address of bridge ports as a bridge MAC address, bridge MAC will be chosen from the first\nadded bridge port. After a device reboot, the bridge MAC can change depending on the port-number.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcpSnooping": {
                    "type": "boolean"
                },
                "disabled": {
                    "type": "boolean"
                },
                "etherType": {
                    "type": "string",
                    "description": "This property only has effect when vlan-filtering is set to yes.\n"
                },
                "fastForward": {
                    "type": "boolean"
                },
                "forwardDelay": {
                    "type": "string",
                    "description": "Time which is spent during the initialization phase of the bridge interface (i.e., after router startup or enabling the\ninterface) in listening/learning state before the bridge will start functioning normally.\n"
                },
                "frameTypes": {
                    "type": "string",
                    "description": "Specifies allowed frame types on a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "igmpSnooping": {
                    "type": "boolean",
                    "description": "Enables multicast group and port learning to prevent multicast traffic from flooding all interfaces in a bridge.\n"
                },
                "igmpVersion": {
                    "type": "integer",
                    "description": "Selects the IGMP version in which IGMP general membership queries will be generated. This property only has effect when\nigmp-snooping is set to yes.\n"
                },
                "ingressFiltering": {
                    "type": "boolean",
                    "description": "Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the\nbridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This\nproperty only has effect when vlan-filtering is set to yes.\n"
                },
                "l2mtu": {
                    "type": "integer",
                    "description": "Layer2 Maximum transmission unit.\n"
                },
                "lastMemberInterval": {
                    "type": "string",
                    "description": "If a port has fast-leave set to no and a bridge port receives a IGMP Leave message, then a IGMP Snooping enabled bridge\nwill send a IGMP query to make sure that no devices has subscribed to a certain multicast stream on a bridge port.\n"
                },
                "lastMemberQueryCount": {
                    "type": "integer",
                    "description": "How many times should last-member-interval pass until a IGMP Snooping bridge will stop forwarding a certain multicast\nstream. This property only has effect when igmp-snooping is set to yes.\n"
                },
                "macAddress": {
                    "type": "string"
                },
                "maxHops": {
                    "type": "integer",
                    "description": "Bridge count which BPDU can pass in a MSTP enabled network in the same region before BPDU is being ignored. This\nproperty only has effect when protocol-mode is set to mstp.\n"
                },
                "maxMessageAge": {
                    "type": "string",
                    "description": "Changes the Max Age value in BPDU packets, which is transmitted by the root bridge. This property only has effect when\nprotocol-mode is set to stp or rstp. Value: 6s..40s\n"
                },
                "membershipInterval": {
                    "type": "string",
                    "description": "Amount of time after an entry in the Multicast Database (MDB) is removed if a IGMP membership report is not received on\na certain port. This property only has effect when igmp-snooping is set to yes.\n"
                },
                "mldVersion": {
                    "type": "integer",
                    "description": "Selects the MLD version. Version 2 adds support for source-specific multicast. This property only has effect when\nRouterOS IPv6 package is enabled and igmp-snooping is set to yes.\n"
                },
                "mtu": {
                    "type": "string",
                    "description": "The default bridge MTU value without any bridge ports added is 1500. The MTU value can be set manually, but it cannot\nexceed the bridge L2MTU or the lowest bridge port L2MTU. If a new bridge port is added with L2MTU which is smaller than\nthe actual-mtu of the bridge (set by the mtu property), then manually set value will be ignored and the bridge will act\nas if mtu=auto is set.\n"
                },
                "multicastQuerier": {
                    "type": "boolean",
                    "description": "Multicast querier generates IGMP general membership queries to which all IGMP capable devices respond with an IGMP\nmembership report, usually a PIM (multicast) router or IGMP proxy generates these queries. This property only has an\neffect when igmp-snooping is set to yes. Additionally, the igmp-snooping should be disabled/enabled after changing\nmulticast-querier property.\n"
                },
                "multicastRouter": {
                    "type": "string",
                    "description": "A multicast router port is a port where a multicast router or querier is connected. On this port, unregistered multicast\nstreams and IGMP/MLD membership reports will be sent. This setting changes the state of the multicast router for a\nbridge interface itself. This property can be used to send IGMP/MLD membership reports and multicast traffic to the\nbridge interface for further multicast routing or proxying. This property only has an effect when igmp-snooping is set\nto yes.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "priority": {
                    "type": "string",
                    "description": "Bridge priority, used by STP to determine root bridge, used by MSTP to determine CIST and IST regional root bridge. This\nproperty has no effect when protocol-mode is set to none.\n"
                },
                "protocolMode": {
                    "type": "string",
                    "description": "Select Spanning tree protocol (STP) or Rapid spanning tree protocol (RSTP) to ensure a loop-free topology for any\nbridged LAN.\n"
                },
                "pvid": {
                    "type": "integer",
                    "description": "Port VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. It applies e.g. to frames sent\nfrom bridge IP and destined to a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "querierInterval": {
                    "type": "string",
                    "description": "Used to change the interval how often a bridge checks if it is the active multicast querier. This property only has\neffect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "queryInterval": {
                    "type": "string",
                    "description": "Used to change the interval how often IGMP general membership queries are sent out. This property only has effect when\nigmp-snooping and multicast-querier is set to yes.\n"
                },
                "queryResponseInterval": {
                    "type": "string",
                    "description": "Interval in which a IGMP capable device must reply to a IGMP query with a IGMP membership report. This property only has\neffect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "MSTP region name. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "regionRevision": {
                    "type": "integer",
                    "description": "MSTP configuration revision number. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "running": {
                    "type": "boolean"
                },
                "startupQueryCount": {
                    "type": "integer",
                    "description": "Specifies how many times must startup-query-interval pass until the bridge starts sending out IGMP general membership\nqueries periodically. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "startupQueryInterval": {
                    "type": "string",
                    "description": "Used to change the amount of time after a bridge starts sending out IGMP general membership queries after the bridge is\nenabled. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "transmitHoldCount": {
                    "type": "integer",
                    "description": "The Transmit Hold Count used by the Port Transmit state machine to limit transmission rate.\n"
                },
                "vlanFiltering": {
                    "type": "boolean",
                    "description": "Globally enables or disables VLAN functionality for bridge.\n"
                }
            },
            "required": [
                "actualMtu",
                "adminMac",
                "fastForward",
                "igmpVersion",
                "l2mtu",
                "lastMemberInterval",
                "lastMemberQueryCount",
                "macAddress",
                "maxHops",
                "membershipInterval",
                "mldVersion",
                "multicastRouter",
                "name",
                "querierInterval",
                "queryInterval",
                "queryResponseInterval",
                "running",
                "startupQueryCount",
                "startupQueryInterval"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "addDhcpOption82": {
                    "type": "boolean",
                    "description": "Whether to add DHCP Option-82 information (Agent Remote ID and Agent Circuit ID) to DHCP packets. Can be used together\nwith Option-82 capable DHCP server to assign IP addresses and implement policies. This property only has effect when\ndhcp-snooping is set to yes.\n"
                },
                "adminMac": {
                    "type": "string",
                    "description": "Static MAC address of the bridge. This property only has effect when auto-mac is set to no.\n"
                },
                "ageingTime": {
                    "type": "string",
                    "description": "How long a host's information will be kept in the bridge database.\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP resolution protocol mode.\n"
                },
                "arpTimeout": {
                    "type": "string",
                    "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to\nthe value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds,\nminutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                },
                "autoMac": {
                    "type": "boolean",
                    "description": "Automatically select one MAC address of bridge ports as a bridge MAC address, bridge MAC will be chosen from the first\nadded bridge port. After a device reboot, the bridge MAC can change depending on the port-number.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcpSnooping": {
                    "type": "boolean"
                },
                "disabled": {
                    "type": "boolean"
                },
                "etherType": {
                    "type": "string",
                    "description": "This property only has effect when vlan-filtering is set to yes.\n"
                },
                "fastForward": {
                    "type": "boolean"
                },
                "forwardDelay": {
                    "type": "string",
                    "description": "Time which is spent during the initialization phase of the bridge interface (i.e., after router startup or enabling the\ninterface) in listening/learning state before the bridge will start functioning normally.\n"
                },
                "frameTypes": {
                    "type": "string",
                    "description": "Specifies allowed frame types on a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "igmpSnooping": {
                    "type": "boolean",
                    "description": "Enables multicast group and port learning to prevent multicast traffic from flooding all interfaces in a bridge.\n"
                },
                "igmpVersion": {
                    "type": "integer",
                    "description": "Selects the IGMP version in which IGMP general membership queries will be generated. This property only has effect when\nigmp-snooping is set to yes.\n"
                },
                "ingressFiltering": {
                    "type": "boolean",
                    "description": "Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the\nbridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This\nproperty only has effect when vlan-filtering is set to yes.\n"
                },
                "lastMemberInterval": {
                    "type": "string",
                    "description": "If a port has fast-leave set to no and a bridge port receives a IGMP Leave message, then a IGMP Snooping enabled bridge\nwill send a IGMP query to make sure that no devices has subscribed to a certain multicast stream on a bridge port.\n"
                },
                "lastMemberQueryCount": {
                    "type": "integer",
                    "description": "How many times should last-member-interval pass until a IGMP Snooping bridge will stop forwarding a certain multicast\nstream. This property only has effect when igmp-snooping is set to yes.\n"
                },
                "maxHops": {
                    "type": "integer",
                    "description": "Bridge count which BPDU can pass in a MSTP enabled network in the same region before BPDU is being ignored. This\nproperty only has effect when protocol-mode is set to mstp.\n"
                },
                "maxMessageAge": {
                    "type": "string",
                    "description": "Changes the Max Age value in BPDU packets, which is transmitted by the root bridge. This property only has effect when\nprotocol-mode is set to stp or rstp. Value: 6s..40s\n"
                },
                "membershipInterval": {
                    "type": "string",
                    "description": "Amount of time after an entry in the Multicast Database (MDB) is removed if a IGMP membership report is not received on\na certain port. This property only has effect when igmp-snooping is set to yes.\n"
                },
                "mldVersion": {
                    "type": "integer",
                    "description": "Selects the MLD version. Version 2 adds support for source-specific multicast. This property only has effect when\nRouterOS IPv6 package is enabled and igmp-snooping is set to yes.\n"
                },
                "mtu": {
                    "type": "string",
                    "description": "The default bridge MTU value without any bridge ports added is 1500. The MTU value can be set manually, but it cannot\nexceed the bridge L2MTU or the lowest bridge port L2MTU. If a new bridge port is added with L2MTU which is smaller than\nthe actual-mtu of the bridge (set by the mtu property), then manually set value will be ignored and the bridge will act\nas if mtu=auto is set.\n"
                },
                "multicastQuerier": {
                    "type": "boolean",
                    "description": "Multicast querier generates IGMP general membership queries to which all IGMP capable devices respond with an IGMP\nmembership report, usually a PIM (multicast) router or IGMP proxy generates these queries. This property only has an\neffect when igmp-snooping is set to yes. Additionally, the igmp-snooping should be disabled/enabled after changing\nmulticast-querier property.\n"
                },
                "multicastRouter": {
                    "type": "string",
                    "description": "A multicast router port is a port where a multicast router or querier is connected. On this port, unregistered multicast\nstreams and IGMP/MLD membership reports will be sent. This setting changes the state of the multicast router for a\nbridge interface itself. This property can be used to send IGMP/MLD membership reports and multicast traffic to the\nbridge interface for further multicast routing or proxying. This property only has an effect when igmp-snooping is set\nto yes.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "priority": {
                    "type": "string",
                    "description": "Bridge priority, used by STP to determine root bridge, used by MSTP to determine CIST and IST regional root bridge. This\nproperty has no effect when protocol-mode is set to none.\n"
                },
                "protocolMode": {
                    "type": "string",
                    "description": "Select Spanning tree protocol (STP) or Rapid spanning tree protocol (RSTP) to ensure a loop-free topology for any\nbridged LAN.\n"
                },
                "pvid": {
                    "type": "integer",
                    "description": "Port VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. It applies e.g. to frames sent\nfrom bridge IP and destined to a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "querierInterval": {
                    "type": "string",
                    "description": "Used to change the interval how often a bridge checks if it is the active multicast querier. This property only has\neffect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "queryInterval": {
                    "type": "string",
                    "description": "Used to change the interval how often IGMP general membership queries are sent out. This property only has effect when\nigmp-snooping and multicast-querier is set to yes.\n"
                },
                "queryResponseInterval": {
                    "type": "string",
                    "description": "Interval in which a IGMP capable device must reply to a IGMP query with a IGMP membership report. This property only has\neffect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "MSTP region name. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "regionRevision": {
                    "type": "integer",
                    "description": "MSTP configuration revision number. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "startupQueryCount": {
                    "type": "integer",
                    "description": "Specifies how many times must startup-query-interval pass until the bridge starts sending out IGMP general membership\nqueries periodically. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "startupQueryInterval": {
                    "type": "string",
                    "description": "Used to change the amount of time after a bridge starts sending out IGMP general membership queries after the bridge is\nenabled. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "transmitHoldCount": {
                    "type": "integer",
                    "description": "The Transmit Hold Count used by the Port Transmit state machine to limit transmission rate.\n"
                },
                "vlanFiltering": {
                    "type": "boolean",
                    "description": "Globally enables or disables VLAN functionality for bridge.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Bridge resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "actualMtu": {
                        "type": "integer"
                    },
                    "addDhcpOption82": {
                        "type": "boolean",
                        "description": "Whether to add DHCP Option-82 information (Agent Remote ID and Agent Circuit ID) to DHCP packets. Can be used together\nwith Option-82 capable DHCP server to assign IP addresses and implement policies. This property only has effect when\ndhcp-snooping is set to yes.\n"
                    },
                    "adminMac": {
                        "type": "string",
                        "description": "Static MAC address of the bridge. This property only has effect when auto-mac is set to no.\n"
                    },
                    "ageingTime": {
                        "type": "string",
                        "description": "How long a host's information will be kept in the bridge database.\n"
                    },
                    "arp": {
                        "type": "string",
                        "description": "ARP resolution protocol mode.\n"
                    },
                    "arpTimeout": {
                        "type": "string",
                        "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to\nthe value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds,\nminutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                    },
                    "autoMac": {
                        "type": "boolean",
                        "description": "Automatically select one MAC address of bridge ports as a bridge MAC address, bridge MAC will be chosen from the first\nadded bridge port. After a device reboot, the bridge MAC can change depending on the port-number.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "dhcpSnooping": {
                        "type": "boolean"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "etherType": {
                        "type": "string",
                        "description": "This property only has effect when vlan-filtering is set to yes.\n"
                    },
                    "fastForward": {
                        "type": "boolean"
                    },
                    "forwardDelay": {
                        "type": "string",
                        "description": "Time which is spent during the initialization phase of the bridge interface (i.e., after router startup or enabling the\ninterface) in listening/learning state before the bridge will start functioning normally.\n"
                    },
                    "frameTypes": {
                        "type": "string",
                        "description": "Specifies allowed frame types on a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                    },
                    "igmpSnooping": {
                        "type": "boolean",
                        "description": "Enables multicast group and port learning to prevent multicast traffic from flooding all interfaces in a bridge.\n"
                    },
                    "igmpVersion": {
                        "type": "integer",
                        "description": "Selects the IGMP version in which IGMP general membership queries will be generated. This property only has effect when\nigmp-snooping is set to yes.\n"
                    },
                    "ingressFiltering": {
                        "type": "boolean",
                        "description": "Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the\nbridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This\nproperty only has effect when vlan-filtering is set to yes.\n"
                    },
                    "l2mtu": {
                        "type": "integer",
                        "description": "Layer2 Maximum transmission unit.\n"
                    },
                    "lastMemberInterval": {
                        "type": "string",
                        "description": "If a port has fast-leave set to no and a bridge port receives a IGMP Leave message, then a IGMP Snooping enabled bridge\nwill send a IGMP query to make sure that no devices has subscribed to a certain multicast stream on a bridge port.\n"
                    },
                    "lastMemberQueryCount": {
                        "type": "integer",
                        "description": "How many times should last-member-interval pass until a IGMP Snooping bridge will stop forwarding a certain multicast\nstream. This property only has effect when igmp-snooping is set to yes.\n"
                    },
                    "macAddress": {
                        "type": "string"
                    },
                    "maxHops": {
                        "type": "integer",
                        "description": "Bridge count which BPDU can pass in a MSTP enabled network in the same region before BPDU is being ignored. This\nproperty only has effect when protocol-mode is set to mstp.\n"
                    },
                    "maxMessageAge": {
                        "type": "string",
                        "description": "Changes the Max Age value in BPDU packets, which is transmitted by the root bridge. This property only has effect when\nprotocol-mode is set to stp or rstp. Value: 6s..40s\n"
                    },
                    "membershipInterval": {
                        "type": "string",
                        "description": "Amount of time after an entry in the Multicast Database (MDB) is removed if a IGMP membership report is not received on\na certain port. This property only has effect when igmp-snooping is set to yes.\n"
                    },
                    "mldVersion": {
                        "type": "integer",
                        "description": "Selects the MLD version. Version 2 adds support for source-specific multicast. This property only has effect when\nRouterOS IPv6 package is enabled and igmp-snooping is set to yes.\n"
                    },
                    "mtu": {
                        "type": "string",
                        "description": "The default bridge MTU value without any bridge ports added is 1500. The MTU value can be set manually, but it cannot\nexceed the bridge L2MTU or the lowest bridge port L2MTU. If a new bridge port is added with L2MTU which is smaller than\nthe actual-mtu of the bridge (set by the mtu property), then manually set value will be ignored and the bridge will act\nas if mtu=auto is set.\n"
                    },
                    "multicastQuerier": {
                        "type": "boolean",
                        "description": "Multicast querier generates IGMP general membership queries to which all IGMP capable devices respond with an IGMP\nmembership report, usually a PIM (multicast) router or IGMP proxy generates these queries. This property only has an\neffect when igmp-snooping is set to yes. Additionally, the igmp-snooping should be disabled/enabled after changing\nmulticast-querier property.\n"
                    },
                    "multicastRouter": {
                        "type": "string",
                        "description": "A multicast router port is a port where a multicast router or querier is connected. On this port, unregistered multicast\nstreams and IGMP/MLD membership reports will be sent. This setting changes the state of the multicast router for a\nbridge interface itself. This property can be used to send IGMP/MLD membership reports and multicast traffic to the\nbridge interface for further multicast routing or proxying. This property only has an effect when igmp-snooping is set\nto yes.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "priority": {
                        "type": "string",
                        "description": "Bridge priority, used by STP to determine root bridge, used by MSTP to determine CIST and IST regional root bridge. This\nproperty has no effect when protocol-mode is set to none.\n"
                    },
                    "protocolMode": {
                        "type": "string",
                        "description": "Select Spanning tree protocol (STP) or Rapid spanning tree protocol (RSTP) to ensure a loop-free topology for any\nbridged LAN.\n"
                    },
                    "pvid": {
                        "type": "integer",
                        "description": "Port VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. It applies e.g. to frames sent\nfrom bridge IP and destined to a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                    },
                    "querierInterval": {
                        "type": "string",
                        "description": "Used to change the interval how often a bridge checks if it is the active multicast querier. This property only has\neffect when igmp-snooping and multicast-querier is set to yes.\n"
                    },
                    "queryInterval": {
                        "type": "string",
                        "description": "Used to change the interval how often IGMP general membership queries are sent out. This property only has effect when\nigmp-snooping and multicast-querier is set to yes.\n"
                    },
                    "queryResponseInterval": {
                        "type": "string",
                        "description": "Interval in which a IGMP capable device must reply to a IGMP query with a IGMP membership report. This property only has\neffect when igmp-snooping and multicast-querier is set to yes.\n"
                    },
                    "regionName": {
                        "type": "string",
                        "description": "MSTP region name. This property only has effect when protocol-mode is set to mstp.\n"
                    },
                    "regionRevision": {
                        "type": "integer",
                        "description": "MSTP configuration revision number. This property only has effect when protocol-mode is set to mstp.\n"
                    },
                    "running": {
                        "type": "boolean"
                    },
                    "startupQueryCount": {
                        "type": "integer",
                        "description": "Specifies how many times must startup-query-interval pass until the bridge starts sending out IGMP general membership\nqueries periodically. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                    },
                    "startupQueryInterval": {
                        "type": "string",
                        "description": "Used to change the amount of time after a bridge starts sending out IGMP general membership queries after the bridge is\nenabled. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                    },
                    "transmitHoldCount": {
                        "type": "integer",
                        "description": "The Transmit Hold Count used by the Port Transmit state machine to limit transmission rate.\n"
                    },
                    "vlanFiltering": {
                        "type": "boolean",
                        "description": "Globally enables or disables VLAN functionality for bridge.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/bridgePort:BridgePort": {
            "description": "## # routeros.Iface.BridgePort (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Iface.InterfaceBridgePort\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "autoIsolate": {
                    "type": "boolean",
                    "description": "When enabled, prevents a port moving from discarding into forwarding state if no BPDUs are received from the neighboring\nbridge. The port will change into a forwarding state only when a BPDU is received. This property only has an effect when\nprotocol-mode is set to rstp or mstp and edge is set to no.\n"
                },
                "bpduGuard": {
                    "type": "boolean",
                    "description": "This property has no effect when protocol-mode is set to none.\n"
                },
                "bridge": {
                    "type": "string"
                },
                "broadcastFlood": {
                    "type": "boolean",
                    "description": "When enabled, bridge floods broadcast traffic to all bridge egress ports. When disabled, drops broadcast traffic on\negress ports.\n"
                },
                "comment": {
                    "type": "string"
                },
                "debugInfo": {
                    "type": "string"
                },
                "designatedBridge": {
                    "type": "string",
                    "description": "Root bridge ID (bridge priority and the bridge MAC address).\n"
                },
                "designatedCost": {
                    "type": "string",
                    "description": "Designated cost.\n"
                },
                "designatedPortNumber": {
                    "type": "integer",
                    "description": "Designated port number.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "edge": {
                    "type": "string",
                    "description": "Set port as edge port or non-edge port, or enable edge discovery. Edge ports are connected to a LAN that has no other\nbridges attached.\n"
                },
                "edgePort": {
                    "type": "boolean",
                    "description": "Whether port is an edge port or not.\n"
                },
                "edgePortDiscovery": {
                    "type": "boolean",
                    "description": "Whether port is set to automatically detect edge ports.\n"
                },
                "externalFdbStatus": {
                    "type": "boolean",
                    "description": "Whether registration table is used instead of forwarding data base.\n"
                },
                "fastLeave": {
                    "type": "boolean",
                    "description": "Enables IGMP Fast leave feature on the port.\n"
                },
                "forwarding": {
                    "type": "boolean",
                    "description": "Shows if the port is not blocked by (R/M)STP.\n"
                },
                "frameTypes": {
                    "type": "string",
                    "description": "Specifies allowed ingress frame types on a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "horizon": {
                    "type": "string",
                    "description": "Use split horizon bridging to prevent bridging loops. Set the same value for group of ports, to prevent them from\nsending data to ports with the same horizon value. Split horizon is a software feature that disables hardware\noffloading. This value is integer '0'..'429496729' or 'none'.\n"
                },
                "hw": {
                    "type": "boolean",
                    "description": "Enable or disable Hardware Offloading of the interface.\n"
                },
                "hwOffload": {
                    "type": "boolean",
                    "description": "Hardware offloading state.\n"
                },
                "hwOffloadGroup": {
                    "type": "string",
                    "description": "Switch chip used by the port.\n"
                },
                "inactive": {
                    "type": "boolean"
                },
                "ingressFiltering": {
                    "type": "boolean",
                    "description": "Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the\nbridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This\nproperty only has effect when vlan-filtering is set to yes.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "internalPathCost": {
                    "type": "integer",
                    "description": "Path cost to the interface for MSTI0 inside a region. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "learn": {
                    "type": "string",
                    "description": "Changes MAC learning behaviour on a bridge port\n"
                },
                "learning": {
                    "type": "boolean",
                    "description": "Shows whether the port is capable of learning MAC addresses.\n"
                },
                "multicastRouter": {
                    "type": "string",
                    "description": "Changes the state of a bridge port whether IGMP membership reports are going to be forwarded to this port.\n"
                },
                "nextid": {
                    "type": "string"
                },
                "pathCost": {
                    "type": "string",
                    "description": "Path cost to the interface, used by STP to determine the \"best\" path, used by MSTP todetermine \"best\" path between\nregions. This property has no effect when protocol-mode is set to none.\n"
                },
                "pointToPoint": {
                    "type": "string",
                    "description": "Specifies if a bridge port is connected to a bridge using a point-to-point link for faster convergence in case of\nfailure. This property has no effect when protocol-mode is set to none.\n"
                },
                "pointToPointPort": {
                    "type": "boolean",
                    "description": "Whether the port is connected to a bridge port using full-duplex (true) or half-duplex (false).\n"
                },
                "portNumber": {
                    "type": "integer",
                    "description": "Port number will be assigned in the order that ports got added to the bridge, but this is only true until reboot. After\nreboot internal numbering will be used.\n"
                },
                "priority": {
                    "type": "string",
                    "description": "The priority of the interface, used by STP to determine the root port, used by MSTP to determine root port between\nregions.\n"
                },
                "pvid": {
                    "type": "integer",
                    "description": "ort VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. This property only has effect when\nvlan-filtering is set to yes.\n"
                },
                "restrictedRole": {
                    "type": "boolean",
                    "description": "Enable the restricted role on a port, used by STP to forbid a port becoming a root port. This property only has effect\nwhen protocol-mode is set to mstp.\n"
                },
                "restrictedTcn": {
                    "type": "boolean",
                    "description": "Disable topology change notification (TCN) sending on a port, used by STP to forbid network topology changes to\npropagate. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "role": {
                    "type": "string",
                    "description": "(R/M)STP algorithm assigned role of the port\n"
                },
                "rootPathCost": {
                    "type": "integer",
                    "description": "The total cost of the path to the root-bridge.\n"
                },
                "sendingRstp": {
                    "type": "string",
                    "description": "Whether the port is sending RSTP or MSTP BPDU types. A port will transit to STP type when RSTP/MSTP enabled port\nreceives a STP BPDU\n"
                },
                "status": {
                    "type": "string",
                    "description": "Port status ('in-bridge' - port is enabled).\n"
                },
                "tagStacking": {
                    "type": "boolean",
                    "description": "Forces all packets to be treated as untagged packets. Packets on ingress port will be tagged with another VLAN tag\nregardless if a VLAN tag already exists, packets will be tagged with a VLAN ID that matches the pvid value and will use\nEtherType that is specified in ether-type. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "trusted": {
                    "type": "boolean",
                    "description": "When enabled, it allows to forward DHCP packets towards DHCP server through this port. Mainly used to limit unauthorized\nservers to provide malicious information for users. This property only has effect when dhcp-snooping is set to yes.\n"
                },
                "unknownMulticastFlood": {
                    "type": "boolean",
                    "description": "When enabled, bridge floods unknown multicast traffic to all bridge egress ports.\n"
                },
                "unknownUnicastFlood": {
                    "type": "boolean",
                    "description": "When enabled, bridge floods unknown unicast traffic to all bridge egress ports.\n"
                }
            },
            "required": [
                "bridge",
                "debugInfo",
                "designatedBridge",
                "designatedCost",
                "designatedPortNumber",
                "dynamic",
                "edgePort",
                "edgePortDiscovery",
                "externalFdbStatus",
                "forwarding",
                "hw",
                "hwOffload",
                "hwOffloadGroup",
                "inactive",
                "ingressFiltering",
                "interface",
                "learning",
                "nextid",
                "pointToPointPort",
                "portNumber",
                "pvid",
                "role",
                "rootPathCost",
                "sendingRstp",
                "status"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "autoIsolate": {
                    "type": "boolean",
                    "description": "When enabled, prevents a port moving from discarding into forwarding state if no BPDUs are received from the neighboring\nbridge. The port will change into a forwarding state only when a BPDU is received. This property only has an effect when\nprotocol-mode is set to rstp or mstp and edge is set to no.\n"
                },
                "bpduGuard": {
                    "type": "boolean",
                    "description": "This property has no effect when protocol-mode is set to none.\n"
                },
                "bridge": {
                    "type": "string"
                },
                "broadcastFlood": {
                    "type": "boolean",
                    "description": "When enabled, bridge floods broadcast traffic to all bridge egress ports. When disabled, drops broadcast traffic on\negress ports.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "edge": {
                    "type": "string",
                    "description": "Set port as edge port or non-edge port, or enable edge discovery. Edge ports are connected to a LAN that has no other\nbridges attached.\n"
                },
                "fastLeave": {
                    "type": "boolean",
                    "description": "Enables IGMP Fast leave feature on the port.\n"
                },
                "frameTypes": {
                    "type": "string",
                    "description": "Specifies allowed ingress frame types on a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "horizon": {
                    "type": "string",
                    "description": "Use split horizon bridging to prevent bridging loops. Set the same value for group of ports, to prevent them from\nsending data to ports with the same horizon value. Split horizon is a software feature that disables hardware\noffloading. This value is integer '0'..'429496729' or 'none'.\n"
                },
                "hw": {
                    "type": "boolean",
                    "description": "Enable or disable Hardware Offloading of the interface.\n"
                },
                "ingressFiltering": {
                    "type": "boolean",
                    "description": "Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the\nbridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This\nproperty only has effect when vlan-filtering is set to yes.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "internalPathCost": {
                    "type": "integer",
                    "description": "Path cost to the interface for MSTI0 inside a region. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "learn": {
                    "type": "string",
                    "description": "Changes MAC learning behaviour on a bridge port\n"
                },
                "multicastRouter": {
                    "type": "string",
                    "description": "Changes the state of a bridge port whether IGMP membership reports are going to be forwarded to this port.\n"
                },
                "pathCost": {
                    "type": "string",
                    "description": "Path cost to the interface, used by STP to determine the \"best\" path, used by MSTP todetermine \"best\" path between\nregions. This property has no effect when protocol-mode is set to none.\n"
                },
                "pointToPoint": {
                    "type": "string",
                    "description": "Specifies if a bridge port is connected to a bridge using a point-to-point link for faster convergence in case of\nfailure. This property has no effect when protocol-mode is set to none.\n"
                },
                "priority": {
                    "type": "string",
                    "description": "The priority of the interface, used by STP to determine the root port, used by MSTP to determine root port between\nregions.\n"
                },
                "pvid": {
                    "type": "integer",
                    "description": "ort VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. This property only has effect when\nvlan-filtering is set to yes.\n"
                },
                "restrictedRole": {
                    "type": "boolean",
                    "description": "Enable the restricted role on a port, used by STP to forbid a port becoming a root port. This property only has effect\nwhen protocol-mode is set to mstp.\n"
                },
                "restrictedTcn": {
                    "type": "boolean",
                    "description": "Disable topology change notification (TCN) sending on a port, used by STP to forbid network topology changes to\npropagate. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "tagStacking": {
                    "type": "boolean",
                    "description": "Forces all packets to be treated as untagged packets. Packets on ingress port will be tagged with another VLAN tag\nregardless if a VLAN tag already exists, packets will be tagged with a VLAN ID that matches the pvid value and will use\nEtherType that is specified in ether-type. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "trusted": {
                    "type": "boolean",
                    "description": "When enabled, it allows to forward DHCP packets towards DHCP server through this port. Mainly used to limit unauthorized\nservers to provide malicious information for users. This property only has effect when dhcp-snooping is set to yes.\n"
                },
                "unknownMulticastFlood": {
                    "type": "boolean",
                    "description": "When enabled, bridge floods unknown multicast traffic to all bridge egress ports.\n"
                },
                "unknownUnicastFlood": {
                    "type": "boolean",
                    "description": "When enabled, bridge floods unknown unicast traffic to all bridge egress ports.\n"
                }
            },
            "requiredInputs": [
                "bridge",
                "interface",
                "pvid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BridgePort resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "autoIsolate": {
                        "type": "boolean",
                        "description": "When enabled, prevents a port moving from discarding into forwarding state if no BPDUs are received from the neighboring\nbridge. The port will change into a forwarding state only when a BPDU is received. This property only has an effect when\nprotocol-mode is set to rstp or mstp and edge is set to no.\n"
                    },
                    "bpduGuard": {
                        "type": "boolean",
                        "description": "This property has no effect when protocol-mode is set to none.\n"
                    },
                    "bridge": {
                        "type": "string"
                    },
                    "broadcastFlood": {
                        "type": "boolean",
                        "description": "When enabled, bridge floods broadcast traffic to all bridge egress ports. When disabled, drops broadcast traffic on\negress ports.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "debugInfo": {
                        "type": "string"
                    },
                    "designatedBridge": {
                        "type": "string",
                        "description": "Root bridge ID (bridge priority and the bridge MAC address).\n"
                    },
                    "designatedCost": {
                        "type": "string",
                        "description": "Designated cost.\n"
                    },
                    "designatedPortNumber": {
                        "type": "integer",
                        "description": "Designated port number.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "edge": {
                        "type": "string",
                        "description": "Set port as edge port or non-edge port, or enable edge discovery. Edge ports are connected to a LAN that has no other\nbridges attached.\n"
                    },
                    "edgePort": {
                        "type": "boolean",
                        "description": "Whether port is an edge port or not.\n"
                    },
                    "edgePortDiscovery": {
                        "type": "boolean",
                        "description": "Whether port is set to automatically detect edge ports.\n"
                    },
                    "externalFdbStatus": {
                        "type": "boolean",
                        "description": "Whether registration table is used instead of forwarding data base.\n"
                    },
                    "fastLeave": {
                        "type": "boolean",
                        "description": "Enables IGMP Fast leave feature on the port.\n"
                    },
                    "forwarding": {
                        "type": "boolean",
                        "description": "Shows if the port is not blocked by (R/M)STP.\n"
                    },
                    "frameTypes": {
                        "type": "string",
                        "description": "Specifies allowed ingress frame types on a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                    },
                    "horizon": {
                        "type": "string",
                        "description": "Use split horizon bridging to prevent bridging loops. Set the same value for group of ports, to prevent them from\nsending data to ports with the same horizon value. Split horizon is a software feature that disables hardware\noffloading. This value is integer '0'..'429496729' or 'none'.\n"
                    },
                    "hw": {
                        "type": "boolean",
                        "description": "Enable or disable Hardware Offloading of the interface.\n"
                    },
                    "hwOffload": {
                        "type": "boolean",
                        "description": "Hardware offloading state.\n"
                    },
                    "hwOffloadGroup": {
                        "type": "string",
                        "description": "Switch chip used by the port.\n"
                    },
                    "inactive": {
                        "type": "boolean"
                    },
                    "ingressFiltering": {
                        "type": "boolean",
                        "description": "Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the\nbridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This\nproperty only has effect when vlan-filtering is set to yes.\n"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "internalPathCost": {
                        "type": "integer",
                        "description": "Path cost to the interface for MSTI0 inside a region. This property only has effect when protocol-mode is set to mstp.\n"
                    },
                    "learn": {
                        "type": "string",
                        "description": "Changes MAC learning behaviour on a bridge port\n"
                    },
                    "learning": {
                        "type": "boolean",
                        "description": "Shows whether the port is capable of learning MAC addresses.\n"
                    },
                    "multicastRouter": {
                        "type": "string",
                        "description": "Changes the state of a bridge port whether IGMP membership reports are going to be forwarded to this port.\n"
                    },
                    "nextid": {
                        "type": "string"
                    },
                    "pathCost": {
                        "type": "string",
                        "description": "Path cost to the interface, used by STP to determine the \"best\" path, used by MSTP todetermine \"best\" path between\nregions. This property has no effect when protocol-mode is set to none.\n"
                    },
                    "pointToPoint": {
                        "type": "string",
                        "description": "Specifies if a bridge port is connected to a bridge using a point-to-point link for faster convergence in case of\nfailure. This property has no effect when protocol-mode is set to none.\n"
                    },
                    "pointToPointPort": {
                        "type": "boolean",
                        "description": "Whether the port is connected to a bridge port using full-duplex (true) or half-duplex (false).\n"
                    },
                    "portNumber": {
                        "type": "integer",
                        "description": "Port number will be assigned in the order that ports got added to the bridge, but this is only true until reboot. After\nreboot internal numbering will be used.\n"
                    },
                    "priority": {
                        "type": "string",
                        "description": "The priority of the interface, used by STP to determine the root port, used by MSTP to determine root port between\nregions.\n"
                    },
                    "pvid": {
                        "type": "integer",
                        "description": "ort VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. This property only has effect when\nvlan-filtering is set to yes.\n"
                    },
                    "restrictedRole": {
                        "type": "boolean",
                        "description": "Enable the restricted role on a port, used by STP to forbid a port becoming a root port. This property only has effect\nwhen protocol-mode is set to mstp.\n"
                    },
                    "restrictedTcn": {
                        "type": "boolean",
                        "description": "Disable topology change notification (TCN) sending on a port, used by STP to forbid network topology changes to\npropagate. This property only has effect when protocol-mode is set to mstp.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "(R/M)STP algorithm assigned role of the port\n"
                    },
                    "rootPathCost": {
                        "type": "integer",
                        "description": "The total cost of the path to the root-bridge.\n"
                    },
                    "sendingRstp": {
                        "type": "string",
                        "description": "Whether the port is sending RSTP or MSTP BPDU types. A port will transit to STP type when RSTP/MSTP enabled port\nreceives a STP BPDU\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Port status ('in-bridge' - port is enabled).\n"
                    },
                    "tagStacking": {
                        "type": "boolean",
                        "description": "Forces all packets to be treated as untagged packets. Packets on ingress port will be tagged with another VLAN tag\nregardless if a VLAN tag already exists, packets will be tagged with a VLAN ID that matches the pvid value and will use\nEtherType that is specified in ether-type. This property only has effect when vlan-filtering is set to yes.\n"
                    },
                    "trusted": {
                        "type": "boolean",
                        "description": "When enabled, it allows to forward DHCP packets towards DHCP server through this port. Mainly used to limit unauthorized\nservers to provide malicious information for users. This property only has effect when dhcp-snooping is set to yes.\n"
                    },
                    "unknownMulticastFlood": {
                        "type": "boolean",
                        "description": "When enabled, bridge floods unknown multicast traffic to all bridge egress ports.\n"
                    },
                    "unknownUnicastFlood": {
                        "type": "boolean",
                        "description": "When enabled, bridge floods unknown unicast traffic to all bridge egress ports.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/bridgeVlan:BridgeVlan": {
            "description": "## # routeros.Iface.BridgeVlan (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Iface.InterfaceBridgeVlan\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "The bridge interface which the respective VLAN entry is intended for.\n"
                },
                "comment": {
                    "type": "string"
                },
                "currentTaggeds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "currentUntaggeds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "taggeds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Interface list with a VLAN tag adding action in egress. This setting accepts comma separated values. E.g.\ntagged=ether1,ether2.\n"
                },
                "untaggeds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Interface list with a VLAN tag removing action in egress. This setting accepts comma separated values. E.g.\nuntagged=ether3,ether4\n"
                },
                "vlanIds": {
                    "type": "string",
                    "description": "The list of VLAN IDs for certain port configuration. This setting accepts VLAN ID range as well as comma separated\nvalues. E.g. vlan-ids=100-115,120,122,128-130.\n"
                }
            },
            "required": [
                "bridge",
                "currentTaggeds",
                "currentUntaggeds",
                "dynamic",
                "vlanIds"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "The bridge interface which the respective VLAN entry is intended for.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "taggeds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Interface list with a VLAN tag adding action in egress. This setting accepts comma separated values. E.g.\ntagged=ether1,ether2.\n"
                },
                "untaggeds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Interface list with a VLAN tag removing action in egress. This setting accepts comma separated values. E.g.\nuntagged=ether3,ether4\n"
                },
                "vlanIds": {
                    "type": "string",
                    "description": "The list of VLAN IDs for certain port configuration. This setting accepts VLAN ID range as well as comma separated\nvalues. E.g. vlan-ids=100-115,120,122,128-130.\n"
                }
            },
            "requiredInputs": [
                "bridge",
                "vlanIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering BridgeVlan resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "bridge": {
                        "type": "string",
                        "description": "The bridge interface which the respective VLAN entry is intended for.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "currentTaggeds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "currentUntaggeds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "taggeds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Interface list with a VLAN tag adding action in egress. This setting accepts comma separated values. E.g.\ntagged=ether1,ether2.\n"
                    },
                    "untaggeds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Interface list with a VLAN tag removing action in egress. This setting accepts comma separated values. E.g.\nuntagged=ether3,ether4\n"
                    },
                    "vlanIds": {
                        "type": "string",
                        "description": "The list of VLAN IDs for certain port configuration. This setting accepts VLAN ID range as well as comma separated\nvalues. E.g. vlan-ids=100-115,120,122,128-130.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/gre:Gre": {
            "description": "## # routeros.Iface.Gre (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Iface.InterfaceGre\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "actualMtu": {
                    "type": "integer"
                },
                "allowFastPath": {
                    "type": "boolean",
                    "description": "Whether to allow FastPath processing. Must be disabled if IPsec tunneling is used.\n"
                },
                "clampTcpMss": {
                    "type": "boolean",
                    "description": "Controls whether to change MSS size for received TCP SYN packets. When enabled, a router will change the MSS size for\nreceived TCP SYN packets if the current MSS size exceeds the tunnel interface MTU (taking into account the TCP/IP\noverhead). The received encapsulated packet will still contain the original MSS, and only after decapsulation the MSS is\nchanged.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dontFragment": {
                    "type": "string"
                },
                "dscp": {
                    "type": "string",
                    "description": "Set dscp value in GRE header to a fixed value '0..63' or 'inherit' from dscp value taken from tunnelled traffic.\n"
                },
                "ipsecSecret": {
                    "type": "string",
                    "description": "When secret is specified, router adds dynamic IPsec peer to remote-address with pre-shared key and policy (by default\nphase2 uses sha1/aes128cbc).\n",
                    "secret": true
                },
                "keepalive": {
                    "type": "string",
                    "description": "Tunnel keepalive parameter sets the time interval in which the tunnel running flag will remain even if the remote end of\ntunnel goes down. If configured time,retries fail, interface running flag is removed. Parameters are written in\nfollowing format: KeepaliveInterval,KeepaliveRetries where KeepaliveInterval is time interval and KeepaliveRetries -\nnumber of retry attempts. KeepaliveInterval is integer 0..4294967295\n"
                },
                "l2mtu": {
                    "type": "integer",
                    "description": "Layer2 Maximum transmission unit.\n"
                },
                "localAddress": {
                    "type": "string"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "remoteAddress": {
                    "type": "string"
                },
                "running": {
                    "type": "boolean"
                }
            },
            "required": [
                "actualMtu",
                "l2mtu",
                "mtu",
                "name",
                "remoteAddress",
                "running"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "allowFastPath": {
                    "type": "boolean",
                    "description": "Whether to allow FastPath processing. Must be disabled if IPsec tunneling is used.\n"
                },
                "clampTcpMss": {
                    "type": "boolean",
                    "description": "Controls whether to change MSS size for received TCP SYN packets. When enabled, a router will change the MSS size for\nreceived TCP SYN packets if the current MSS size exceeds the tunnel interface MTU (taking into account the TCP/IP\noverhead). The received encapsulated packet will still contain the original MSS, and only after decapsulation the MSS is\nchanged.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dontFragment": {
                    "type": "string"
                },
                "dscp": {
                    "type": "string",
                    "description": "Set dscp value in GRE header to a fixed value '0..63' or 'inherit' from dscp value taken from tunnelled traffic.\n"
                },
                "ipsecSecret": {
                    "type": "string",
                    "description": "When secret is specified, router adds dynamic IPsec peer to remote-address with pre-shared key and policy (by default\nphase2 uses sha1/aes128cbc).\n",
                    "secret": true
                },
                "keepalive": {
                    "type": "string",
                    "description": "Tunnel keepalive parameter sets the time interval in which the tunnel running flag will remain even if the remote end of\ntunnel goes down. If configured time,retries fail, interface running flag is removed. Parameters are written in\nfollowing format: KeepaliveInterval,KeepaliveRetries where KeepaliveInterval is time interval and KeepaliveRetries -\nnumber of retry attempts. KeepaliveInterval is integer 0..4294967295\n"
                },
                "localAddress": {
                    "type": "string"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "remoteAddress": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "remoteAddress"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Gre resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "actualMtu": {
                        "type": "integer"
                    },
                    "allowFastPath": {
                        "type": "boolean",
                        "description": "Whether to allow FastPath processing. Must be disabled if IPsec tunneling is used.\n"
                    },
                    "clampTcpMss": {
                        "type": "boolean",
                        "description": "Controls whether to change MSS size for received TCP SYN packets. When enabled, a router will change the MSS size for\nreceived TCP SYN packets if the current MSS size exceeds the tunnel interface MTU (taking into account the TCP/IP\noverhead). The received encapsulated packet will still contain the original MSS, and only after decapsulation the MSS is\nchanged.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dontFragment": {
                        "type": "string"
                    },
                    "dscp": {
                        "type": "string",
                        "description": "Set dscp value in GRE header to a fixed value '0..63' or 'inherit' from dscp value taken from tunnelled traffic.\n"
                    },
                    "ipsecSecret": {
                        "type": "string",
                        "description": "When secret is specified, router adds dynamic IPsec peer to remote-address with pre-shared key and policy (by default\nphase2 uses sha1/aes128cbc).\n",
                        "secret": true
                    },
                    "keepalive": {
                        "type": "string",
                        "description": "Tunnel keepalive parameter sets the time interval in which the tunnel running flag will remain even if the remote end of\ntunnel goes down. If configured time,retries fail, interface running flag is removed. Parameters are written in\nfollowing format: KeepaliveInterval,KeepaliveRetries where KeepaliveInterval is time interval and KeepaliveRetries -\nnumber of retry attempts. KeepaliveInterval is integer 0..4294967295\n"
                    },
                    "l2mtu": {
                        "type": "integer",
                        "description": "Layer2 Maximum transmission unit.\n"
                    },
                    "localAddress": {
                        "type": "string"
                    },
                    "mtu": {
                        "type": "string",
                        "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "remoteAddress": {
                        "type": "string"
                    },
                    "running": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/interfaceBridge:InterfaceBridge": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst bridge = new routeros.iface.InterfaceBridge(\"bridge\", {vlanFiltering: true});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nbridge = routeros.iface.InterfaceBridge(\"bridge\", vlan_filtering=True)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var bridge = new Routeros.Iface.InterfaceBridge(\"bridge\", new()\n    {\n        VlanFiltering = true,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Iface\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Iface.NewInterfaceBridge(ctx, \"bridge\", \u0026Iface.InterfaceBridgeArgs{\n\t\t\tVlanFiltering: pulumi.Bool(true),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Iface.InterfaceBridge;\nimport com.pulumi.routeros.Iface.InterfaceBridgeArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var bridge = new InterfaceBridge(\"bridge\", InterfaceBridgeArgs.builder()        \n            .vlanFiltering(true)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  bridge:\n    type: routeros:Iface:InterfaceBridge\n    properties:\n      vlanFiltering: true\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport with the name of the bridge in case of the example use bridge\n\n```sh\n $ pulumi import routeros:Iface/interfaceBridge:InterfaceBridge bridge bridge\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "actualMtu": {
                    "type": "integer"
                },
                "addDhcpOption82": {
                    "type": "boolean",
                    "description": "Whether to add DHCP Option-82 information (Agent Remote ID and Agent Circuit ID) to DHCP packets. Can be used together with Option-82 capable DHCP server to assign IP addresses and implement policies. This property only has effect when dhcp-snooping is set to yes.\n"
                },
                "adminMac": {
                    "type": "string",
                    "description": "Static MAC address of the bridge. This property only has effect when auto-mac is set to no.\n"
                },
                "ageingTime": {
                    "type": "string",
                    "description": "How long a host's information will be kept in the bridge database.\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP resolution protocol mode.\n"
                },
                "arpTimeout": {
                    "type": "string",
                    "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to the value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds, minutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                },
                "autoMac": {
                    "type": "boolean",
                    "description": "Automatically select one MAC address of bridge ports as a bridge MAC address, bridge MAC will be chosen from the first added bridge port. After a device reboot, the bridge MAC can change depending on the port-number.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcpSnooping": {
                    "type": "boolean"
                },
                "disabled": {
                    "type": "boolean"
                },
                "etherType": {
                    "type": "string",
                    "description": "This property only has effect when vlan-filtering is set to yes.\n"
                },
                "fastForward": {
                    "type": "boolean"
                },
                "forwardDelay": {
                    "type": "string",
                    "description": "Time which is spent during the initialization phase of the bridge interface (i.e., after router startup or enabling the interface) in listening/learning state before the bridge will start functioning normally.\n"
                },
                "frameTypes": {
                    "type": "string",
                    "description": "Specifies allowed frame types on a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "igmpSnooping": {
                    "type": "boolean",
                    "description": "Enables multicast group and port learning to prevent multicast traffic from flooding all interfaces in a bridge.\n"
                },
                "igmpVersion": {
                    "type": "integer",
                    "description": "Selects the IGMP version in which IGMP general membership queries will be generated. This property only has effect when igmp-snooping is set to yes.\n"
                },
                "ingressFiltering": {
                    "type": "boolean",
                    "description": "Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the bridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "l2mtu": {
                    "type": "integer",
                    "description": "Layer2 Maximum transmission unit.\n"
                },
                "lastMemberInterval": {
                    "type": "string",
                    "description": "If a port has fast-leave set to no and a bridge port receives a IGMP Leave message, then a IGMP Snooping enabled bridge will send a IGMP query to make sure that no devices has subscribed to a certain multicast stream on a bridge port.\n"
                },
                "lastMemberQueryCount": {
                    "type": "integer",
                    "description": "How many times should last-member-interval pass until a IGMP Snooping bridge will stop forwarding a certain multicast stream. This property only has effect when igmp-snooping is set to yes.\n"
                },
                "macAddress": {
                    "type": "string"
                },
                "maxHops": {
                    "type": "integer",
                    "description": "Bridge count which BPDU can pass in a MSTP enabled network in the same region before BPDU is being ignored. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "maxMessageAge": {
                    "type": "string",
                    "description": "Changes the Max Age value in BPDU packets, which is transmitted by the root bridge. This property only has effect when protocol-mode is set to stp or rstp. Value: 6s..40s\n"
                },
                "membershipInterval": {
                    "type": "string",
                    "description": "Amount of time after an entry in the Multicast Database (MDB) is removed if a IGMP membership report is not received on a certain port. This property only has effect when igmp-snooping is set to yes.\n"
                },
                "mldVersion": {
                    "type": "integer",
                    "description": "Selects the MLD version. Version 2 adds support for source-specific multicast. This property only has effect when RouterOS IPv6 package is enabled and igmp-snooping is set to yes.\n"
                },
                "mtu": {
                    "type": "string",
                    "description": "The default bridge MTU value without any bridge ports added is 1500. The MTU value can be set manually, but it cannot exceed the bridge L2MTU or the lowest bridge port L2MTU. If a new bridge port is added with L2MTU which is smaller than the actual-mtu of the bridge (set by the mtu property), then manually set value will be ignored and the bridge will act as if mtu=auto is set.\n"
                },
                "multicastQuerier": {
                    "type": "boolean",
                    "description": "Multicast querier generates IGMP general membership queries to which all IGMP capable devices respond with an IGMP membership report, usually a PIM (multicast) router or IGMP proxy generates these queries. This property only has an effect when igmp-snooping is set to yes. Additionally, the igmp-snooping should be disabled/enabled after changing multicast-querier property.\n"
                },
                "multicastRouter": {
                    "type": "string",
                    "description": "A multicast router port is a port where a multicast router or querier is connected. On this port, unregistered multicast streams and IGMP/MLD membership reports will be sent. This setting changes the state of the multicast router for a bridge interface itself. This property can be used to send IGMP/MLD membership reports and multicast traffic to the bridge interface for further multicast routing or proxying. This property only has an effect when igmp-snooping is set to yes.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "priority": {
                    "type": "string",
                    "description": "Bridge priority, used by STP to determine root bridge, used by MSTP to determine CIST and IST regional root bridge. This property has no effect when protocol-mode is set to none.\n"
                },
                "protocolMode": {
                    "type": "string",
                    "description": "Select Spanning tree protocol (STP) or Rapid spanning tree protocol (RSTP) to ensure a loop-free topology for any bridged LAN.\n"
                },
                "pvid": {
                    "type": "integer",
                    "description": "Port VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. It applies e.g. to frames sent from bridge IP and destined to a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "querierInterval": {
                    "type": "string",
                    "description": "Used to change the interval how often a bridge checks if it is the active multicast querier. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "queryInterval": {
                    "type": "string",
                    "description": "Used to change the interval how often IGMP general membership queries are sent out. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "queryResponseInterval": {
                    "type": "string",
                    "description": "Interval in which a IGMP capable device must reply to a IGMP query with a IGMP membership report. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "MSTP region name. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "regionRevision": {
                    "type": "integer",
                    "description": "MSTP configuration revision number. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "running": {
                    "type": "boolean"
                },
                "startupQueryCount": {
                    "type": "integer",
                    "description": "Specifies how many times must startup-query-interval pass until the bridge starts sending out IGMP general membership queries periodically. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "startupQueryInterval": {
                    "type": "string",
                    "description": "Used to change the amount of time after a bridge starts sending out IGMP general membership queries after the bridge is enabled. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "transmitHoldCount": {
                    "type": "integer",
                    "description": "The Transmit Hold Count used by the Port Transmit state machine to limit transmission rate.\n"
                },
                "vlanFiltering": {
                    "type": "boolean",
                    "description": "Globally enables or disables VLAN functionality for bridge.\n"
                }
            },
            "required": [
                "actualMtu",
                "adminMac",
                "fastForward",
                "igmpVersion",
                "l2mtu",
                "lastMemberInterval",
                "lastMemberQueryCount",
                "macAddress",
                "maxHops",
                "membershipInterval",
                "mldVersion",
                "multicastRouter",
                "name",
                "querierInterval",
                "queryInterval",
                "queryResponseInterval",
                "running",
                "startupQueryCount",
                "startupQueryInterval"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "addDhcpOption82": {
                    "type": "boolean",
                    "description": "Whether to add DHCP Option-82 information (Agent Remote ID and Agent Circuit ID) to DHCP packets. Can be used together with Option-82 capable DHCP server to assign IP addresses and implement policies. This property only has effect when dhcp-snooping is set to yes.\n"
                },
                "adminMac": {
                    "type": "string",
                    "description": "Static MAC address of the bridge. This property only has effect when auto-mac is set to no.\n"
                },
                "ageingTime": {
                    "type": "string",
                    "description": "How long a host's information will be kept in the bridge database.\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP resolution protocol mode.\n"
                },
                "arpTimeout": {
                    "type": "string",
                    "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to the value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds, minutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                },
                "autoMac": {
                    "type": "boolean",
                    "description": "Automatically select one MAC address of bridge ports as a bridge MAC address, bridge MAC will be chosen from the first added bridge port. After a device reboot, the bridge MAC can change depending on the port-number.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcpSnooping": {
                    "type": "boolean"
                },
                "disabled": {
                    "type": "boolean"
                },
                "etherType": {
                    "type": "string",
                    "description": "This property only has effect when vlan-filtering is set to yes.\n"
                },
                "fastForward": {
                    "type": "boolean"
                },
                "forwardDelay": {
                    "type": "string",
                    "description": "Time which is spent during the initialization phase of the bridge interface (i.e., after router startup or enabling the interface) in listening/learning state before the bridge will start functioning normally.\n"
                },
                "frameTypes": {
                    "type": "string",
                    "description": "Specifies allowed frame types on a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "igmpSnooping": {
                    "type": "boolean",
                    "description": "Enables multicast group and port learning to prevent multicast traffic from flooding all interfaces in a bridge.\n"
                },
                "igmpVersion": {
                    "type": "integer",
                    "description": "Selects the IGMP version in which IGMP general membership queries will be generated. This property only has effect when igmp-snooping is set to yes.\n"
                },
                "ingressFiltering": {
                    "type": "boolean",
                    "description": "Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the bridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "lastMemberInterval": {
                    "type": "string",
                    "description": "If a port has fast-leave set to no and a bridge port receives a IGMP Leave message, then a IGMP Snooping enabled bridge will send a IGMP query to make sure that no devices has subscribed to a certain multicast stream on a bridge port.\n"
                },
                "lastMemberQueryCount": {
                    "type": "integer",
                    "description": "How many times should last-member-interval pass until a IGMP Snooping bridge will stop forwarding a certain multicast stream. This property only has effect when igmp-snooping is set to yes.\n"
                },
                "maxHops": {
                    "type": "integer",
                    "description": "Bridge count which BPDU can pass in a MSTP enabled network in the same region before BPDU is being ignored. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "maxMessageAge": {
                    "type": "string",
                    "description": "Changes the Max Age value in BPDU packets, which is transmitted by the root bridge. This property only has effect when protocol-mode is set to stp or rstp. Value: 6s..40s\n"
                },
                "membershipInterval": {
                    "type": "string",
                    "description": "Amount of time after an entry in the Multicast Database (MDB) is removed if a IGMP membership report is not received on a certain port. This property only has effect when igmp-snooping is set to yes.\n"
                },
                "mldVersion": {
                    "type": "integer",
                    "description": "Selects the MLD version. Version 2 adds support for source-specific multicast. This property only has effect when RouterOS IPv6 package is enabled and igmp-snooping is set to yes.\n"
                },
                "mtu": {
                    "type": "string",
                    "description": "The default bridge MTU value without any bridge ports added is 1500. The MTU value can be set manually, but it cannot exceed the bridge L2MTU or the lowest bridge port L2MTU. If a new bridge port is added with L2MTU which is smaller than the actual-mtu of the bridge (set by the mtu property), then manually set value will be ignored and the bridge will act as if mtu=auto is set.\n"
                },
                "multicastQuerier": {
                    "type": "boolean",
                    "description": "Multicast querier generates IGMP general membership queries to which all IGMP capable devices respond with an IGMP membership report, usually a PIM (multicast) router or IGMP proxy generates these queries. This property only has an effect when igmp-snooping is set to yes. Additionally, the igmp-snooping should be disabled/enabled after changing multicast-querier property.\n"
                },
                "multicastRouter": {
                    "type": "string",
                    "description": "A multicast router port is a port where a multicast router or querier is connected. On this port, unregistered multicast streams and IGMP/MLD membership reports will be sent. This setting changes the state of the multicast router for a bridge interface itself. This property can be used to send IGMP/MLD membership reports and multicast traffic to the bridge interface for further multicast routing or proxying. This property only has an effect when igmp-snooping is set to yes.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "priority": {
                    "type": "string",
                    "description": "Bridge priority, used by STP to determine root bridge, used by MSTP to determine CIST and IST regional root bridge. This property has no effect when protocol-mode is set to none.\n"
                },
                "protocolMode": {
                    "type": "string",
                    "description": "Select Spanning tree protocol (STP) or Rapid spanning tree protocol (RSTP) to ensure a loop-free topology for any bridged LAN.\n"
                },
                "pvid": {
                    "type": "integer",
                    "description": "Port VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. It applies e.g. to frames sent from bridge IP and destined to a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "querierInterval": {
                    "type": "string",
                    "description": "Used to change the interval how often a bridge checks if it is the active multicast querier. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "queryInterval": {
                    "type": "string",
                    "description": "Used to change the interval how often IGMP general membership queries are sent out. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "queryResponseInterval": {
                    "type": "string",
                    "description": "Interval in which a IGMP capable device must reply to a IGMP query with a IGMP membership report. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "regionName": {
                    "type": "string",
                    "description": "MSTP region name. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "regionRevision": {
                    "type": "integer",
                    "description": "MSTP configuration revision number. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "startupQueryCount": {
                    "type": "integer",
                    "description": "Specifies how many times must startup-query-interval pass until the bridge starts sending out IGMP general membership queries periodically. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "startupQueryInterval": {
                    "type": "string",
                    "description": "Used to change the amount of time after a bridge starts sending out IGMP general membership queries after the bridge is enabled. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                },
                "transmitHoldCount": {
                    "type": "integer",
                    "description": "The Transmit Hold Count used by the Port Transmit state machine to limit transmission rate.\n"
                },
                "vlanFiltering": {
                    "type": "boolean",
                    "description": "Globally enables or disables VLAN functionality for bridge.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InterfaceBridge resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "actualMtu": {
                        "type": "integer"
                    },
                    "addDhcpOption82": {
                        "type": "boolean",
                        "description": "Whether to add DHCP Option-82 information (Agent Remote ID and Agent Circuit ID) to DHCP packets. Can be used together with Option-82 capable DHCP server to assign IP addresses and implement policies. This property only has effect when dhcp-snooping is set to yes.\n"
                    },
                    "adminMac": {
                        "type": "string",
                        "description": "Static MAC address of the bridge. This property only has effect when auto-mac is set to no.\n"
                    },
                    "ageingTime": {
                        "type": "string",
                        "description": "How long a host's information will be kept in the bridge database.\n"
                    },
                    "arp": {
                        "type": "string",
                        "description": "ARP resolution protocol mode.\n"
                    },
                    "arpTimeout": {
                        "type": "string",
                        "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to the value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds, minutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                    },
                    "autoMac": {
                        "type": "boolean",
                        "description": "Automatically select one MAC address of bridge ports as a bridge MAC address, bridge MAC will be chosen from the first added bridge port. After a device reboot, the bridge MAC can change depending on the port-number.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "dhcpSnooping": {
                        "type": "boolean"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "etherType": {
                        "type": "string",
                        "description": "This property only has effect when vlan-filtering is set to yes.\n"
                    },
                    "fastForward": {
                        "type": "boolean"
                    },
                    "forwardDelay": {
                        "type": "string",
                        "description": "Time which is spent during the initialization phase of the bridge interface (i.e., after router startup or enabling the interface) in listening/learning state before the bridge will start functioning normally.\n"
                    },
                    "frameTypes": {
                        "type": "string",
                        "description": "Specifies allowed frame types on a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                    },
                    "igmpSnooping": {
                        "type": "boolean",
                        "description": "Enables multicast group and port learning to prevent multicast traffic from flooding all interfaces in a bridge.\n"
                    },
                    "igmpVersion": {
                        "type": "integer",
                        "description": "Selects the IGMP version in which IGMP general membership queries will be generated. This property only has effect when igmp-snooping is set to yes.\n"
                    },
                    "ingressFiltering": {
                        "type": "boolean",
                        "description": "Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the bridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This property only has effect when vlan-filtering is set to yes.\n"
                    },
                    "l2mtu": {
                        "type": "integer",
                        "description": "Layer2 Maximum transmission unit.\n"
                    },
                    "lastMemberInterval": {
                        "type": "string",
                        "description": "If a port has fast-leave set to no and a bridge port receives a IGMP Leave message, then a IGMP Snooping enabled bridge will send a IGMP query to make sure that no devices has subscribed to a certain multicast stream on a bridge port.\n"
                    },
                    "lastMemberQueryCount": {
                        "type": "integer",
                        "description": "How many times should last-member-interval pass until a IGMP Snooping bridge will stop forwarding a certain multicast stream. This property only has effect when igmp-snooping is set to yes.\n"
                    },
                    "macAddress": {
                        "type": "string"
                    },
                    "maxHops": {
                        "type": "integer",
                        "description": "Bridge count which BPDU can pass in a MSTP enabled network in the same region before BPDU is being ignored. This property only has effect when protocol-mode is set to mstp.\n"
                    },
                    "maxMessageAge": {
                        "type": "string",
                        "description": "Changes the Max Age value in BPDU packets, which is transmitted by the root bridge. This property only has effect when protocol-mode is set to stp or rstp. Value: 6s..40s\n"
                    },
                    "membershipInterval": {
                        "type": "string",
                        "description": "Amount of time after an entry in the Multicast Database (MDB) is removed if a IGMP membership report is not received on a certain port. This property only has effect when igmp-snooping is set to yes.\n"
                    },
                    "mldVersion": {
                        "type": "integer",
                        "description": "Selects the MLD version. Version 2 adds support for source-specific multicast. This property only has effect when RouterOS IPv6 package is enabled and igmp-snooping is set to yes.\n"
                    },
                    "mtu": {
                        "type": "string",
                        "description": "The default bridge MTU value without any bridge ports added is 1500. The MTU value can be set manually, but it cannot exceed the bridge L2MTU or the lowest bridge port L2MTU. If a new bridge port is added with L2MTU which is smaller than the actual-mtu of the bridge (set by the mtu property), then manually set value will be ignored and the bridge will act as if mtu=auto is set.\n"
                    },
                    "multicastQuerier": {
                        "type": "boolean",
                        "description": "Multicast querier generates IGMP general membership queries to which all IGMP capable devices respond with an IGMP membership report, usually a PIM (multicast) router or IGMP proxy generates these queries. This property only has an effect when igmp-snooping is set to yes. Additionally, the igmp-snooping should be disabled/enabled after changing multicast-querier property.\n"
                    },
                    "multicastRouter": {
                        "type": "string",
                        "description": "A multicast router port is a port where a multicast router or querier is connected. On this port, unregistered multicast streams and IGMP/MLD membership reports will be sent. This setting changes the state of the multicast router for a bridge interface itself. This property can be used to send IGMP/MLD membership reports and multicast traffic to the bridge interface for further multicast routing or proxying. This property only has an effect when igmp-snooping is set to yes.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "priority": {
                        "type": "string",
                        "description": "Bridge priority, used by STP to determine root bridge, used by MSTP to determine CIST and IST regional root bridge. This property has no effect when protocol-mode is set to none.\n"
                    },
                    "protocolMode": {
                        "type": "string",
                        "description": "Select Spanning tree protocol (STP) or Rapid spanning tree protocol (RSTP) to ensure a loop-free topology for any bridged LAN.\n"
                    },
                    "pvid": {
                        "type": "integer",
                        "description": "Port VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. It applies e.g. to frames sent from bridge IP and destined to a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                    },
                    "querierInterval": {
                        "type": "string",
                        "description": "Used to change the interval how often a bridge checks if it is the active multicast querier. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                    },
                    "queryInterval": {
                        "type": "string",
                        "description": "Used to change the interval how often IGMP general membership queries are sent out. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                    },
                    "queryResponseInterval": {
                        "type": "string",
                        "description": "Interval in which a IGMP capable device must reply to a IGMP query with a IGMP membership report. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                    },
                    "regionName": {
                        "type": "string",
                        "description": "MSTP region name. This property only has effect when protocol-mode is set to mstp.\n"
                    },
                    "regionRevision": {
                        "type": "integer",
                        "description": "MSTP configuration revision number. This property only has effect when protocol-mode is set to mstp.\n"
                    },
                    "running": {
                        "type": "boolean"
                    },
                    "startupQueryCount": {
                        "type": "integer",
                        "description": "Specifies how many times must startup-query-interval pass until the bridge starts sending out IGMP general membership queries periodically. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                    },
                    "startupQueryInterval": {
                        "type": "string",
                        "description": "Used to change the amount of time after a bridge starts sending out IGMP general membership queries after the bridge is enabled. This property only has effect when igmp-snooping and multicast-querier is set to yes.\n"
                    },
                    "transmitHoldCount": {
                        "type": "integer",
                        "description": "The Transmit Hold Count used by the Port Transmit state machine to limit transmission rate.\n"
                    },
                    "vlanFiltering": {
                        "type": "boolean",
                        "description": "Globally enables or disables VLAN functionality for bridge.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/interfaceBridgePort:InterfaceBridgePort": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst bridgePort = new routeros.iface.InterfaceBridgePort(\"bridgePort\", {\n    bridge: \"bridge\",\n    \"interface\": \"ether5\",\n    pvid: 50,\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nbridge_port = routeros.iface.InterfaceBridgePort(\"bridgePort\",\n    bridge=\"bridge\",\n    interface=\"ether5\",\n    pvid=50)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var bridgePort = new Routeros.Iface.InterfaceBridgePort(\"bridgePort\", new()\n    {\n        Bridge = \"bridge\",\n        Interface = \"ether5\",\n        Pvid = 50,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Iface\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Iface.NewInterfaceBridgePort(ctx, \"bridgePort\", \u0026Iface.InterfaceBridgePortArgs{\n\t\t\tBridge:    pulumi.String(\"bridge\"),\n\t\t\tInterface: pulumi.String(\"ether5\"),\n\t\t\tPvid:      pulumi.Int(50),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Iface.InterfaceBridgePort;\nimport com.pulumi.routeros.Iface.InterfaceBridgePortArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var bridgePort = new InterfaceBridgePort(\"bridgePort\", InterfaceBridgePortArgs.builder()        \n            .bridge(\"bridge\")\n            .interface_(\"ether5\")\n            .pvid(\"50\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  bridgePort:\n    type: routeros:Iface:InterfaceBridgePort\n    properties:\n      bridge: bridge\n      interface: ether5\n      pvid: '50'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/interface/bridge/port get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Iface/interfaceBridgePort:InterfaceBridgePort bridge_port \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "autoIsolate": {
                    "type": "boolean",
                    "description": "When enabled, prevents a port moving from discarding into forwarding state if no BPDUs are received from the neighboring bridge. The port will change into a forwarding state only when a BPDU is received. This property only has an effect when protocol-mode is set to rstp or mstp and edge is set to no.\n"
                },
                "bpduGuard": {
                    "type": "boolean",
                    "description": "This property has no effect when protocol-mode is set to none.\n"
                },
                "bridge": {
                    "type": "string"
                },
                "broadcastFlood": {
                    "type": "boolean",
                    "description": "When enabled, bridge floods broadcast traffic to all bridge egress ports. When disabled, drops broadcast traffic on egress ports.\n"
                },
                "comment": {
                    "type": "string"
                },
                "debugInfo": {
                    "type": "string"
                },
                "designatedBridge": {
                    "type": "string",
                    "description": "Root bridge ID (bridge priority and the bridge MAC address).\n"
                },
                "designatedCost": {
                    "type": "string",
                    "description": "Designated cost.\n"
                },
                "designatedPortNumber": {
                    "type": "integer",
                    "description": "Designated port number.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                },
                "edge": {
                    "type": "string",
                    "description": "Set port as edge port or non-edge port, or enable edge discovery. Edge ports are connected to a LAN that has no other bridges attached.\n"
                },
                "edgePort": {
                    "type": "boolean",
                    "description": "Whether port is an edge port or not.\n"
                },
                "edgePortDiscovery": {
                    "type": "boolean",
                    "description": "Whether port is set to automatically detect edge ports.\n"
                },
                "externalFdbStatus": {
                    "type": "boolean",
                    "description": "Whether registration table is used instead of forwarding data base.\n"
                },
                "fastLeave": {
                    "type": "boolean",
                    "description": "Enables IGMP Fast leave feature on the port.\n"
                },
                "forwarding": {
                    "type": "boolean",
                    "description": "Shows if the port is not blocked by (R/M)STP.\n"
                },
                "frameTypes": {
                    "type": "string",
                    "description": "Specifies allowed ingress frame types on a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "horizon": {
                    "type": "string",
                    "description": "Use split horizon bridging to prevent bridging loops. Set the same value for group of ports, to prevent them from sending data to ports with the same horizon value. Split horizon is a software feature that disables hardware offloading. This value is integer '0'..'429496729' or 'none'.\n"
                },
                "hw": {
                    "type": "boolean",
                    "description": "Enable or disable Hardware Offloading of the interface.\n"
                },
                "hwOffload": {
                    "type": "boolean",
                    "description": "Hardware offloading state.\n"
                },
                "hwOffloadGroup": {
                    "type": "string",
                    "description": "Switch chip used by the port.\n"
                },
                "inactive": {
                    "type": "boolean"
                },
                "ingressFiltering": {
                    "type": "boolean",
                    "description": "Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the bridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "internalPathCost": {
                    "type": "integer",
                    "description": "Path cost to the interface for MSTI0 inside a region. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "learn": {
                    "type": "string",
                    "description": "Changes MAC learning behaviour on a bridge port\n"
                },
                "learning": {
                    "type": "boolean",
                    "description": "Shows whether the port is capable of learning MAC addresses.\n"
                },
                "multicastRouter": {
                    "type": "string",
                    "description": "Changes the state of a bridge port whether IGMP membership reports are going to be forwarded to this port.\n"
                },
                "nextid": {
                    "type": "string"
                },
                "pathCost": {
                    "type": "string",
                    "description": "Path cost to the interface, used by STP to determine the \"best\" path, used by MSTP todetermine \"best\" path between regions. This property has no effect when protocol-mode is set to none.\n"
                },
                "pointToPoint": {
                    "type": "string",
                    "description": "Specifies if a bridge port is connected to a bridge using a point-to-point link for faster convergence in case of failure. This property has no effect when protocol-mode is set to none.\n"
                },
                "pointToPointPort": {
                    "type": "boolean",
                    "description": "Whether the port is connected to a bridge port using full-duplex (true) or half-duplex (false).\n"
                },
                "portNumber": {
                    "type": "integer",
                    "description": "Port number will be assigned in the order that ports got added to the bridge, but this is only true until reboot. After reboot internal numbering will be used.\n"
                },
                "priority": {
                    "type": "string",
                    "description": "The priority of the interface, used by STP to determine the root port, used by MSTP to determine root port between regions.\n"
                },
                "pvid": {
                    "type": "integer",
                    "description": "ort VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "restrictedRole": {
                    "type": "boolean",
                    "description": "Enable the restricted role on a port, used by STP to forbid a port becoming a root port. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "restrictedTcn": {
                    "type": "boolean",
                    "description": "Disable topology change notification (TCN) sending on a port, used by STP to forbid network topology changes to propagate. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "role": {
                    "type": "string",
                    "description": "(R/M)STP algorithm assigned role of the port\n"
                },
                "rootPathCost": {
                    "type": "integer",
                    "description": "The total cost of the path to the root-bridge.\n"
                },
                "sendingRstp": {
                    "type": "string",
                    "description": "Whether the port is sending RSTP or MSTP BPDU types. A port will transit to STP type when RSTP/MSTP enabled port receives a STP BPDU\n"
                },
                "status": {
                    "type": "string",
                    "description": "Port status ('in-bridge' - port is enabled).\n"
                },
                "tagStacking": {
                    "type": "boolean",
                    "description": "Forces all packets to be treated as untagged packets. Packets on ingress port will be tagged with another VLAN tag regardless if a VLAN tag already exists, packets will be tagged with a VLAN ID that matches the pvid value and will use EtherType that is specified in ether-type. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "trusted": {
                    "type": "boolean",
                    "description": "When enabled, it allows to forward DHCP packets towards DHCP server through this port. Mainly used to limit unauthorized servers to provide malicious information for users. This property only has effect when dhcp-snooping is set to yes.\n"
                },
                "unknownMulticastFlood": {
                    "type": "boolean",
                    "description": "When enabled, bridge floods unknown multicast traffic to all bridge egress ports.\n"
                },
                "unknownUnicastFlood": {
                    "type": "boolean",
                    "description": "When enabled, bridge floods unknown unicast traffic to all bridge egress ports.\n"
                }
            },
            "required": [
                "bridge",
                "debugInfo",
                "designatedBridge",
                "designatedCost",
                "designatedPortNumber",
                "dynamic",
                "edgePort",
                "edgePortDiscovery",
                "externalFdbStatus",
                "forwarding",
                "hw",
                "hwOffload",
                "hwOffloadGroup",
                "inactive",
                "ingressFiltering",
                "interface",
                "learning",
                "nextid",
                "pointToPointPort",
                "portNumber",
                "pvid",
                "role",
                "rootPathCost",
                "sendingRstp",
                "status"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "autoIsolate": {
                    "type": "boolean",
                    "description": "When enabled, prevents a port moving from discarding into forwarding state if no BPDUs are received from the neighboring bridge. The port will change into a forwarding state only when a BPDU is received. This property only has an effect when protocol-mode is set to rstp or mstp and edge is set to no.\n"
                },
                "bpduGuard": {
                    "type": "boolean",
                    "description": "This property has no effect when protocol-mode is set to none.\n"
                },
                "bridge": {
                    "type": "string"
                },
                "broadcastFlood": {
                    "type": "boolean",
                    "description": "When enabled, bridge floods broadcast traffic to all bridge egress ports. When disabled, drops broadcast traffic on egress ports.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "edge": {
                    "type": "string",
                    "description": "Set port as edge port or non-edge port, or enable edge discovery. Edge ports are connected to a LAN that has no other bridges attached.\n"
                },
                "fastLeave": {
                    "type": "boolean",
                    "description": "Enables IGMP Fast leave feature on the port.\n"
                },
                "frameTypes": {
                    "type": "string",
                    "description": "Specifies allowed ingress frame types on a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "horizon": {
                    "type": "string",
                    "description": "Use split horizon bridging to prevent bridging loops. Set the same value for group of ports, to prevent them from sending data to ports with the same horizon value. Split horizon is a software feature that disables hardware offloading. This value is integer '0'..'429496729' or 'none'.\n"
                },
                "hw": {
                    "type": "boolean",
                    "description": "Enable or disable Hardware Offloading of the interface.\n"
                },
                "ingressFiltering": {
                    "type": "boolean",
                    "description": "Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the bridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "internalPathCost": {
                    "type": "integer",
                    "description": "Path cost to the interface for MSTI0 inside a region. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "learn": {
                    "type": "string",
                    "description": "Changes MAC learning behaviour on a bridge port\n"
                },
                "multicastRouter": {
                    "type": "string",
                    "description": "Changes the state of a bridge port whether IGMP membership reports are going to be forwarded to this port.\n"
                },
                "pathCost": {
                    "type": "string",
                    "description": "Path cost to the interface, used by STP to determine the \"best\" path, used by MSTP todetermine \"best\" path between regions. This property has no effect when protocol-mode is set to none.\n"
                },
                "pointToPoint": {
                    "type": "string",
                    "description": "Specifies if a bridge port is connected to a bridge using a point-to-point link for faster convergence in case of failure. This property has no effect when protocol-mode is set to none.\n"
                },
                "priority": {
                    "type": "string",
                    "description": "The priority of the interface, used by STP to determine the root port, used by MSTP to determine root port between regions.\n"
                },
                "pvid": {
                    "type": "integer",
                    "description": "ort VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "restrictedRole": {
                    "type": "boolean",
                    "description": "Enable the restricted role on a port, used by STP to forbid a port becoming a root port. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "restrictedTcn": {
                    "type": "boolean",
                    "description": "Disable topology change notification (TCN) sending on a port, used by STP to forbid network topology changes to propagate. This property only has effect when protocol-mode is set to mstp.\n"
                },
                "tagStacking": {
                    "type": "boolean",
                    "description": "Forces all packets to be treated as untagged packets. Packets on ingress port will be tagged with another VLAN tag regardless if a VLAN tag already exists, packets will be tagged with a VLAN ID that matches the pvid value and will use EtherType that is specified in ether-type. This property only has effect when vlan-filtering is set to yes.\n"
                },
                "trusted": {
                    "type": "boolean",
                    "description": "When enabled, it allows to forward DHCP packets towards DHCP server through this port. Mainly used to limit unauthorized servers to provide malicious information for users. This property only has effect when dhcp-snooping is set to yes.\n"
                },
                "unknownMulticastFlood": {
                    "type": "boolean",
                    "description": "When enabled, bridge floods unknown multicast traffic to all bridge egress ports.\n"
                },
                "unknownUnicastFlood": {
                    "type": "boolean",
                    "description": "When enabled, bridge floods unknown unicast traffic to all bridge egress ports.\n"
                }
            },
            "requiredInputs": [
                "bridge",
                "interface",
                "pvid"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InterfaceBridgePort resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "autoIsolate": {
                        "type": "boolean",
                        "description": "When enabled, prevents a port moving from discarding into forwarding state if no BPDUs are received from the neighboring bridge. The port will change into a forwarding state only when a BPDU is received. This property only has an effect when protocol-mode is set to rstp or mstp and edge is set to no.\n"
                    },
                    "bpduGuard": {
                        "type": "boolean",
                        "description": "This property has no effect when protocol-mode is set to none.\n"
                    },
                    "bridge": {
                        "type": "string"
                    },
                    "broadcastFlood": {
                        "type": "boolean",
                        "description": "When enabled, bridge floods broadcast traffic to all bridge egress ports. When disabled, drops broadcast traffic on egress ports.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "debugInfo": {
                        "type": "string"
                    },
                    "designatedBridge": {
                        "type": "string",
                        "description": "Root bridge ID (bridge priority and the bridge MAC address).\n"
                    },
                    "designatedCost": {
                        "type": "string",
                        "description": "Designated cost.\n"
                    },
                    "designatedPortNumber": {
                        "type": "integer",
                        "description": "Designated port number.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                    },
                    "edge": {
                        "type": "string",
                        "description": "Set port as edge port or non-edge port, or enable edge discovery. Edge ports are connected to a LAN that has no other bridges attached.\n"
                    },
                    "edgePort": {
                        "type": "boolean",
                        "description": "Whether port is an edge port or not.\n"
                    },
                    "edgePortDiscovery": {
                        "type": "boolean",
                        "description": "Whether port is set to automatically detect edge ports.\n"
                    },
                    "externalFdbStatus": {
                        "type": "boolean",
                        "description": "Whether registration table is used instead of forwarding data base.\n"
                    },
                    "fastLeave": {
                        "type": "boolean",
                        "description": "Enables IGMP Fast leave feature on the port.\n"
                    },
                    "forwarding": {
                        "type": "boolean",
                        "description": "Shows if the port is not blocked by (R/M)STP.\n"
                    },
                    "frameTypes": {
                        "type": "string",
                        "description": "Specifies allowed ingress frame types on a bridge port. This property only has effect when vlan-filtering is set to yes.\n"
                    },
                    "horizon": {
                        "type": "string",
                        "description": "Use split horizon bridging to prevent bridging loops. Set the same value for group of ports, to prevent them from sending data to ports with the same horizon value. Split horizon is a software feature that disables hardware offloading. This value is integer '0'..'429496729' or 'none'.\n"
                    },
                    "hw": {
                        "type": "boolean",
                        "description": "Enable or disable Hardware Offloading of the interface.\n"
                    },
                    "hwOffload": {
                        "type": "boolean",
                        "description": "Hardware offloading state.\n"
                    },
                    "hwOffloadGroup": {
                        "type": "string",
                        "description": "Switch chip used by the port.\n"
                    },
                    "inactive": {
                        "type": "boolean"
                    },
                    "ingressFiltering": {
                        "type": "boolean",
                        "description": "Enables or disables VLAN ingress filtering, which checks if the ingress port is a member of the received VLAN ID in the bridge VLAN table. Should be used with frame-types to specify if the ingress traffic should be tagged or untagged. This property only has effect when vlan-filtering is set to yes.\n"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "internalPathCost": {
                        "type": "integer",
                        "description": "Path cost to the interface for MSTI0 inside a region. This property only has effect when protocol-mode is set to mstp.\n"
                    },
                    "learn": {
                        "type": "string",
                        "description": "Changes MAC learning behaviour on a bridge port\n"
                    },
                    "learning": {
                        "type": "boolean",
                        "description": "Shows whether the port is capable of learning MAC addresses.\n"
                    },
                    "multicastRouter": {
                        "type": "string",
                        "description": "Changes the state of a bridge port whether IGMP membership reports are going to be forwarded to this port.\n"
                    },
                    "nextid": {
                        "type": "string"
                    },
                    "pathCost": {
                        "type": "string",
                        "description": "Path cost to the interface, used by STP to determine the \"best\" path, used by MSTP todetermine \"best\" path between regions. This property has no effect when protocol-mode is set to none.\n"
                    },
                    "pointToPoint": {
                        "type": "string",
                        "description": "Specifies if a bridge port is connected to a bridge using a point-to-point link for faster convergence in case of failure. This property has no effect when protocol-mode is set to none.\n"
                    },
                    "pointToPointPort": {
                        "type": "boolean",
                        "description": "Whether the port is connected to a bridge port using full-duplex (true) or half-duplex (false).\n"
                    },
                    "portNumber": {
                        "type": "integer",
                        "description": "Port number will be assigned in the order that ports got added to the bridge, but this is only true until reboot. After reboot internal numbering will be used.\n"
                    },
                    "priority": {
                        "type": "string",
                        "description": "The priority of the interface, used by STP to determine the root port, used by MSTP to determine root port between regions.\n"
                    },
                    "pvid": {
                        "type": "integer",
                        "description": "ort VLAN ID (pvid) specifies which VLAN the untagged ingress traffic is assigned to. This property only has effect when vlan-filtering is set to yes.\n"
                    },
                    "restrictedRole": {
                        "type": "boolean",
                        "description": "Enable the restricted role on a port, used by STP to forbid a port becoming a root port. This property only has effect when protocol-mode is set to mstp.\n"
                    },
                    "restrictedTcn": {
                        "type": "boolean",
                        "description": "Disable topology change notification (TCN) sending on a port, used by STP to forbid network topology changes to propagate. This property only has effect when protocol-mode is set to mstp.\n"
                    },
                    "role": {
                        "type": "string",
                        "description": "(R/M)STP algorithm assigned role of the port\n"
                    },
                    "rootPathCost": {
                        "type": "integer",
                        "description": "The total cost of the path to the root-bridge.\n"
                    },
                    "sendingRstp": {
                        "type": "string",
                        "description": "Whether the port is sending RSTP or MSTP BPDU types. A port will transit to STP type when RSTP/MSTP enabled port receives a STP BPDU\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Port status ('in-bridge' - port is enabled).\n"
                    },
                    "tagStacking": {
                        "type": "boolean",
                        "description": "Forces all packets to be treated as untagged packets. Packets on ingress port will be tagged with another VLAN tag regardless if a VLAN tag already exists, packets will be tagged with a VLAN ID that matches the pvid value and will use EtherType that is specified in ether-type. This property only has effect when vlan-filtering is set to yes.\n"
                    },
                    "trusted": {
                        "type": "boolean",
                        "description": "When enabled, it allows to forward DHCP packets towards DHCP server through this port. Mainly used to limit unauthorized servers to provide malicious information for users. This property only has effect when dhcp-snooping is set to yes.\n"
                    },
                    "unknownMulticastFlood": {
                        "type": "boolean",
                        "description": "When enabled, bridge floods unknown multicast traffic to all bridge egress ports.\n"
                    },
                    "unknownUnicastFlood": {
                        "type": "boolean",
                        "description": "When enabled, bridge floods unknown unicast traffic to all bridge egress ports.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/interfaceBridgeVlan:InterfaceBridgeVlan": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst bridgeVlan = new routeros.iface.InterfaceBridgeVlan(\"bridgeVlan\", {\n    bridge: \"bridge\",\n    taggeds: [\n        \"bridge\",\n        \"ether1\",\n    ],\n    untaggeds: [\"ether5\"],\n    vlanIds: \"50\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nbridge_vlan = routeros.iface.InterfaceBridgeVlan(\"bridgeVlan\",\n    bridge=\"bridge\",\n    taggeds=[\n        \"bridge\",\n        \"ether1\",\n    ],\n    untaggeds=[\"ether5\"],\n    vlan_ids=\"50\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var bridgeVlan = new Routeros.Iface.InterfaceBridgeVlan(\"bridgeVlan\", new()\n    {\n        Bridge = \"bridge\",\n        Taggeds = new[]\n        {\n            \"bridge\",\n            \"ether1\",\n        },\n        Untaggeds = new[]\n        {\n            \"ether5\",\n        },\n        VlanIds = \"50\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Iface\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Iface.NewInterfaceBridgeVlan(ctx, \"bridgeVlan\", \u0026Iface.InterfaceBridgeVlanArgs{\n\t\t\tBridge: pulumi.String(\"bridge\"),\n\t\t\tTaggeds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"bridge\"),\n\t\t\t\tpulumi.String(\"ether1\"),\n\t\t\t},\n\t\t\tUntaggeds: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"ether5\"),\n\t\t\t},\n\t\t\tVlanIds: pulumi.String(\"50\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Iface.InterfaceBridgeVlan;\nimport com.pulumi.routeros.Iface.InterfaceBridgeVlanArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var bridgeVlan = new InterfaceBridgeVlan(\"bridgeVlan\", InterfaceBridgeVlanArgs.builder()        \n            .bridge(\"bridge\")\n            .taggeds(            \n                \"bridge\",\n                \"ether1\")\n            .untaggeds(\"ether5\")\n            .vlanIds(\"50\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  bridgeVlan:\n    type: routeros:Iface:InterfaceBridgeVlan\n    properties:\n      bridge: bridge\n      taggeds:\n        - bridge\n        - ether1\n      untaggeds:\n        - ether5\n      vlanIds: '50'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/interface/bridge/vlan get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Iface/interfaceBridgeVlan:InterfaceBridgeVlan bridge_vlan \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "The bridge interface which the respective VLAN entry is intended for.\n"
                },
                "comment": {
                    "type": "string"
                },
                "currentTaggeds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "currentUntaggeds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                },
                "taggeds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Interface list with a VLAN tag adding action in egress. This setting accepts comma separated values. E.g. tagged=ether1,ether2.\n"
                },
                "untaggeds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Interface list with a VLAN tag removing action in egress. This setting accepts comma separated values. E.g. untagged=ether3,ether4\n"
                },
                "vlanIds": {
                    "type": "string",
                    "description": "The list of VLAN IDs for certain port configuration. This setting accepts VLAN ID range as well as comma separated values. E.g. vlan-ids=100-115,120,122,128-130.\n"
                }
            },
            "required": [
                "bridge",
                "currentTaggeds",
                "currentUntaggeds",
                "dynamic",
                "vlanIds"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "The bridge interface which the respective VLAN entry is intended for.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "taggeds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Interface list with a VLAN tag adding action in egress. This setting accepts comma separated values. E.g. tagged=ether1,ether2.\n"
                },
                "untaggeds": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Interface list with a VLAN tag removing action in egress. This setting accepts comma separated values. E.g. untagged=ether3,ether4\n"
                },
                "vlanIds": {
                    "type": "string",
                    "description": "The list of VLAN IDs for certain port configuration. This setting accepts VLAN ID range as well as comma separated values. E.g. vlan-ids=100-115,120,122,128-130.\n"
                }
            },
            "requiredInputs": [
                "bridge",
                "vlanIds"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InterfaceBridgeVlan resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "bridge": {
                        "type": "string",
                        "description": "The bridge interface which the respective VLAN entry is intended for.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "currentTaggeds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "currentUntaggeds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                    },
                    "taggeds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Interface list with a VLAN tag adding action in egress. This setting accepts comma separated values. E.g. tagged=ether1,ether2.\n"
                    },
                    "untaggeds": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Interface list with a VLAN tag removing action in egress. This setting accepts comma separated values. E.g. untagged=ether3,ether4\n"
                    },
                    "vlanIds": {
                        "type": "string",
                        "description": "The list of VLAN IDs for certain port configuration. This setting accepts VLAN ID range as well as comma separated values. E.g. vlan-ids=100-115,120,122,128-130.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/interfaceGre:InterfaceGre": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst greHq = new routeros.iface.InterfaceGre(\"greHq\", {\n    disabled: true,\n    remoteAddress: \"10.77.3.26\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ngre_hq = routeros.iface.InterfaceGre(\"greHq\",\n    disabled=True,\n    remote_address=\"10.77.3.26\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var greHq = new Routeros.Iface.InterfaceGre(\"greHq\", new()\n    {\n        Disabled = true,\n        RemoteAddress = \"10.77.3.26\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Iface\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Iface.NewInterfaceGre(ctx, \"greHq\", \u0026Iface.InterfaceGreArgs{\n\t\t\tDisabled:      pulumi.Bool(true),\n\t\t\tRemoteAddress: pulumi.String(\"10.77.3.26\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Iface.InterfaceGre;\nimport com.pulumi.routeros.Iface.InterfaceGreArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var greHq = new InterfaceGre(\"greHq\", InterfaceGreArgs.builder()        \n            .disabled(true)\n            .remoteAddress(\"10.77.3.26\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  greHq:\n    type: routeros:Iface:InterfaceGre\n    properties:\n      disabled: true\n      remoteAddress: 10.77.3.26\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport with the name of the gre interface in case of the example use gre-hq-1\n\n```sh\n $ pulumi import routeros:Iface/interfaceGre:InterfaceGre gre_hq gre-hq-1\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "actualMtu": {
                    "type": "integer"
                },
                "allowFastPath": {
                    "type": "boolean",
                    "description": "Whether to allow FastPath processing. Must be disabled if IPsec tunneling is used.\n"
                },
                "clampTcpMss": {
                    "type": "boolean",
                    "description": "Controls whether to change MSS size for received TCP SYN packets. When enabled, a router will change the MSS size for received TCP SYN packets if the current MSS size exceeds the tunnel interface MTU (taking into account the TCP/IP overhead). The received encapsulated packet will still contain the original MSS, and only after decapsulation the MSS is changed.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dontFragment": {
                    "type": "string"
                },
                "dscp": {
                    "type": "string",
                    "description": "Set dscp value in GRE header to a fixed value '0..63' or 'inherit' from dscp value taken from tunnelled traffic.\n"
                },
                "ipsecSecret": {
                    "type": "string",
                    "description": "When secret is specified, router adds dynamic IPsec peer to remote-address with pre-shared key and policy (by default phase2 uses sha1/aes128cbc).\n",
                    "secret": true
                },
                "keepalive": {
                    "type": "string",
                    "description": "Tunnel keepalive parameter sets the time interval in which the tunnel running flag will remain even if the remote end of tunnel goes down. If configured time,retries fail, interface running flag is removed. Parameters are written in following format: KeepaliveInterval,KeepaliveRetries where KeepaliveInterval is time interval and KeepaliveRetries - number of retry attempts. KeepaliveInterval is integer 0..4294967295\n"
                },
                "l2mtu": {
                    "type": "integer",
                    "description": "Layer2 Maximum transmission unit.\n"
                },
                "localAddress": {
                    "type": "string"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "remoteAddress": {
                    "type": "string"
                },
                "running": {
                    "type": "boolean"
                }
            },
            "required": [
                "actualMtu",
                "l2mtu",
                "mtu",
                "name",
                "remoteAddress",
                "running"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "allowFastPath": {
                    "type": "boolean",
                    "description": "Whether to allow FastPath processing. Must be disabled if IPsec tunneling is used.\n"
                },
                "clampTcpMss": {
                    "type": "boolean",
                    "description": "Controls whether to change MSS size for received TCP SYN packets. When enabled, a router will change the MSS size for received TCP SYN packets if the current MSS size exceeds the tunnel interface MTU (taking into account the TCP/IP overhead). The received encapsulated packet will still contain the original MSS, and only after decapsulation the MSS is changed.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dontFragment": {
                    "type": "string"
                },
                "dscp": {
                    "type": "string",
                    "description": "Set dscp value in GRE header to a fixed value '0..63' or 'inherit' from dscp value taken from tunnelled traffic.\n"
                },
                "ipsecSecret": {
                    "type": "string",
                    "description": "When secret is specified, router adds dynamic IPsec peer to remote-address with pre-shared key and policy (by default phase2 uses sha1/aes128cbc).\n",
                    "secret": true
                },
                "keepalive": {
                    "type": "string",
                    "description": "Tunnel keepalive parameter sets the time interval in which the tunnel running flag will remain even if the remote end of tunnel goes down. If configured time,retries fail, interface running flag is removed. Parameters are written in following format: KeepaliveInterval,KeepaliveRetries where KeepaliveInterval is time interval and KeepaliveRetries - number of retry attempts. KeepaliveInterval is integer 0..4294967295\n"
                },
                "localAddress": {
                    "type": "string"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "remoteAddress": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "remoteAddress"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InterfaceGre resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "actualMtu": {
                        "type": "integer"
                    },
                    "allowFastPath": {
                        "type": "boolean",
                        "description": "Whether to allow FastPath processing. Must be disabled if IPsec tunneling is used.\n"
                    },
                    "clampTcpMss": {
                        "type": "boolean",
                        "description": "Controls whether to change MSS size for received TCP SYN packets. When enabled, a router will change the MSS size for received TCP SYN packets if the current MSS size exceeds the tunnel interface MTU (taking into account the TCP/IP overhead). The received encapsulated packet will still contain the original MSS, and only after decapsulation the MSS is changed.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dontFragment": {
                        "type": "string"
                    },
                    "dscp": {
                        "type": "string",
                        "description": "Set dscp value in GRE header to a fixed value '0..63' or 'inherit' from dscp value taken from tunnelled traffic.\n"
                    },
                    "ipsecSecret": {
                        "type": "string",
                        "description": "When secret is specified, router adds dynamic IPsec peer to remote-address with pre-shared key and policy (by default phase2 uses sha1/aes128cbc).\n",
                        "secret": true
                    },
                    "keepalive": {
                        "type": "string",
                        "description": "Tunnel keepalive parameter sets the time interval in which the tunnel running flag will remain even if the remote end of tunnel goes down. If configured time,retries fail, interface running flag is removed. Parameters are written in following format: KeepaliveInterval,KeepaliveRetries where KeepaliveInterval is time interval and KeepaliveRetries - number of retry attempts. KeepaliveInterval is integer 0..4294967295\n"
                    },
                    "l2mtu": {
                        "type": "integer",
                        "description": "Layer2 Maximum transmission unit.\n"
                    },
                    "localAddress": {
                        "type": "string"
                    },
                    "mtu": {
                        "type": "string",
                        "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "remoteAddress": {
                        "type": "string"
                    },
                    "running": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/interfaceVlan:InterfaceVlan": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst interfaceVlan = new routeros.iface.InterfaceVlan(\"interfaceVlan\", {\n    \"interface\": \"bridge\",\n    vlanId: 50,\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ninterface_vlan = routeros.iface.InterfaceVlan(\"interfaceVlan\",\n    interface=\"bridge\",\n    vlan_id=50)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var interfaceVlan = new Routeros.Iface.InterfaceVlan(\"interfaceVlan\", new()\n    {\n        Interface = \"bridge\",\n        VlanId = 50,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Iface\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Iface.NewInterfaceVlan(ctx, \"interfaceVlan\", \u0026Iface.InterfaceVlanArgs{\n\t\t\tInterface: pulumi.String(\"bridge\"),\n\t\t\tVlanId:    pulumi.Int(50),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Iface.InterfaceVlan;\nimport com.pulumi.routeros.Iface.InterfaceVlanArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var interfaceVlan = new InterfaceVlan(\"interfaceVlan\", InterfaceVlanArgs.builder()        \n            .interface_(\"bridge\")\n            .vlanId(50)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  interfaceVlan:\n    type: routeros:Iface:InterfaceVlan\n    properties:\n      interface: bridge\n      vlanId: 50\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport with the name of the vlan interface in case of the example use VLAN_TEST\n\n```sh\n $ pulumi import routeros:Iface/interfaceVlan:InterfaceVlan interface_vlan VLAN_TEST\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP resolution protocol mode.\n"
                },
                "arpTimeout": {
                    "type": "string",
                    "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to the value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds, minutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "l2mtu": {
                    "type": "integer",
                    "description": "Layer2 Maximum transmission unit.\n"
                },
                "loopProtect": {
                    "type": "string"
                },
                "loopProtectDisableTime": {
                    "type": "string"
                },
                "loopProtectSendInterval": {
                    "type": "string"
                },
                "loopProtectStatus": {
                    "type": "string"
                },
                "macAddress": {
                    "type": "string"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "running": {
                    "type": "boolean"
                },
                "useServiceTag": {
                    "type": "boolean"
                },
                "vlanId": {
                    "type": "integer"
                }
            },
            "required": [
                "interface",
                "l2mtu",
                "loopProtectStatus",
                "macAddress",
                "mtu",
                "name",
                "running",
                "vlanId"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP resolution protocol mode.\n"
                },
                "arpTimeout": {
                    "type": "string",
                    "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to the value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds, minutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "loopProtect": {
                    "type": "string"
                },
                "loopProtectDisableTime": {
                    "type": "string"
                },
                "loopProtectSendInterval": {
                    "type": "string"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "useServiceTag": {
                    "type": "boolean"
                },
                "vlanId": {
                    "type": "integer"
                }
            },
            "requiredInputs": [
                "interface",
                "vlanId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InterfaceVlan resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "arp": {
                        "type": "string",
                        "description": "ARP resolution protocol mode.\n"
                    },
                    "arpTimeout": {
                        "type": "string",
                        "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to the value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds, minutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "l2mtu": {
                        "type": "integer",
                        "description": "Layer2 Maximum transmission unit.\n"
                    },
                    "loopProtect": {
                        "type": "string"
                    },
                    "loopProtectDisableTime": {
                        "type": "string"
                    },
                    "loopProtectSendInterval": {
                        "type": "string"
                    },
                    "loopProtectStatus": {
                        "type": "string"
                    },
                    "macAddress": {
                        "type": "string"
                    },
                    "mtu": {
                        "type": "string",
                        "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "running": {
                        "type": "boolean"
                    },
                    "useServiceTag": {
                        "type": "boolean"
                    },
                    "vlanId": {
                        "type": "integer"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/interfaceVrrp:InterfaceVrrp": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst interfaceVrrp = new routeros.iface.InterfaceVrrp(\"interfaceVrrp\", {\"interface\": \"bridge\"});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ninterface_vrrp = routeros.iface.InterfaceVrrp(\"interfaceVrrp\", interface=\"bridge\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var interfaceVrrp = new Routeros.Iface.InterfaceVrrp(\"interfaceVrrp\", new()\n    {\n        Interface = \"bridge\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Iface\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Iface.NewInterfaceVrrp(ctx, \"interfaceVrrp\", \u0026Iface.InterfaceVrrpArgs{\n\t\t\tInterface: pulumi.String(\"bridge\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Iface.InterfaceVrrp;\nimport com.pulumi.routeros.Iface.InterfaceVrrpArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var interfaceVrrp = new InterfaceVrrp(\"interfaceVrrp\", InterfaceVrrpArgs.builder()        \n            .interface_(\"bridge\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  interfaceVrrp:\n    type: routeros:Iface:InterfaceVrrp\n    properties:\n      interface: bridge\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/interface/vrrp get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Iface/interfaceVrrp:InterfaceVrrp interface_vrrp \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP resolution protocol mode.\n"
                },
                "arpTimeout": {
                    "type": "string",
                    "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to the value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds, minutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                },
                "authentication": {
                    "type": "string",
                    "description": "Authentication method to use for VRRP advertisement packets.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "groupMaster": {
                    "type": "string",
                    "description": "Allows combining multiple VRRP interfaces to maintain the same VRRP status within the group.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "interval": {
                    "type": "string",
                    "description": "VRRP update interval in seconds. Defines how often master sends advertisement packets.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "macAddress": {
                    "type": "string"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "onBackup": {
                    "type": "string",
                    "description": "Script to execute when the node is switched to the backup state.\n"
                },
                "onFail": {
                    "type": "string",
                    "description": "Script to execute when the node fails.\n"
                },
                "onMaster": {
                    "type": "string",
                    "description": "Script to execute when the node is switched to master state.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password required for authentication. Can be ignored if authentication is not used.\n",
                    "secret": true
                },
                "preemptionMode": {
                    "type": "boolean",
                    "description": "Whether the master node always has the priority. When set to 'no' the backup node will not be elected to be a master until the current master fails, even if the backup node has higher priority than the current master. This setting is ignored if the owner router becomes available\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of VRRP node used in Master election algorithm. A higher number means higher priority. '255' is reserved for the router that owns VR IP and '0' is reserved for the Master router to indicate that it is releasing responsibility.\n"
                },
                "remoteAddress": {
                    "type": "string",
                    "description": "Specifies the remote address of the other VRRP router for syncing connection tracking. If not set, the system autodetects the remote address via VRRP. The remote address is used only if sync-connection-tracking=yes.Sync connection tracking uses UDP port 8275.\n"
                },
                "running": {
                    "type": "boolean"
                },
                "syncConnectionTracking": {
                    "type": "boolean",
                    "description": "Synchronize connection tracking entries from Master to Backup device.\n"
                },
                "v3Protocol": {
                    "type": "string",
                    "description": "A protocol that will be used by VRRPv3. Valid only if the version is 3.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "Which VRRP version to use.\n"
                },
                "vrid": {
                    "type": "integer",
                    "description": "Virtual Router identifier. Each Virtual router must have a unique id number.\n"
                }
            },
            "required": [
                "groupMaster",
                "interface",
                "invalid",
                "macAddress",
                "mtu",
                "name",
                "running"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP resolution protocol mode.\n"
                },
                "arpTimeout": {
                    "type": "string",
                    "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to the value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds, minutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                },
                "authentication": {
                    "type": "string",
                    "description": "Authentication method to use for VRRP advertisement packets.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "groupMaster": {
                    "type": "string",
                    "description": "Allows combining multiple VRRP interfaces to maintain the same VRRP status within the group.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "interval": {
                    "type": "string",
                    "description": "VRRP update interval in seconds. Defines how often master sends advertisement packets.\n"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "onBackup": {
                    "type": "string",
                    "description": "Script to execute when the node is switched to the backup state.\n"
                },
                "onFail": {
                    "type": "string",
                    "description": "Script to execute when the node fails.\n"
                },
                "onMaster": {
                    "type": "string",
                    "description": "Script to execute when the node is switched to master state.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password required for authentication. Can be ignored if authentication is not used.\n",
                    "secret": true
                },
                "preemptionMode": {
                    "type": "boolean",
                    "description": "Whether the master node always has the priority. When set to 'no' the backup node will not be elected to be a master until the current master fails, even if the backup node has higher priority than the current master. This setting is ignored if the owner router becomes available\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of VRRP node used in Master election algorithm. A higher number means higher priority. '255' is reserved for the router that owns VR IP and '0' is reserved for the Master router to indicate that it is releasing responsibility.\n"
                },
                "remoteAddress": {
                    "type": "string",
                    "description": "Specifies the remote address of the other VRRP router for syncing connection tracking. If not set, the system autodetects the remote address via VRRP. The remote address is used only if sync-connection-tracking=yes.Sync connection tracking uses UDP port 8275.\n"
                },
                "syncConnectionTracking": {
                    "type": "boolean",
                    "description": "Synchronize connection tracking entries from Master to Backup device.\n"
                },
                "v3Protocol": {
                    "type": "string",
                    "description": "A protocol that will be used by VRRPv3. Valid only if the version is 3.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "Which VRRP version to use.\n"
                },
                "vrid": {
                    "type": "integer",
                    "description": "Virtual Router identifier. Each Virtual router must have a unique id number.\n"
                }
            },
            "requiredInputs": [
                "interface"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InterfaceVrrp resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "arp": {
                        "type": "string",
                        "description": "ARP resolution protocol mode.\n"
                    },
                    "arpTimeout": {
                        "type": "string",
                        "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to the value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds, minutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                    },
                    "authentication": {
                        "type": "string",
                        "description": "Authentication method to use for VRRP advertisement packets.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "groupMaster": {
                        "type": "string",
                        "description": "Allows combining multiple VRRP interfaces to maintain the same VRRP status within the group.\n"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "interval": {
                        "type": "string",
                        "description": "VRRP update interval in seconds. Defines how often master sends advertisement packets.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "macAddress": {
                        "type": "string"
                    },
                    "mtu": {
                        "type": "string",
                        "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "onBackup": {
                        "type": "string",
                        "description": "Script to execute when the node is switched to the backup state.\n"
                    },
                    "onFail": {
                        "type": "string",
                        "description": "Script to execute when the node fails.\n"
                    },
                    "onMaster": {
                        "type": "string",
                        "description": "Script to execute when the node is switched to master state.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password required for authentication. Can be ignored if authentication is not used.\n",
                        "secret": true
                    },
                    "preemptionMode": {
                        "type": "boolean",
                        "description": "Whether the master node always has the priority. When set to 'no' the backup node will not be elected to be a master until the current master fails, even if the backup node has higher priority than the current master. This setting is ignored if the owner router becomes available\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority of VRRP node used in Master election algorithm. A higher number means higher priority. '255' is reserved for the router that owns VR IP and '0' is reserved for the Master router to indicate that it is releasing responsibility.\n"
                    },
                    "remoteAddress": {
                        "type": "string",
                        "description": "Specifies the remote address of the other VRRP router for syncing connection tracking. If not set, the system autodetects the remote address via VRRP. The remote address is used only if sync-connection-tracking=yes.Sync connection tracking uses UDP port 8275.\n"
                    },
                    "running": {
                        "type": "boolean"
                    },
                    "syncConnectionTracking": {
                        "type": "boolean",
                        "description": "Synchronize connection tracking entries from Master to Backup device.\n"
                    },
                    "v3Protocol": {
                        "type": "string",
                        "description": "A protocol that will be used by VRRPv3. Valid only if the version is 3.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "Which VRRP version to use.\n"
                    },
                    "vrid": {
                        "type": "integer",
                        "description": "Virtual Router identifier. Each Virtual router must have a unique id number.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/interfaceWireguard:InterfaceWireguard": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst testWgInterface = new routeros.iface.InterfaceWireguard(\"testWgInterface\", {listenPort: 13231});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest_wg_interface = routeros.iface.InterfaceWireguard(\"testWgInterface\", listen_port=13231)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testWgInterface = new Routeros.Iface.InterfaceWireguard(\"testWgInterface\", new()\n    {\n        ListenPort = 13231,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Iface\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Iface.NewInterfaceWireguard(ctx, \"testWgInterface\", \u0026Iface.InterfaceWireguardArgs{\n\t\t\tListenPort: pulumi.Int(13231),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Iface.InterfaceWireguard;\nimport com.pulumi.routeros.Iface.InterfaceWireguardArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testWgInterface = new InterfaceWireguard(\"testWgInterface\", InterfaceWireguardArgs.builder()        \n            .listenPort(\"13231\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testWgInterface:\n    type: routeros:Iface:InterfaceWireguard\n    properties:\n      listenPort: '13231'\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport with the name of the wireguard interface in case of the example use test_wg_interface\n\n```sh\n $ pulumi import routeros:Iface/interfaceWireguard:InterfaceWireguard test_wg_interface test_wg_interface\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "listenPort": {
                    "type": "integer",
                    "description": "Port for WireGuard service to listen on for incoming sessions.\n"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "A base64 private key. If not specified, it will be automatically generated upon interface creation.\n",
                    "secret": true
                },
                "publicKey": {
                    "type": "string",
                    "description": "A base64 public key is calculated from the private key.\n"
                },
                "running": {
                    "type": "boolean"
                }
            },
            "required": [
                "listenPort",
                "mtu",
                "name",
                "privateKey",
                "publicKey",
                "running"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "listenPort": {
                    "type": "integer",
                    "description": "Port for WireGuard service to listen on for incoming sessions.\n"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "privateKey": {
                    "type": "string",
                    "description": "A base64 private key. If not specified, it will be automatically generated upon interface creation.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "listenPort"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InterfaceWireguard resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "listenPort": {
                        "type": "integer",
                        "description": "Port for WireGuard service to listen on for incoming sessions.\n"
                    },
                    "mtu": {
                        "type": "string",
                        "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "A base64 private key. If not specified, it will be automatically generated upon interface creation.\n",
                        "secret": true
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "A base64 public key is calculated from the private key.\n"
                    },
                    "running": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/interfaceWireguardPeer:InterfaceWireguardPeer": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst testWgInterface = new routeros.iface.InterfaceWireguard(\"testWgInterface\", {listenPort: 13231});\nconst wgPeer = new routeros.iface.InterfaceWireguardPeer(\"wgPeer\", {\n    \"interface\": testWgInterface.name,\n    publicKey: \"MY_BASE_64_PUBLIC_KEY\",\n    allowedAddresses: [\n        \"192.168.0.0/16\",\n        \"172.16.0.0/12\",\n        \"10.0.0.0/8\",\n    ],\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest_wg_interface = routeros.iface.InterfaceWireguard(\"testWgInterface\", listen_port=13231)\nwg_peer = routeros.iface.InterfaceWireguardPeer(\"wgPeer\",\n    interface=test_wg_interface.name,\n    public_key=\"MY_BASE_64_PUBLIC_KEY\",\n    allowed_addresses=[\n        \"192.168.0.0/16\",\n        \"172.16.0.0/12\",\n        \"10.0.0.0/8\",\n    ])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testWgInterface = new Routeros.Iface.InterfaceWireguard(\"testWgInterface\", new()\n    {\n        ListenPort = 13231,\n    });\n\n    var wgPeer = new Routeros.Iface.InterfaceWireguardPeer(\"wgPeer\", new()\n    {\n        Interface = testWgInterface.Name,\n        PublicKey = \"MY_BASE_64_PUBLIC_KEY\",\n        AllowedAddresses = new[]\n        {\n            \"192.168.0.0/16\",\n            \"172.16.0.0/12\",\n            \"10.0.0.0/8\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Iface\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttestWgInterface, err := Iface.NewInterfaceWireguard(ctx, \"testWgInterface\", \u0026Iface.InterfaceWireguardArgs{\n\t\t\tListenPort: pulumi.Int(13231),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = Iface.NewInterfaceWireguardPeer(ctx, \"wgPeer\", \u0026Iface.InterfaceWireguardPeerArgs{\n\t\t\tInterface: testWgInterface.Name,\n\t\t\tPublicKey: pulumi.String(\"MY_BASE_64_PUBLIC_KEY\"),\n\t\t\tAllowedAddresses: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"192.168.0.0/16\"),\n\t\t\t\tpulumi.String(\"172.16.0.0/12\"),\n\t\t\t\tpulumi.String(\"10.0.0.0/8\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Iface.InterfaceWireguard;\nimport com.pulumi.routeros.Iface.InterfaceWireguardArgs;\nimport com.pulumi.routeros.Iface.InterfaceWireguardPeer;\nimport com.pulumi.routeros.Iface.InterfaceWireguardPeerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testWgInterface = new InterfaceWireguard(\"testWgInterface\", InterfaceWireguardArgs.builder()        \n            .listenPort(\"13231\")\n            .build());\n\n        var wgPeer = new InterfaceWireguardPeer(\"wgPeer\", InterfaceWireguardPeerArgs.builder()        \n            .interface_(testWgInterface.name())\n            .publicKey(\"MY_BASE_64_PUBLIC_KEY\")\n            .allowedAddresses(            \n                \"192.168.0.0/16\",\n                \"172.16.0.0/12\",\n                \"10.0.0.0/8\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testWgInterface:\n    type: routeros:Iface:InterfaceWireguard\n    properties:\n      listenPort: '13231'\n  wgPeer:\n    type: routeros:Iface:InterfaceWireguardPeer\n    properties:\n      interface: ${testWgInterface.name}\n      publicKey: MY_BASE_64_PUBLIC_KEY\n      allowedAddresses:\n        - 192.168.0.0/16\n        - 172.16.0.0/12\n        - 10.0.0.0/8\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/interface/wireguard/peers get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Iface/interfaceWireguardPeer:InterfaceWireguardPeer wg_peer \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "allowedAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.\n"
                },
                "comment": {
                    "type": "string"
                },
                "currentEndpointAddress": {
                    "type": "string",
                    "description": "The most recent source IP address of correctly authenticated packets from the peer.\n"
                },
                "currentEndpointPort": {
                    "type": "integer",
                    "description": "The most recent source IP port of correctly authenticated packets from the peer.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "endpointAddress": {
                    "type": "string",
                    "description": "An endpoint IP or hostname can be left blank to allow remote connection from any address.\n"
                },
                "endpointPort": {
                    "type": "string",
                    "description": "An endpoint port can be left blank to allow remote connection from any port.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "lastHandshake": {
                    "type": "string",
                    "description": "Time in seconds after the last successful handshake.\n"
                },
                "persistentKeepalive": {
                    "type": "string",
                    "description": "A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.\n"
                },
                "presharedKey": {
                    "type": "string",
                    "description": "A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.\n",
                    "secret": true
                },
                "publicKey": {
                    "type": "string",
                    "description": "The remote peer's calculated public key.\n"
                },
                "rx": {
                    "type": "string",
                    "description": "The total amount of bytes received from the peer.\n"
                },
                "tx": {
                    "type": "string",
                    "description": "The total amount of bytes transmitted to the peer.\n"
                }
            },
            "required": [
                "currentEndpointAddress",
                "currentEndpointPort",
                "endpointAddress",
                "endpointPort",
                "interface",
                "lastHandshake",
                "publicKey",
                "rx",
                "tx"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "allowedAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "endpointAddress": {
                    "type": "string",
                    "description": "An endpoint IP or hostname can be left blank to allow remote connection from any address.\n"
                },
                "endpointPort": {
                    "type": "string",
                    "description": "An endpoint port can be left blank to allow remote connection from any port.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "persistentKeepalive": {
                    "type": "string",
                    "description": "A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.\n"
                },
                "presharedKey": {
                    "type": "string",
                    "description": "A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.\n",
                    "secret": true
                },
                "publicKey": {
                    "type": "string",
                    "description": "The remote peer's calculated public key.\n"
                }
            },
            "requiredInputs": [
                "interface",
                "publicKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering InterfaceWireguardPeer resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "allowedAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which outgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses, and ::/0 may be specified for matching all IPv6 addresses.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "currentEndpointAddress": {
                        "type": "string",
                        "description": "The most recent source IP address of correctly authenticated packets from the peer.\n"
                    },
                    "currentEndpointPort": {
                        "type": "integer",
                        "description": "The most recent source IP port of correctly authenticated packets from the peer.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "endpointAddress": {
                        "type": "string",
                        "description": "An endpoint IP or hostname can be left blank to allow remote connection from any address.\n"
                    },
                    "endpointPort": {
                        "type": "string",
                        "description": "An endpoint port can be left blank to allow remote connection from any port.\n"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "lastHandshake": {
                        "type": "string",
                        "description": "Time in seconds after the last successful handshake.\n"
                    },
                    "persistentKeepalive": {
                        "type": "string",
                        "description": "A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for the purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely sends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit from having a persistent keepalive interval of 25 seconds.\n"
                    },
                    "presharedKey": {
                        "type": "string",
                        "description": "A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key cryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.\n",
                        "secret": true
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "The remote peer's calculated public key.\n"
                    },
                    "rx": {
                        "type": "string",
                        "description": "The total amount of bytes received from the peer.\n"
                    },
                    "tx": {
                        "type": "string",
                        "description": "The total amount of bytes transmitted to the peer.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/list:List": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst list = new routeros.iface.List(\"list\", {});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nlist = routeros.iface.List(\"list\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var list = new Routeros.Iface.List(\"list\");\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Iface\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Iface.NewList(ctx, \"list\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Iface.List;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var list = new List(\"list\");\n\n    }\n}\n```\n```yaml\nresources:\n  list:\n    type: routeros:Iface:List\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport with the name of the interface list in case of the example use my-list\n\n```sh\n $ pulumi import routeros:Iface/list:List list my-list\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "builtin": {
                    "type": "boolean"
                },
                "comment": {
                    "type": "string"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                },
                "exclude": {
                    "type": "string"
                },
                "include": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                }
            },
            "required": [
                "builtin",
                "dynamic",
                "name"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "exclude": {
                    "type": "string"
                },
                "include": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering List resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "builtin": {
                        "type": "boolean"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                    },
                    "exclude": {
                        "type": "string"
                    },
                    "include": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/listMember:ListMember": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst listMember = new routeros.iface.ListMember(\"listMember\", {\n    \"interface\": \"ether1\",\n    list: \"my-list\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nlist_member = routeros.iface.ListMember(\"listMember\",\n    interface=\"ether1\",\n    list=\"my-list\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var listMember = new Routeros.Iface.ListMember(\"listMember\", new()\n    {\n        Interface = \"ether1\",\n        List = \"my-list\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Iface\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Iface.NewListMember(ctx, \"listMember\", \u0026Iface.ListMemberArgs{\n\t\t\tInterface: pulumi.String(\"ether1\"),\n\t\t\tList:      pulumi.String(\"my-list\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Iface.ListMember;\nimport com.pulumi.routeros.Iface.ListMemberArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var listMember = new ListMember(\"listMember\", ListMemberArgs.builder()        \n            .interface_(\"ether1\")\n            .list(\"my-list\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  listMember:\n    type: routeros:Iface:ListMember\n    properties:\n      interface: ether1\n      list: my-list\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/interface/list/member get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Iface/listMember:ListMember list_member \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean"
                },
                "interface": {
                    "type": "string"
                },
                "list": {
                    "type": "string"
                }
            },
            "required": [
                "dynamic",
                "interface",
                "list"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "interface": {
                    "type": "string"
                },
                "list": {
                    "type": "string"
                }
            },
            "requiredInputs": [
                "interface",
                "list"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering ListMember resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean"
                    },
                    "interface": {
                        "type": "string"
                    },
                    "list": {
                        "type": "string"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/openVpnServer:OpenVpnServer": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst user1 = new routeros.iface.OpenVpnServer(\"user1\", {user: \"user1\"}, {\n    dependsOn: [routeros_ovpn_server.server],\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nuser1 = routeros.iface.OpenVpnServer(\"user1\", user=\"user1\",\nopts=pulumi.ResourceOptions(depends_on=[routeros_ovpn_server[\"server\"]]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var user1 = new Routeros.Iface.OpenVpnServer(\"user1\", new()\n    {\n        User = \"user1\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            routeros_ovpn_server.Server,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Iface\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Iface.NewOpenVpnServer(ctx, \"user1\", \u0026Iface.OpenVpnServerArgs{\n\t\t\tUser: pulumi.String(\"user1\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\trouteros_ovpn_server.Server,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Iface.OpenVpnServer;\nimport com.pulumi.routeros.Iface.OpenVpnServerArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var user1 = new OpenVpnServer(\"user1\", OpenVpnServerArgs.builder()        \n            .user(\"user1\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(routeros_ovpn_server.server())\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  user1:\n    type: routeros:Iface:OpenVpnServer\n    properties:\n      user: user1\n    options:\n      dependson:\n        - ${routeros_ovpn_server.server}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/interface/ovpn-server get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Iface/openVpnServer:OpenVpnServer user1 *29\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "clientAddress": {
                    "type": "string",
                    "description": "The address of the remote side.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "encoding": {
                    "type": "string",
                    "description": "Encryption characteristics.\n"
                },
                "mtu": {
                    "type": "integer",
                    "description": "Layer2 Maximum transmission unit.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Interface name (Example: ovpn-in1).\n"
                },
                "running": {
                    "type": "boolean"
                },
                "uptime": {
                    "type": "string",
                    "description": "Connection uptime.\n"
                },
                "user": {
                    "type": "string",
                    "description": "User name used for authentication.\n"
                }
            },
            "required": [
                "clientAddress",
                "encoding",
                "mtu",
                "name",
                "running",
                "uptime"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string",
                    "description": "Interface name (Example: ovpn-in1).\n"
                },
                "user": {
                    "type": "string",
                    "description": "User name used for authentication.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering OpenVpnServer resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "clientAddress": {
                        "type": "string",
                        "description": "The address of the remote side.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "encoding": {
                        "type": "string",
                        "description": "Encryption characteristics.\n"
                    },
                    "mtu": {
                        "type": "integer",
                        "description": "Layer2 Maximum transmission unit.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Interface name (Example: ovpn-in1).\n"
                    },
                    "running": {
                        "type": "boolean"
                    },
                    "uptime": {
                        "type": "string",
                        "description": "Connection uptime.\n"
                    },
                    "user": {
                        "type": "string",
                        "description": "User name used for authentication.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/vlan:Vlan": {
            "description": "## # routeros.Iface.Vlan (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Iface.InterfaceVlan\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP resolution protocol mode.\n"
                },
                "arpTimeout": {
                    "type": "string",
                    "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to\nthe value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds,\nminutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "l2mtu": {
                    "type": "integer",
                    "description": "Layer2 Maximum transmission unit.\n"
                },
                "loopProtect": {
                    "type": "string"
                },
                "loopProtectDisableTime": {
                    "type": "string"
                },
                "loopProtectSendInterval": {
                    "type": "string"
                },
                "loopProtectStatus": {
                    "type": "string"
                },
                "macAddress": {
                    "type": "string"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "running": {
                    "type": "boolean"
                },
                "useServiceTag": {
                    "type": "boolean"
                },
                "vlanId": {
                    "type": "integer"
                }
            },
            "required": [
                "interface",
                "l2mtu",
                "loopProtectStatus",
                "macAddress",
                "mtu",
                "name",
                "running",
                "vlanId"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP resolution protocol mode.\n"
                },
                "arpTimeout": {
                    "type": "string",
                    "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to\nthe value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds,\nminutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "loopProtect": {
                    "type": "string"
                },
                "loopProtectDisableTime": {
                    "type": "string"
                },
                "loopProtectSendInterval": {
                    "type": "string"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "useServiceTag": {
                    "type": "boolean"
                },
                "vlanId": {
                    "type": "integer"
                }
            },
            "requiredInputs": [
                "interface",
                "vlanId"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Vlan resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "arp": {
                        "type": "string",
                        "description": "ARP resolution protocol mode.\n"
                    },
                    "arpTimeout": {
                        "type": "string",
                        "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to\nthe value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds,\nminutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "l2mtu": {
                        "type": "integer",
                        "description": "Layer2 Maximum transmission unit.\n"
                    },
                    "loopProtect": {
                        "type": "string"
                    },
                    "loopProtectDisableTime": {
                        "type": "string"
                    },
                    "loopProtectSendInterval": {
                        "type": "string"
                    },
                    "loopProtectStatus": {
                        "type": "string"
                    },
                    "macAddress": {
                        "type": "string"
                    },
                    "mtu": {
                        "type": "string",
                        "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "running": {
                        "type": "boolean"
                    },
                    "useServiceTag": {
                        "type": "boolean"
                    },
                    "vlanId": {
                        "type": "integer"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/vrrp:Vrrp": {
            "description": "## # routeros.Iface.Vrrp (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Iface.InterfaceVrrp\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP resolution protocol mode.\n"
                },
                "arpTimeout": {
                    "type": "string",
                    "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to\nthe value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds,\nminutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                },
                "authentication": {
                    "type": "string",
                    "description": "Authentication method to use for VRRP advertisement packets.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "groupMaster": {
                    "type": "string",
                    "description": "Allows combining multiple VRRP interfaces to maintain the same VRRP status within the group.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "interval": {
                    "type": "string",
                    "description": "VRRP update interval in seconds. Defines how often master sends advertisement packets.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "macAddress": {
                    "type": "string"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "onBackup": {
                    "type": "string",
                    "description": "Script to execute when the node is switched to the backup state.\n"
                },
                "onFail": {
                    "type": "string",
                    "description": "Script to execute when the node fails.\n"
                },
                "onMaster": {
                    "type": "string",
                    "description": "Script to execute when the node is switched to master state.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password required for authentication. Can be ignored if authentication is not used.\n",
                    "secret": true
                },
                "preemptionMode": {
                    "type": "boolean",
                    "description": "Whether the master node always has the priority. When set to 'no' the backup node will not be elected to be a master\nuntil the current master fails, even if the backup node has higher priority than the current master. This setting is\nignored if the owner router becomes available\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of VRRP node used in Master election algorithm. A higher number means higher priority. '255' is reserved for\nthe router that owns VR IP and '0' is reserved for the Master router to indicate that it is releasing responsibility.\n"
                },
                "remoteAddress": {
                    "type": "string",
                    "description": "Specifies the remote address of the other VRRP router for syncing connection tracking. If not set, the system\nautodetects the remote address via VRRP. The remote address is used only if sync-connection-tracking=yes.Sync connection\ntracking uses UDP port 8275.\n"
                },
                "running": {
                    "type": "boolean"
                },
                "syncConnectionTracking": {
                    "type": "boolean",
                    "description": "Synchronize connection tracking entries from Master to Backup device.\n"
                },
                "v3Protocol": {
                    "type": "string",
                    "description": "A protocol that will be used by VRRPv3. Valid only if the version is 3.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "Which VRRP version to use.\n"
                },
                "vrid": {
                    "type": "integer",
                    "description": "Virtual Router identifier. Each Virtual router must have a unique id number.\n"
                }
            },
            "required": [
                "groupMaster",
                "interface",
                "invalid",
                "macAddress",
                "mtu",
                "name",
                "running"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "arp": {
                    "type": "string",
                    "description": "ARP resolution protocol mode.\n"
                },
                "arpTimeout": {
                    "type": "string",
                    "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to\nthe value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds,\nminutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                },
                "authentication": {
                    "type": "string",
                    "description": "Authentication method to use for VRRP advertisement packets.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "groupMaster": {
                    "type": "string",
                    "description": "Allows combining multiple VRRP interfaces to maintain the same VRRP status within the group.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "interval": {
                    "type": "string",
                    "description": "VRRP update interval in seconds. Defines how often master sends advertisement packets.\n"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "onBackup": {
                    "type": "string",
                    "description": "Script to execute when the node is switched to the backup state.\n"
                },
                "onFail": {
                    "type": "string",
                    "description": "Script to execute when the node fails.\n"
                },
                "onMaster": {
                    "type": "string",
                    "description": "Script to execute when the node is switched to master state.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password required for authentication. Can be ignored if authentication is not used.\n",
                    "secret": true
                },
                "preemptionMode": {
                    "type": "boolean",
                    "description": "Whether the master node always has the priority. When set to 'no' the backup node will not be elected to be a master\nuntil the current master fails, even if the backup node has higher priority than the current master. This setting is\nignored if the owner router becomes available\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Priority of VRRP node used in Master election algorithm. A higher number means higher priority. '255' is reserved for\nthe router that owns VR IP and '0' is reserved for the Master router to indicate that it is releasing responsibility.\n"
                },
                "remoteAddress": {
                    "type": "string",
                    "description": "Specifies the remote address of the other VRRP router for syncing connection tracking. If not set, the system\nautodetects the remote address via VRRP. The remote address is used only if sync-connection-tracking=yes.Sync connection\ntracking uses UDP port 8275.\n"
                },
                "syncConnectionTracking": {
                    "type": "boolean",
                    "description": "Synchronize connection tracking entries from Master to Backup device.\n"
                },
                "v3Protocol": {
                    "type": "string",
                    "description": "A protocol that will be used by VRRPv3. Valid only if the version is 3.\n"
                },
                "version": {
                    "type": "integer",
                    "description": "Which VRRP version to use.\n"
                },
                "vrid": {
                    "type": "integer",
                    "description": "Virtual Router identifier. Each Virtual router must have a unique id number.\n"
                }
            },
            "requiredInputs": [
                "interface"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Vrrp resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "arp": {
                        "type": "string",
                        "description": "ARP resolution protocol mode.\n"
                    },
                    "arpTimeout": {
                        "type": "string",
                        "description": "ARP timeout is time how long ARP record is kept in ARP table after no packets are received from IP. Value auto equals to\nthe value of arp-timeout in IP/Settings, default is 30s. Can use postfix ms, s, M, h, d for milliseconds, seconds,\nminutes, hours or days. If no postfix is set then seconds (s) is used.\n"
                    },
                    "authentication": {
                        "type": "string",
                        "description": "Authentication method to use for VRRP advertisement packets.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "groupMaster": {
                        "type": "string",
                        "description": "Allows combining multiple VRRP interfaces to maintain the same VRRP status within the group.\n"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "interval": {
                        "type": "string",
                        "description": "VRRP update interval in seconds. Defines how often master sends advertisement packets.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "macAddress": {
                        "type": "string"
                    },
                    "mtu": {
                        "type": "string",
                        "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "onBackup": {
                        "type": "string",
                        "description": "Script to execute when the node is switched to the backup state.\n"
                    },
                    "onFail": {
                        "type": "string",
                        "description": "Script to execute when the node fails.\n"
                    },
                    "onMaster": {
                        "type": "string",
                        "description": "Script to execute when the node is switched to master state.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password required for authentication. Can be ignored if authentication is not used.\n",
                        "secret": true
                    },
                    "preemptionMode": {
                        "type": "boolean",
                        "description": "Whether the master node always has the priority. When set to 'no' the backup node will not be elected to be a master\nuntil the current master fails, even if the backup node has higher priority than the current master. This setting is\nignored if the owner router becomes available\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Priority of VRRP node used in Master election algorithm. A higher number means higher priority. '255' is reserved for\nthe router that owns VR IP and '0' is reserved for the Master router to indicate that it is releasing responsibility.\n"
                    },
                    "remoteAddress": {
                        "type": "string",
                        "description": "Specifies the remote address of the other VRRP router for syncing connection tracking. If not set, the system\nautodetects the remote address via VRRP. The remote address is used only if sync-connection-tracking=yes.Sync connection\ntracking uses UDP port 8275.\n"
                    },
                    "running": {
                        "type": "boolean"
                    },
                    "syncConnectionTracking": {
                        "type": "boolean",
                        "description": "Synchronize connection tracking entries from Master to Backup device.\n"
                    },
                    "v3Protocol": {
                        "type": "string",
                        "description": "A protocol that will be used by VRRPv3. Valid only if the version is 3.\n"
                    },
                    "version": {
                        "type": "integer",
                        "description": "Which VRRP version to use.\n"
                    },
                    "vrid": {
                        "type": "integer",
                        "description": "Virtual Router identifier. Each Virtual router must have a unique id number.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/wireguard:Wireguard": {
            "description": "## # routeros.Iface.Wireguard (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Iface.InterfaceWireguard\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "listenPort": {
                    "type": "integer",
                    "description": "Port for WireGuard service to listen on for incoming sessions.\n"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "privateKey": {
                    "type": "string",
                    "description": "A base64 private key. If not specified, it will be automatically generated upon interface creation.\n",
                    "secret": true
                },
                "publicKey": {
                    "type": "string",
                    "description": "A base64 public key is calculated from the private key.\n"
                },
                "running": {
                    "type": "boolean"
                }
            },
            "required": [
                "listenPort",
                "mtu",
                "name",
                "privateKey",
                "publicKey",
                "running"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "listenPort": {
                    "type": "integer",
                    "description": "Port for WireGuard service to listen on for incoming sessions.\n"
                },
                "mtu": {
                    "type": "string",
                    "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "privateKey": {
                    "type": "string",
                    "description": "A base64 private key. If not specified, it will be automatically generated upon interface creation.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "listenPort"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Wireguard resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "listenPort": {
                        "type": "integer",
                        "description": "Port for WireGuard service to listen on for incoming sessions.\n"
                    },
                    "mtu": {
                        "type": "string",
                        "description": "Layer3 Maximum transmission unit ('auto', 0 .. 65535)\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "privateKey": {
                        "type": "string",
                        "description": "A base64 private key. If not specified, it will be automatically generated upon interface creation.\n",
                        "secret": true
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "A base64 public key is calculated from the private key.\n"
                    },
                    "running": {
                        "type": "boolean"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Iface/wireguardPeer:WireguardPeer": {
            "description": "## # routeros.Iface.WireguardPeer (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Iface.InterfaceWireguardPeer\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "allowedAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which\noutgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,\nand ::/0 may be specified for matching all IPv6 addresses.\n"
                },
                "comment": {
                    "type": "string"
                },
                "currentEndpointAddress": {
                    "type": "string",
                    "description": "The most recent source IP address of correctly authenticated packets from the peer.\n"
                },
                "currentEndpointPort": {
                    "type": "integer",
                    "description": "The most recent source IP port of correctly authenticated packets from the peer.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "endpointAddress": {
                    "type": "string",
                    "description": "An endpoint IP or hostname can be left blank to allow remote connection from any address.\n"
                },
                "endpointPort": {
                    "type": "string",
                    "description": "An endpoint port can be left blank to allow remote connection from any port.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "lastHandshake": {
                    "type": "string",
                    "description": "Time in seconds after the last successful handshake.\n"
                },
                "persistentKeepalive": {
                    "type": "string",
                    "description": "A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for\nthe purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely\nsends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit\nfrom having a persistent keepalive interval of 25 seconds.\n"
                },
                "presharedKey": {
                    "type": "string",
                    "description": "A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key\ncryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.\n",
                    "secret": true
                },
                "publicKey": {
                    "type": "string",
                    "description": "The remote peer's calculated public key.\n"
                },
                "rx": {
                    "type": "string",
                    "description": "The total amount of bytes received from the peer.\n"
                },
                "tx": {
                    "type": "string",
                    "description": "The total amount of bytes transmitted to the peer.\n"
                }
            },
            "required": [
                "currentEndpointAddress",
                "currentEndpointPort",
                "endpointAddress",
                "endpointPort",
                "interface",
                "lastHandshake",
                "publicKey",
                "rx",
                "tx"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "allowedAddresses": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which\noutgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,\nand ::/0 may be specified for matching all IPv6 addresses.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "endpointAddress": {
                    "type": "string",
                    "description": "An endpoint IP or hostname can be left blank to allow remote connection from any address.\n"
                },
                "endpointPort": {
                    "type": "string",
                    "description": "An endpoint port can be left blank to allow remote connection from any port.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "persistentKeepalive": {
                    "type": "string",
                    "description": "A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for\nthe purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely\nsends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit\nfrom having a persistent keepalive interval of 25 seconds.\n"
                },
                "presharedKey": {
                    "type": "string",
                    "description": "A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key\ncryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.\n",
                    "secret": true
                },
                "publicKey": {
                    "type": "string",
                    "description": "The remote peer's calculated public key.\n"
                }
            },
            "requiredInputs": [
                "interface",
                "publicKey"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering WireguardPeer resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "allowedAddresses": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of IP (v4 or v6) addresses with CIDR masks from which incoming traffic for this peer is allowed and to which\noutgoing traffic for this peer is directed. The catch-all 0.0.0.0/0 may be specified for matching all IPv4 addresses,\nand ::/0 may be specified for matching all IPv6 addresses.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "currentEndpointAddress": {
                        "type": "string",
                        "description": "The most recent source IP address of correctly authenticated packets from the peer.\n"
                    },
                    "currentEndpointPort": {
                        "type": "integer",
                        "description": "The most recent source IP port of correctly authenticated packets from the peer.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "endpointAddress": {
                        "type": "string",
                        "description": "An endpoint IP or hostname can be left blank to allow remote connection from any address.\n"
                    },
                    "endpointPort": {
                        "type": "string",
                        "description": "An endpoint port can be left blank to allow remote connection from any port.\n"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "lastHandshake": {
                        "type": "string",
                        "description": "Time in seconds after the last successful handshake.\n"
                    },
                    "persistentKeepalive": {
                        "type": "string",
                        "description": "A seconds interval, between 1 and 65535 inclusive, of how often to send an authenticated empty packet to the peer for\nthe purpose of keeping a stateful firewall or NAT mapping valid persistently. For example, if the interface very rarely\nsends traffic, but it might at anytime receive traffic from a peer, and it is behind NAT, the interface might benefit\nfrom having a persistent keepalive interval of 25 seconds.\n"
                    },
                    "presharedKey": {
                        "type": "string",
                        "description": "A **base64** preshared key. Optional, and may be omitted. This option adds an additional layer of symmetric-key\ncryptography to be mixed into the already existing public-key cryptography, for post-quantum resistance.\n",
                        "secret": true
                    },
                    "publicKey": {
                        "type": "string",
                        "description": "The remote peer's calculated public key.\n"
                    },
                    "rx": {
                        "type": "string",
                        "description": "The total amount of bytes received from the peer.\n"
                    },
                    "tx": {
                        "type": "string",
                        "description": "The total amount of bytes transmitted to the peer.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/dhcpClient:DhcpClient": {
            "description": "## # routeros.Ip.DhcpClient (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Ip.DhcpIpClient\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "addDefaultRoute": {
                    "type": "string",
                    "description": "Whether to install default route in routing table received from DHCP server.\n"
                },
                "address": {
                    "type": "string",
                    "description": "IP address and netmask, which is assigned to DHCP Client from the Server.\n"
                },
                "comment": {
                    "type": "string"
                },
                "defaultRouteDistance": {
                    "type": "integer",
                    "description": "Distance of default route. Applicable if add-default-route is set to yes.\n"
                },
                "dhcpOptions": {
                    "type": "string",
                    "description": "Options that are sent to the DHCP server.\n"
                },
                "dhcpServer": {
                    "type": "string",
                    "description": "The IP address of the DHCP server.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "expiresAfter": {
                    "type": "string",
                    "description": "A time when the lease expires (specified by the DHCP server).\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The IP address of the gateway which is assigned by DHCP server.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "primaryDns": {
                    "type": "string",
                    "description": "The IP address of the first DNS resolver, that was assigned by the DHCP server.\n"
                },
                "primaryNtp": {
                    "type": "string",
                    "description": "The IP address of the primary NTP server, assigned by the DHCP server.\n"
                },
                "secondaryDns": {
                    "type": "string",
                    "description": "The IP address of the second DNS resolver, assigned by the DHCP server.\n"
                },
                "secondaryNtp": {
                    "type": "string",
                    "description": "The IP address of the secondary NTP server, assigned by the DHCP server.\n"
                },
                "status": {
                    "type": "string"
                },
                "usePeerDns": {
                    "type": "boolean",
                    "description": "Whether to accept the DNS settings advertised by DHCP Server (will override the settings put in the /ip dns submenu).\n"
                },
                "usePeerNtp": {
                    "type": "boolean",
                    "description": "Whether to accept the NTP settings advertised by DHCP Server (will override the settings put in the /system ntp client\nsubmenu).\n"
                }
            },
            "required": [
                "addDefaultRoute",
                "address",
                "dhcpServer",
                "dynamic",
                "expiresAfter",
                "gateway",
                "interface",
                "invalid",
                "primaryDns",
                "primaryNtp",
                "secondaryDns",
                "secondaryNtp",
                "status"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "addDefaultRoute": {
                    "type": "string",
                    "description": "Whether to install default route in routing table received from DHCP server.\n"
                },
                "comment": {
                    "type": "string"
                },
                "defaultRouteDistance": {
                    "type": "integer",
                    "description": "Distance of default route. Applicable if add-default-route is set to yes.\n"
                },
                "dhcpOptions": {
                    "type": "string",
                    "description": "Options that are sent to the DHCP server.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "usePeerDns": {
                    "type": "boolean",
                    "description": "Whether to accept the DNS settings advertised by DHCP Server (will override the settings put in the /ip dns submenu).\n"
                },
                "usePeerNtp": {
                    "type": "boolean",
                    "description": "Whether to accept the NTP settings advertised by DHCP Server (will override the settings put in the /system ntp client\nsubmenu).\n"
                }
            },
            "requiredInputs": [
                "interface"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DhcpClient resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "addDefaultRoute": {
                        "type": "string",
                        "description": "Whether to install default route in routing table received from DHCP server.\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "IP address and netmask, which is assigned to DHCP Client from the Server.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "defaultRouteDistance": {
                        "type": "integer",
                        "description": "Distance of default route. Applicable if add-default-route is set to yes.\n"
                    },
                    "dhcpOptions": {
                        "type": "string",
                        "description": "Options that are sent to the DHCP server.\n"
                    },
                    "dhcpServer": {
                        "type": "string",
                        "description": "The IP address of the DHCP server.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "expiresAfter": {
                        "type": "string",
                        "description": "A time when the lease expires (specified by the DHCP server).\n"
                    },
                    "gateway": {
                        "type": "string",
                        "description": "The IP address of the gateway which is assigned by DHCP server.\n"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "primaryDns": {
                        "type": "string",
                        "description": "The IP address of the first DNS resolver, that was assigned by the DHCP server.\n"
                    },
                    "primaryNtp": {
                        "type": "string",
                        "description": "The IP address of the primary NTP server, assigned by the DHCP server.\n"
                    },
                    "secondaryDns": {
                        "type": "string",
                        "description": "The IP address of the second DNS resolver, assigned by the DHCP server.\n"
                    },
                    "secondaryNtp": {
                        "type": "string",
                        "description": "The IP address of the secondary NTP server, assigned by the DHCP server.\n"
                    },
                    "status": {
                        "type": "string"
                    },
                    "usePeerDns": {
                        "type": "boolean",
                        "description": "Whether to accept the DNS settings advertised by DHCP Server (will override the settings put in the /ip dns submenu).\n"
                    },
                    "usePeerNtp": {
                        "type": "boolean",
                        "description": "Whether to accept the NTP settings advertised by DHCP Server (will override the settings put in the /system ntp client\nsubmenu).\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/dhcpIpClient:DhcpIpClient": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst client = new routeros.ip.DhcpIpClient(\"client\", {\"interface\": \"bridge\"});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nclient = routeros.ip.DhcpIpClient(\"client\", interface=\"bridge\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var client = new Routeros.Ip.DhcpIpClient(\"client\", new()\n    {\n        Interface = \"bridge\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ip.NewDhcpIpClient(ctx, \"client\", \u0026Ip.DhcpIpClientArgs{\n\t\t\tInterface: pulumi.String(\"bridge\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.DhcpIpClient;\nimport com.pulumi.routeros.Ip.DhcpIpClientArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var client = new DhcpIpClient(\"client\", DhcpIpClientArgs.builder()        \n            .interface_(\"bridge\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  client:\n    type: routeros:Ip:DhcpIpClient\n    properties:\n      interface: bridge\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ip/dhcp-client get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ip/dhcpIpClient:DhcpIpClient client \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "addDefaultRoute": {
                    "type": "string",
                    "description": "Whether to install default route in routing table received from DHCP server.\n"
                },
                "address": {
                    "type": "string",
                    "description": "IP address and netmask, which is assigned to DHCP Client from the Server.\n"
                },
                "comment": {
                    "type": "string"
                },
                "defaultRouteDistance": {
                    "type": "integer",
                    "description": "Distance of default route. Applicable if add-default-route is set to yes.\n"
                },
                "dhcpOptions": {
                    "type": "string",
                    "description": "Options that are sent to the DHCP server.\n"
                },
                "dhcpServer": {
                    "type": "string",
                    "description": "The IP address of the DHCP server.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                },
                "expiresAfter": {
                    "type": "string",
                    "description": "A time when the lease expires (specified by the DHCP server).\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The IP address of the gateway which is assigned by DHCP server.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "primaryDns": {
                    "type": "string",
                    "description": "The IP address of the first DNS resolver, that was assigned by the DHCP server.\n"
                },
                "primaryNtp": {
                    "type": "string",
                    "description": "The IP address of the primary NTP server, assigned by the DHCP server.\n"
                },
                "secondaryDns": {
                    "type": "string",
                    "description": "The IP address of the second DNS resolver, assigned by the DHCP server.\n"
                },
                "secondaryNtp": {
                    "type": "string",
                    "description": "The IP address of the secondary NTP server, assigned by the DHCP server.\n"
                },
                "status": {
                    "type": "string"
                },
                "usePeerDns": {
                    "type": "boolean",
                    "description": "Whether to accept the DNS settings advertised by DHCP Server (will override the settings put in the /ip dns submenu).\n"
                },
                "usePeerNtp": {
                    "type": "boolean",
                    "description": "Whether to accept the NTP settings advertised by DHCP Server (will override the settings put in the /system ntp client submenu).\n"
                }
            },
            "required": [
                "addDefaultRoute",
                "address",
                "dhcpServer",
                "dynamic",
                "expiresAfter",
                "gateway",
                "interface",
                "invalid",
                "primaryDns",
                "primaryNtp",
                "secondaryDns",
                "secondaryNtp",
                "status"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "addDefaultRoute": {
                    "type": "string",
                    "description": "Whether to install default route in routing table received from DHCP server.\n"
                },
                "comment": {
                    "type": "string"
                },
                "defaultRouteDistance": {
                    "type": "integer",
                    "description": "Distance of default route. Applicable if add-default-route is set to yes.\n"
                },
                "dhcpOptions": {
                    "type": "string",
                    "description": "Options that are sent to the DHCP server.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "usePeerDns": {
                    "type": "boolean",
                    "description": "Whether to accept the DNS settings advertised by DHCP Server (will override the settings put in the /ip dns submenu).\n"
                },
                "usePeerNtp": {
                    "type": "boolean",
                    "description": "Whether to accept the NTP settings advertised by DHCP Server (will override the settings put in the /system ntp client submenu).\n"
                }
            },
            "requiredInputs": [
                "interface"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DhcpIpClient resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "addDefaultRoute": {
                        "type": "string",
                        "description": "Whether to install default route in routing table received from DHCP server.\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "IP address and netmask, which is assigned to DHCP Client from the Server.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "defaultRouteDistance": {
                        "type": "integer",
                        "description": "Distance of default route. Applicable if add-default-route is set to yes.\n"
                    },
                    "dhcpOptions": {
                        "type": "string",
                        "description": "Options that are sent to the DHCP server.\n"
                    },
                    "dhcpServer": {
                        "type": "string",
                        "description": "The IP address of the DHCP server.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                    },
                    "expiresAfter": {
                        "type": "string",
                        "description": "A time when the lease expires (specified by the DHCP server).\n"
                    },
                    "gateway": {
                        "type": "string",
                        "description": "The IP address of the gateway which is assigned by DHCP server.\n"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "primaryDns": {
                        "type": "string",
                        "description": "The IP address of the first DNS resolver, that was assigned by the DHCP server.\n"
                    },
                    "primaryNtp": {
                        "type": "string",
                        "description": "The IP address of the primary NTP server, assigned by the DHCP server.\n"
                    },
                    "secondaryDns": {
                        "type": "string",
                        "description": "The IP address of the second DNS resolver, assigned by the DHCP server.\n"
                    },
                    "secondaryNtp": {
                        "type": "string",
                        "description": "The IP address of the secondary NTP server, assigned by the DHCP server.\n"
                    },
                    "status": {
                        "type": "string"
                    },
                    "usePeerDns": {
                        "type": "boolean",
                        "description": "Whether to accept the DNS settings advertised by DHCP Server (will override the settings put in the /ip dns submenu).\n"
                    },
                    "usePeerNtp": {
                        "type": "boolean",
                        "description": "Whether to accept the NTP settings advertised by DHCP Server (will override the settings put in the /system ntp client submenu).\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/dhcpIpServer:DhcpIpServer": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst server = new routeros.ip.DhcpIpServer(\"server\", {\n    addressPool: \"my_address_pool\",\n    \"interface\": \"bridge\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nserver = routeros.ip.DhcpIpServer(\"server\",\n    address_pool=\"my_address_pool\",\n    interface=\"bridge\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var server = new Routeros.Ip.DhcpIpServer(\"server\", new()\n    {\n        AddressPool = \"my_address_pool\",\n        Interface = \"bridge\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ip.NewDhcpIpServer(ctx, \"server\", \u0026Ip.DhcpIpServerArgs{\n\t\t\tAddressPool: pulumi.String(\"my_address_pool\"),\n\t\t\tInterface:   pulumi.String(\"bridge\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.DhcpIpServer;\nimport com.pulumi.routeros.Ip.DhcpIpServerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var server = new DhcpIpServer(\"server\", DhcpIpServerArgs.builder()        \n            .addressPool(\"my_address_pool\")\n            .interface_(\"bridge\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  server:\n    type: routeros:Ip:DhcpIpServer\n    properties:\n      addressPool: my_address_pool\n      interface: bridge\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport with the name of the DHCP server in case of the example use bridge_dhcp\n\n```sh\n $ pulumi import routeros:Ip/dhcpIpServer:DhcpIpServer server bridge_dhcp\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "addArp": {
                    "type": "boolean",
                    "description": "Whether to add dynamic ARP entry.\n"
                },
                "addressPool": {
                    "type": "string",
                    "description": "IP pool, from which to take IP addresses for the clients. If set to static-only, then only the clients that have a static lease (added in lease submenu) will be allowed.\n"
                },
                "allowDualStackQueue": {
                    "type": "boolean",
                    "description": "Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification. Requires IPv6 DHCP Server to have this option enabled as well to work properly.\n"
                },
                "alwaysBroadcast": {
                    "type": "boolean",
                    "description": "Always send replies as broadcasts even if destination IP is known.\n"
                },
                "authoritative": {
                    "type": "string",
                    "description": "Option changes the way how a server responds to DHCP requests.\n"
                },
                "bootpLeaseTime": {
                    "type": "string",
                    "description": "Accepts two predefined options or time value: * forever - lease never expires * lease-time - use time from lease-time parameter\n"
                },
                "bootpSupport": {
                    "type": "string",
                    "description": "Support for BOOTP clients.\n"
                },
                "clientMacLimit": {
                    "type": "integer",
                    "description": "Specifies whether to limit specific number of clients per single MAC address.\n"
                },
                "comment": {
                    "type": "string"
                },
                "conflictDetection": {
                    "type": "boolean",
                    "description": "Allows to disable/enable conflict detection. If option is enabled, then whenever server tries to assign a lease it will send ICMP and ARP messages to detect whether such address in the network already exist. If any of above get reply address is considered already used. Conflict detection must be disabled when any kind of DHCP client limitation per port or per mac is used.\n"
                },
                "delayThreshold": {
                    "type": "string",
                    "description": "If secs field in DHCP packet is smaller than delay-threshold, then this packet is ignored. If set to none - there is no threshold (all DHCP packets are processed).\n"
                },
                "dhcpOptionSet": {
                    "type": "string",
                    "description": "Use custom set of DHCP options defined in option sets menu.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                },
                "insertQueueBefore": {
                    "type": "string",
                    "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "leaseScript": {
                    "type": "string",
                    "description": "A script that will be executed after a lease is assigned or de-assigned.\n"
                },
                "leaseTime": {
                    "type": "string",
                    "description": "The time that a client may use the assigned address. The client will try to renew this address after half of this time and will request a new address after the time limit expires.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "parentQueue": {
                    "type": "string"
                },
                "relay": {
                    "type": "string",
                    "description": "The IP address of the relay this DHCP server.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "The address which the DHCP client must send requests to in order to renew an IP address lease.\n"
                },
                "useFramedAsClassless": {
                    "type": "boolean",
                    "description": "Forward RADIUS Framed-Route as a DHCP Classless-Static-Route to DHCP-client.\n"
                },
                "useRadius": {
                    "type": "string",
                    "description": "Whether to use RADIUS server.\n"
                }
            },
            "required": [
                "dynamic",
                "interface",
                "invalid",
                "name"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "addArp": {
                    "type": "boolean",
                    "description": "Whether to add dynamic ARP entry.\n"
                },
                "addressPool": {
                    "type": "string",
                    "description": "IP pool, from which to take IP addresses for the clients. If set to static-only, then only the clients that have a static lease (added in lease submenu) will be allowed.\n"
                },
                "allowDualStackQueue": {
                    "type": "boolean",
                    "description": "Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification. Requires IPv6 DHCP Server to have this option enabled as well to work properly.\n"
                },
                "alwaysBroadcast": {
                    "type": "boolean",
                    "description": "Always send replies as broadcasts even if destination IP is known.\n"
                },
                "authoritative": {
                    "type": "string",
                    "description": "Option changes the way how a server responds to DHCP requests.\n"
                },
                "bootpLeaseTime": {
                    "type": "string",
                    "description": "Accepts two predefined options or time value: * forever - lease never expires * lease-time - use time from lease-time parameter\n"
                },
                "bootpSupport": {
                    "type": "string",
                    "description": "Support for BOOTP clients.\n"
                },
                "clientMacLimit": {
                    "type": "integer",
                    "description": "Specifies whether to limit specific number of clients per single MAC address.\n"
                },
                "comment": {
                    "type": "string"
                },
                "conflictDetection": {
                    "type": "boolean",
                    "description": "Allows to disable/enable conflict detection. If option is enabled, then whenever server tries to assign a lease it will send ICMP and ARP messages to detect whether such address in the network already exist. If any of above get reply address is considered already used. Conflict detection must be disabled when any kind of DHCP client limitation per port or per mac is used.\n"
                },
                "delayThreshold": {
                    "type": "string",
                    "description": "If secs field in DHCP packet is smaller than delay-threshold, then this packet is ignored. If set to none - there is no threshold (all DHCP packets are processed).\n"
                },
                "dhcpOptionSet": {
                    "type": "string",
                    "description": "Use custom set of DHCP options defined in option sets menu.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "insertQueueBefore": {
                    "type": "string",
                    "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "leaseScript": {
                    "type": "string",
                    "description": "A script that will be executed after a lease is assigned or de-assigned.\n"
                },
                "leaseTime": {
                    "type": "string",
                    "description": "The time that a client may use the assigned address. The client will try to renew this address after half of this time and will request a new address after the time limit expires.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "parentQueue": {
                    "type": "string"
                },
                "relay": {
                    "type": "string",
                    "description": "The IP address of the relay this DHCP server.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "The address which the DHCP client must send requests to in order to renew an IP address lease.\n"
                },
                "useFramedAsClassless": {
                    "type": "boolean",
                    "description": "Forward RADIUS Framed-Route as a DHCP Classless-Static-Route to DHCP-client.\n"
                },
                "useRadius": {
                    "type": "string",
                    "description": "Whether to use RADIUS server.\n"
                }
            },
            "requiredInputs": [
                "interface"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DhcpIpServer resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "addArp": {
                        "type": "boolean",
                        "description": "Whether to add dynamic ARP entry.\n"
                    },
                    "addressPool": {
                        "type": "string",
                        "description": "IP pool, from which to take IP addresses for the clients. If set to static-only, then only the clients that have a static lease (added in lease submenu) will be allowed.\n"
                    },
                    "allowDualStackQueue": {
                        "type": "boolean",
                        "description": "Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification. Requires IPv6 DHCP Server to have this option enabled as well to work properly.\n"
                    },
                    "alwaysBroadcast": {
                        "type": "boolean",
                        "description": "Always send replies as broadcasts even if destination IP is known.\n"
                    },
                    "authoritative": {
                        "type": "string",
                        "description": "Option changes the way how a server responds to DHCP requests.\n"
                    },
                    "bootpLeaseTime": {
                        "type": "string",
                        "description": "Accepts two predefined options or time value: * forever - lease never expires * lease-time - use time from lease-time parameter\n"
                    },
                    "bootpSupport": {
                        "type": "string",
                        "description": "Support for BOOTP clients.\n"
                    },
                    "clientMacLimit": {
                        "type": "integer",
                        "description": "Specifies whether to limit specific number of clients per single MAC address.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "conflictDetection": {
                        "type": "boolean",
                        "description": "Allows to disable/enable conflict detection. If option is enabled, then whenever server tries to assign a lease it will send ICMP and ARP messages to detect whether such address in the network already exist. If any of above get reply address is considered already used. Conflict detection must be disabled when any kind of DHCP client limitation per port or per mac is used.\n"
                    },
                    "delayThreshold": {
                        "type": "string",
                        "description": "If secs field in DHCP packet is smaller than delay-threshold, then this packet is ignored. If set to none - there is no threshold (all DHCP packets are processed).\n"
                    },
                    "dhcpOptionSet": {
                        "type": "string",
                        "description": "Use custom set of DHCP options defined in option sets menu.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                    },
                    "insertQueueBefore": {
                        "type": "string",
                        "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "leaseScript": {
                        "type": "string",
                        "description": "A script that will be executed after a lease is assigned or de-assigned.\n"
                    },
                    "leaseTime": {
                        "type": "string",
                        "description": "The time that a client may use the assigned address. The client will try to renew this address after half of this time and will request a new address after the time limit expires.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "parentQueue": {
                        "type": "string"
                    },
                    "relay": {
                        "type": "string",
                        "description": "The IP address of the relay this DHCP server.\n"
                    },
                    "srcAddress": {
                        "type": "string",
                        "description": "The address which the DHCP client must send requests to in order to renew an IP address lease.\n"
                    },
                    "useFramedAsClassless": {
                        "type": "boolean",
                        "description": "Forward RADIUS Framed-Route as a DHCP Classless-Static-Route to DHCP-client.\n"
                    },
                    "useRadius": {
                        "type": "string",
                        "description": "Whether to use RADIUS server.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/dhcpIpServerLease:DhcpIpServerLease": {
            "description": "## # routeros.Ip.DhcpIpServerLease (Resource)\n\nCreates a DHCP lease on the mikrotik device.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst dhcpLease = new routeros.ip.DhcpIpServerLease(\"dhcpLease\", {\n    address: \"10.0.0.2\",\n    macAddress: \"AA:BB:CC:DD:11:22\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ndhcp_lease = routeros.ip.DhcpIpServerLease(\"dhcpLease\",\n    address=\"10.0.0.2\",\n    mac_address=\"AA:BB:CC:DD:11:22\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dhcpLease = new Routeros.Ip.DhcpIpServerLease(\"dhcpLease\", new()\n    {\n        Address = \"10.0.0.2\",\n        MacAddress = \"AA:BB:CC:DD:11:22\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ip.NewDhcpIpServerLease(ctx, \"dhcpLease\", \u0026Ip.DhcpIpServerLeaseArgs{\n\t\t\tAddress:    pulumi.String(\"10.0.0.2\"),\n\t\t\tMacAddress: pulumi.String(\"AA:BB:CC:DD:11:22\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.DhcpIpServerLease;\nimport com.pulumi.routeros.Ip.DhcpIpServerLeaseArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dhcpLease = new DhcpIpServerLease(\"dhcpLease\", DhcpIpServerLeaseArgs.builder()        \n            .address(\"10.0.0.2\")\n            .macAddress(\"AA:BB:CC:DD:11:22\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dhcpLease:\n    type: routeros:Ip:DhcpIpServerLease\n    properties:\n      address: 10.0.0.2\n      macAddress: AA:BB:CC:DD:11:22\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ip/dhcp-server/lease get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ip/dhcpIpServerLease:DhcpIpServerLease dhcp_lease \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "activeAddress": {
                    "type": "string",
                    "description": "The IP address of the machine currently holding the DHCP lease.\n"
                },
                "activeClientId": {
                    "type": "string",
                    "description": "Actual client-id of the client.\n"
                },
                "activeHostname": {
                    "type": "string",
                    "description": "The hostname of the machine currently holding the DHCP lease.\n"
                },
                "activeMacAddress": {
                    "type": "string",
                    "description": "The MAC address of of the machine currently holding the DHCP lease.\n"
                },
                "activeServer": {
                    "type": "string",
                    "description": "Actual dhcp server, which serves this client.\n"
                },
                "address": {
                    "type": "string",
                    "description": "The IP address of the DHCP lease to be created.\n"
                },
                "addressLists": {
                    "type": "string",
                    "description": "Address list to which address will be added if lease is bound.\n"
                },
                "agentCircuitId": {
                    "type": "string",
                    "description": "Circuit ID of DHCP relay agent. If each character should be valid ASCII text symbol or else this value is displayed as hex dump.\n"
                },
                "agentRemoteId": {
                    "type": "string",
                    "description": "Remote ID, set by DHCP relay agent.\n"
                },
                "allowDualStackQueue": {
                    "type": "boolean",
                    "description": "Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.\n"
                },
                "alwaysBroadcast": {
                    "type": "boolean",
                    "description": "Send all replies as broadcasts.\n"
                },
                "blockAccess": {
                    "type": "boolean",
                    "description": "Whether to block access for this DHCP client (true|false).\n"
                },
                "blocked": {
                    "type": "boolean",
                    "description": "Whether the lease is blocked.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "If specified, must match DHCP 'client identifier' option of the request.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcpOption": {
                    "type": "string",
                    "description": "Add additional DHCP options.\n"
                },
                "dhcpOptionSet": {
                    "type": "string",
                    "description": "Add additional set of DHCP options.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Whether the dhcp lease is static or dynamic. Dynamic leases are not guaranteed to continue to be assigned to that specific device. Defaults to false.\n"
                },
                "expiresAfter": {
                    "type": "string",
                    "description": "Time until lease expires.\n"
                },
                "hostName": {
                    "type": "string",
                    "description": "The hostname of the device\n"
                },
                "insertQueueBefore": {
                    "type": "string",
                    "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                },
                "lastSeen": {
                    "type": "string"
                },
                "leaseTime": {
                    "type": "string",
                    "description": "Time that the client may use the address. If set to 0s lease will never expire.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC addreess of the DHCP lease to be created.\n"
                },
                "radius": {
                    "type": "string",
                    "description": "Shows if this dynamic lease is authenticated by RADIUS or not.\n"
                },
                "rateLimit": {
                    "type": "string",
                    "description": "Adds a dynamic simple queue to limit IP's bandwidth to a specified rate. Requires the lease to be static.\n"
                },
                "server": {
                    "type": "string",
                    "description": "Server name which serves this client.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Source MAC address.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Lease status.\n"
                },
                "useSrcMac": {
                    "type": "boolean",
                    "description": "When this option is set server uses source MAC address instead of received CHADDR to assign address.\n"
                }
            },
            "required": [
                "activeAddress",
                "activeClientId",
                "activeHostname",
                "activeMacAddress",
                "activeServer",
                "address",
                "agentCircuitId",
                "agentRemoteId",
                "blocked",
                "expiresAfter",
                "hostName",
                "lastSeen",
                "macAddress",
                "radius",
                "srcMacAddress",
                "status"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "The IP address of the DHCP lease to be created.\n"
                },
                "addressLists": {
                    "type": "string",
                    "description": "Address list to which address will be added if lease is bound.\n"
                },
                "allowDualStackQueue": {
                    "type": "boolean",
                    "description": "Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.\n"
                },
                "alwaysBroadcast": {
                    "type": "boolean",
                    "description": "Send all replies as broadcasts.\n"
                },
                "blockAccess": {
                    "type": "boolean",
                    "description": "Whether to block access for this DHCP client (true|false).\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "If specified, must match DHCP 'client identifier' option of the request.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcpOption": {
                    "type": "string",
                    "description": "Add additional DHCP options.\n"
                },
                "dhcpOptionSet": {
                    "type": "string",
                    "description": "Add additional set of DHCP options.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Whether the dhcp lease is static or dynamic. Dynamic leases are not guaranteed to continue to be assigned to that specific device. Defaults to false.\n"
                },
                "insertQueueBefore": {
                    "type": "string",
                    "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                },
                "leaseTime": {
                    "type": "string",
                    "description": "Time that the client may use the address. If set to 0s lease will never expire.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC addreess of the DHCP lease to be created.\n"
                },
                "rateLimit": {
                    "type": "string",
                    "description": "Adds a dynamic simple queue to limit IP's bandwidth to a specified rate. Requires the lease to be static.\n"
                },
                "server": {
                    "type": "string",
                    "description": "Server name which serves this client.\n"
                },
                "useSrcMac": {
                    "type": "boolean",
                    "description": "When this option is set server uses source MAC address instead of received CHADDR to assign address.\n"
                }
            },
            "requiredInputs": [
                "address",
                "macAddress"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DhcpIpServerLease resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "activeAddress": {
                        "type": "string",
                        "description": "The IP address of the machine currently holding the DHCP lease.\n"
                    },
                    "activeClientId": {
                        "type": "string",
                        "description": "Actual client-id of the client.\n"
                    },
                    "activeHostname": {
                        "type": "string",
                        "description": "The hostname of the machine currently holding the DHCP lease.\n"
                    },
                    "activeMacAddress": {
                        "type": "string",
                        "description": "The MAC address of of the machine currently holding the DHCP lease.\n"
                    },
                    "activeServer": {
                        "type": "string",
                        "description": "Actual dhcp server, which serves this client.\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "The IP address of the DHCP lease to be created.\n"
                    },
                    "addressLists": {
                        "type": "string",
                        "description": "Address list to which address will be added if lease is bound.\n"
                    },
                    "agentCircuitId": {
                        "type": "string",
                        "description": "Circuit ID of DHCP relay agent. If each character should be valid ASCII text symbol or else this value is displayed as hex dump.\n"
                    },
                    "agentRemoteId": {
                        "type": "string",
                        "description": "Remote ID, set by DHCP relay agent.\n"
                    },
                    "allowDualStackQueue": {
                        "type": "boolean",
                        "description": "Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.\n"
                    },
                    "alwaysBroadcast": {
                        "type": "boolean",
                        "description": "Send all replies as broadcasts.\n"
                    },
                    "blockAccess": {
                        "type": "boolean",
                        "description": "Whether to block access for this DHCP client (true|false).\n"
                    },
                    "blocked": {
                        "type": "boolean",
                        "description": "Whether the lease is blocked.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "If specified, must match DHCP 'client identifier' option of the request.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "dhcpOption": {
                        "type": "string",
                        "description": "Add additional DHCP options.\n"
                    },
                    "dhcpOptionSet": {
                        "type": "string",
                        "description": "Add additional set of DHCP options.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Whether the dhcp lease is static or dynamic. Dynamic leases are not guaranteed to continue to be assigned to that specific device. Defaults to false.\n"
                    },
                    "expiresAfter": {
                        "type": "string",
                        "description": "Time until lease expires.\n"
                    },
                    "hostName": {
                        "type": "string",
                        "description": "The hostname of the device\n"
                    },
                    "insertQueueBefore": {
                        "type": "string",
                        "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                    },
                    "lastSeen": {
                        "type": "string"
                    },
                    "leaseTime": {
                        "type": "string",
                        "description": "Time that the client may use the address. If set to 0s lease will never expire.\n"
                    },
                    "macAddress": {
                        "type": "string",
                        "description": "The MAC addreess of the DHCP lease to be created.\n"
                    },
                    "radius": {
                        "type": "string",
                        "description": "Shows if this dynamic lease is authenticated by RADIUS or not.\n"
                    },
                    "rateLimit": {
                        "type": "string",
                        "description": "Adds a dynamic simple queue to limit IP's bandwidth to a specified rate. Requires the lease to be static.\n"
                    },
                    "server": {
                        "type": "string",
                        "description": "Server name which serves this client.\n"
                    },
                    "srcMacAddress": {
                        "type": "string",
                        "description": "Source MAC address.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Lease status.\n"
                    },
                    "useSrcMac": {
                        "type": "boolean",
                        "description": "When this option is set server uses source MAC address instead of received CHADDR to assign address.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/dhcpIpServerNetwork:DhcpIpServerNetwork": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst dhcpServerNetwork = new routeros.ip.DhcpIpServerNetwork(\"dhcpServerNetwork\", {\n    address: \"10.0.0.0/24\",\n    dnsServer: \"1.1.1.1\",\n    gateway: \"10.0.0.1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ndhcp_server_network = routeros.ip.DhcpIpServerNetwork(\"dhcpServerNetwork\",\n    address=\"10.0.0.0/24\",\n    dns_server=\"1.1.1.1\",\n    gateway=\"10.0.0.1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dhcpServerNetwork = new Routeros.Ip.DhcpIpServerNetwork(\"dhcpServerNetwork\", new()\n    {\n        Address = \"10.0.0.0/24\",\n        DnsServer = \"1.1.1.1\",\n        Gateway = \"10.0.0.1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ip.NewDhcpIpServerNetwork(ctx, \"dhcpServerNetwork\", \u0026Ip.DhcpIpServerNetworkArgs{\n\t\t\tAddress:   pulumi.String(\"10.0.0.0/24\"),\n\t\t\tDnsServer: pulumi.String(\"1.1.1.1\"),\n\t\t\tGateway:   pulumi.String(\"10.0.0.1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.DhcpIpServerNetwork;\nimport com.pulumi.routeros.Ip.DhcpIpServerNetworkArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dhcpServerNetwork = new DhcpIpServerNetwork(\"dhcpServerNetwork\", DhcpIpServerNetworkArgs.builder()        \n            .address(\"10.0.0.0/24\")\n            .dnsServer(\"1.1.1.1\")\n            .gateway(\"10.0.0.1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dhcpServerNetwork:\n    type: routeros:Ip:DhcpIpServerNetwork\n    properties:\n      address: 10.0.0.0/24\n      dnsServer: 1.1.1.1\n      gateway: 10.0.0.1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ip/dhcp-server/network get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ip/dhcpIpServerNetwork:DhcpIpServerNetwork dhcp_server_network \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "The network DHCP server(s) will lease addresses from.\n"
                },
                "bootFileName": {
                    "type": "string",
                    "description": "Boot filename.\n"
                },
                "capsManager": {
                    "type": "string",
                    "description": "A comma-separated list of IP addresses for one or more CAPsMAN system managers. DHCP Option 138 (capwap) will be used.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcpOption": {
                    "type": "string",
                    "description": "Add additional DHCP options from the option list.\n"
                },
                "dhcpOptionSet": {
                    "type": "string",
                    "description": "Add an additional set of DHCP options.\n"
                },
                "dnsNone": {
                    "type": "boolean",
                    "description": "If set, then DHCP Server will not pass dynamic DNS servers configured on the router to the DHCP clients if no DNS Server in DNS-server is set.\n"
                },
                "dnsServer": {
                    "type": "string",
                    "description": "the DHCP client will use these as the default DNS servers. Two comma-separated DNS servers can be specified to be used by the DHCP client as primary and secondary DNS servers.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The DHCP client will use this as the 'DNS domain' setting for the network adapter.\n"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The default gateway to be used by DHCP Client.\n"
                },
                "netmask": {
                    "type": "integer",
                    "description": "The actual network mask is to be used by the DHCP client. If set to '0' - netmask from network address will be used.\n"
                },
                "nextServer": {
                    "type": "string",
                    "description": "The IP address of the next server to use in bootstrap.\n"
                },
                "ntpServer": {
                    "type": "string",
                    "description": "The DHCP client will use these as the default NTP servers. Two comma-separated NTP servers can be specified to be used by the DHCP client as primary and secondary NTP servers\n"
                },
                "winsServer": {
                    "type": "string",
                    "description": "The Windows DHCP client will use these as the default WINS servers. Two comma-separated WINS servers can be specified to be used by the DHCP client as primary and secondary WINS servers\n"
                }
            },
            "required": [
                "address",
                "dynamic"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "The network DHCP server(s) will lease addresses from.\n"
                },
                "bootFileName": {
                    "type": "string",
                    "description": "Boot filename.\n"
                },
                "capsManager": {
                    "type": "string",
                    "description": "A comma-separated list of IP addresses for one or more CAPsMAN system managers. DHCP Option 138 (capwap) will be used.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcpOption": {
                    "type": "string",
                    "description": "Add additional DHCP options from the option list.\n"
                },
                "dhcpOptionSet": {
                    "type": "string",
                    "description": "Add an additional set of DHCP options.\n"
                },
                "dnsNone": {
                    "type": "boolean",
                    "description": "If set, then DHCP Server will not pass dynamic DNS servers configured on the router to the DHCP clients if no DNS Server in DNS-server is set.\n"
                },
                "dnsServer": {
                    "type": "string",
                    "description": "the DHCP client will use these as the default DNS servers. Two comma-separated DNS servers can be specified to be used by the DHCP client as primary and secondary DNS servers.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The DHCP client will use this as the 'DNS domain' setting for the network adapter.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The default gateway to be used by DHCP Client.\n"
                },
                "netmask": {
                    "type": "integer",
                    "description": "The actual network mask is to be used by the DHCP client. If set to '0' - netmask from network address will be used.\n"
                },
                "nextServer": {
                    "type": "string",
                    "description": "The IP address of the next server to use in bootstrap.\n"
                },
                "ntpServer": {
                    "type": "string",
                    "description": "The DHCP client will use these as the default NTP servers. Two comma-separated NTP servers can be specified to be used by the DHCP client as primary and secondary NTP servers\n"
                },
                "winsServer": {
                    "type": "string",
                    "description": "The Windows DHCP client will use these as the default WINS servers. Two comma-separated WINS servers can be specified to be used by the DHCP client as primary and secondary WINS servers\n"
                }
            },
            "requiredInputs": [
                "address"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DhcpIpServerNetwork resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "The network DHCP server(s) will lease addresses from.\n"
                    },
                    "bootFileName": {
                        "type": "string",
                        "description": "Boot filename.\n"
                    },
                    "capsManager": {
                        "type": "string",
                        "description": "A comma-separated list of IP addresses for one or more CAPsMAN system managers. DHCP Option 138 (capwap) will be used.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "dhcpOption": {
                        "type": "string",
                        "description": "Add additional DHCP options from the option list.\n"
                    },
                    "dhcpOptionSet": {
                        "type": "string",
                        "description": "Add an additional set of DHCP options.\n"
                    },
                    "dnsNone": {
                        "type": "boolean",
                        "description": "If set, then DHCP Server will not pass dynamic DNS servers configured on the router to the DHCP clients if no DNS Server in DNS-server is set.\n"
                    },
                    "dnsServer": {
                        "type": "string",
                        "description": "the DHCP client will use these as the default DNS servers. Two comma-separated DNS servers can be specified to be used by the DHCP client as primary and secondary DNS servers.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The DHCP client will use this as the 'DNS domain' setting for the network adapter.\n"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                    },
                    "gateway": {
                        "type": "string",
                        "description": "The default gateway to be used by DHCP Client.\n"
                    },
                    "netmask": {
                        "type": "integer",
                        "description": "The actual network mask is to be used by the DHCP client. If set to '0' - netmask from network address will be used.\n"
                    },
                    "nextServer": {
                        "type": "string",
                        "description": "The IP address of the next server to use in bootstrap.\n"
                    },
                    "ntpServer": {
                        "type": "string",
                        "description": "The DHCP client will use these as the default NTP servers. Two comma-separated NTP servers can be specified to be used by the DHCP client as primary and secondary NTP servers\n"
                    },
                    "winsServer": {
                        "type": "string",
                        "description": "The Windows DHCP client will use these as the default WINS servers. Two comma-separated WINS servers can be specified to be used by the DHCP client as primary and secondary WINS servers\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/dhcpServer:DhcpServer": {
            "description": "## # routeros.Ip.DhcpServer (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Ip.DhcpIpServer\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "addArp": {
                    "type": "boolean",
                    "description": "Whether to add dynamic ARP entry.\n"
                },
                "addressPool": {
                    "type": "string",
                    "description": "IP pool, from which to take IP addresses for the clients. If set to static-only, then only the clients that have a\nstatic lease (added in lease submenu) will be allowed.\n"
                },
                "allowDualStackQueue": {
                    "type": "boolean",
                    "description": "Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.\nRequires IPv6 DHCP Server to have this option enabled as well to work properly.\n"
                },
                "alwaysBroadcast": {
                    "type": "boolean",
                    "description": "Always send replies as broadcasts even if destination IP is known.\n"
                },
                "authoritative": {
                    "type": "string",
                    "description": "Option changes the way how a server responds to DHCP requests.\n"
                },
                "bootpLeaseTime": {
                    "type": "string",
                    "description": "Accepts two predefined options or time value: * forever - lease never expires * lease-time - use time from lease-time\nparameter\n"
                },
                "bootpSupport": {
                    "type": "string",
                    "description": "Support for BOOTP clients.\n"
                },
                "clientMacLimit": {
                    "type": "integer",
                    "description": "Specifies whether to limit specific number of clients per single MAC address.\n"
                },
                "comment": {
                    "type": "string"
                },
                "conflictDetection": {
                    "type": "boolean",
                    "description": "Allows to disable/enable conflict detection. If option is enabled, then whenever server tries to assign a lease it will\nsend ICMP and ARP messages to detect whether such address in the network already exist. If any of above get reply\naddress is considered already used. Conflict detection must be disabled when any kind of DHCP client limitation per port\nor per mac is used.\n"
                },
                "delayThreshold": {
                    "type": "string",
                    "description": "If secs field in DHCP packet is smaller than delay-threshold, then this packet is ignored. If set to none - there is no\nthreshold (all DHCP packets are processed).\n"
                },
                "dhcpOptionSet": {
                    "type": "string",
                    "description": "Use custom set of DHCP options defined in option sets menu.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "insertQueueBefore": {
                    "type": "string",
                    "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "leaseScript": {
                    "type": "string",
                    "description": "A script that will be executed after a lease is assigned or de-assigned.\n"
                },
                "leaseTime": {
                    "type": "string",
                    "description": "The time that a client may use the assigned address. The client will try to renew this address after half of this time\nand will request a new address after the time limit expires.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "parentQueue": {
                    "type": "string"
                },
                "relay": {
                    "type": "string",
                    "description": "The IP address of the relay this DHCP server.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "The address which the DHCP client must send requests to in order to renew an IP address lease.\n"
                },
                "useFramedAsClassless": {
                    "type": "boolean",
                    "description": "Forward RADIUS Framed-Route as a DHCP Classless-Static-Route to DHCP-client.\n"
                },
                "useRadius": {
                    "type": "string",
                    "description": "Whether to use RADIUS server.\n"
                }
            },
            "required": [
                "dynamic",
                "interface",
                "invalid",
                "name"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "addArp": {
                    "type": "boolean",
                    "description": "Whether to add dynamic ARP entry.\n"
                },
                "addressPool": {
                    "type": "string",
                    "description": "IP pool, from which to take IP addresses for the clients. If set to static-only, then only the clients that have a\nstatic lease (added in lease submenu) will be allowed.\n"
                },
                "allowDualStackQueue": {
                    "type": "boolean",
                    "description": "Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.\nRequires IPv6 DHCP Server to have this option enabled as well to work properly.\n"
                },
                "alwaysBroadcast": {
                    "type": "boolean",
                    "description": "Always send replies as broadcasts even if destination IP is known.\n"
                },
                "authoritative": {
                    "type": "string",
                    "description": "Option changes the way how a server responds to DHCP requests.\n"
                },
                "bootpLeaseTime": {
                    "type": "string",
                    "description": "Accepts two predefined options or time value: * forever - lease never expires * lease-time - use time from lease-time\nparameter\n"
                },
                "bootpSupport": {
                    "type": "string",
                    "description": "Support for BOOTP clients.\n"
                },
                "clientMacLimit": {
                    "type": "integer",
                    "description": "Specifies whether to limit specific number of clients per single MAC address.\n"
                },
                "comment": {
                    "type": "string"
                },
                "conflictDetection": {
                    "type": "boolean",
                    "description": "Allows to disable/enable conflict detection. If option is enabled, then whenever server tries to assign a lease it will\nsend ICMP and ARP messages to detect whether such address in the network already exist. If any of above get reply\naddress is considered already used. Conflict detection must be disabled when any kind of DHCP client limitation per port\nor per mac is used.\n"
                },
                "delayThreshold": {
                    "type": "string",
                    "description": "If secs field in DHCP packet is smaller than delay-threshold, then this packet is ignored. If set to none - there is no\nthreshold (all DHCP packets are processed).\n"
                },
                "dhcpOptionSet": {
                    "type": "string",
                    "description": "Use custom set of DHCP options defined in option sets menu.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "insertQueueBefore": {
                    "type": "string",
                    "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "leaseScript": {
                    "type": "string",
                    "description": "A script that will be executed after a lease is assigned or de-assigned.\n"
                },
                "leaseTime": {
                    "type": "string",
                    "description": "The time that a client may use the assigned address. The client will try to renew this address after half of this time\nand will request a new address after the time limit expires.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "parentQueue": {
                    "type": "string"
                },
                "relay": {
                    "type": "string",
                    "description": "The IP address of the relay this DHCP server.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "The address which the DHCP client must send requests to in order to renew an IP address lease.\n"
                },
                "useFramedAsClassless": {
                    "type": "boolean",
                    "description": "Forward RADIUS Framed-Route as a DHCP Classless-Static-Route to DHCP-client.\n"
                },
                "useRadius": {
                    "type": "string",
                    "description": "Whether to use RADIUS server.\n"
                }
            },
            "requiredInputs": [
                "interface"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DhcpServer resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "addArp": {
                        "type": "boolean",
                        "description": "Whether to add dynamic ARP entry.\n"
                    },
                    "addressPool": {
                        "type": "string",
                        "description": "IP pool, from which to take IP addresses for the clients. If set to static-only, then only the clients that have a\nstatic lease (added in lease submenu) will be allowed.\n"
                    },
                    "allowDualStackQueue": {
                        "type": "boolean",
                        "description": "Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.\nRequires IPv6 DHCP Server to have this option enabled as well to work properly.\n"
                    },
                    "alwaysBroadcast": {
                        "type": "boolean",
                        "description": "Always send replies as broadcasts even if destination IP is known.\n"
                    },
                    "authoritative": {
                        "type": "string",
                        "description": "Option changes the way how a server responds to DHCP requests.\n"
                    },
                    "bootpLeaseTime": {
                        "type": "string",
                        "description": "Accepts two predefined options or time value: * forever - lease never expires * lease-time - use time from lease-time\nparameter\n"
                    },
                    "bootpSupport": {
                        "type": "string",
                        "description": "Support for BOOTP clients.\n"
                    },
                    "clientMacLimit": {
                        "type": "integer",
                        "description": "Specifies whether to limit specific number of clients per single MAC address.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "conflictDetection": {
                        "type": "boolean",
                        "description": "Allows to disable/enable conflict detection. If option is enabled, then whenever server tries to assign a lease it will\nsend ICMP and ARP messages to detect whether such address in the network already exist. If any of above get reply\naddress is considered already used. Conflict detection must be disabled when any kind of DHCP client limitation per port\nor per mac is used.\n"
                    },
                    "delayThreshold": {
                        "type": "string",
                        "description": "If secs field in DHCP packet is smaller than delay-threshold, then this packet is ignored. If set to none - there is no\nthreshold (all DHCP packets are processed).\n"
                    },
                    "dhcpOptionSet": {
                        "type": "string",
                        "description": "Use custom set of DHCP options defined in option sets menu.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "insertQueueBefore": {
                        "type": "string",
                        "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "leaseScript": {
                        "type": "string",
                        "description": "A script that will be executed after a lease is assigned or de-assigned.\n"
                    },
                    "leaseTime": {
                        "type": "string",
                        "description": "The time that a client may use the assigned address. The client will try to renew this address after half of this time\nand will request a new address after the time limit expires.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "parentQueue": {
                        "type": "string"
                    },
                    "relay": {
                        "type": "string",
                        "description": "The IP address of the relay this DHCP server.\n"
                    },
                    "srcAddress": {
                        "type": "string",
                        "description": "The address which the DHCP client must send requests to in order to renew an IP address lease.\n"
                    },
                    "useFramedAsClassless": {
                        "type": "boolean",
                        "description": "Forward RADIUS Framed-Route as a DHCP Classless-Static-Route to DHCP-client.\n"
                    },
                    "useRadius": {
                        "type": "string",
                        "description": "Whether to use RADIUS server.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/dhcpServerLease:DhcpServerLease": {
            "description": "## # routeros.Ip.DhcpServerLease (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Ip.DhcpIpServerLease\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "activeAddress": {
                    "type": "string",
                    "description": "The IP address of the machine currently holding the DHCP lease.\n"
                },
                "activeClientId": {
                    "type": "string",
                    "description": "Actual client-id of the client.\n"
                },
                "activeHostname": {
                    "type": "string",
                    "description": "The hostname of the machine currently holding the DHCP lease.\n"
                },
                "activeMacAddress": {
                    "type": "string",
                    "description": "The MAC address of of the machine currently holding the DHCP lease.\n"
                },
                "activeServer": {
                    "type": "string",
                    "description": "Actual dhcp server, which serves this client.\n"
                },
                "address": {
                    "type": "string",
                    "description": "The IP address of the DHCP lease to be created.\n"
                },
                "addressLists": {
                    "type": "string",
                    "description": "Address list to which address will be added if lease is bound.\n"
                },
                "agentCircuitId": {
                    "type": "string",
                    "description": "Circuit ID of DHCP relay agent. If each character should be valid ASCII text symbol or else this value is displayed as\nhex dump.\n"
                },
                "agentRemoteId": {
                    "type": "string",
                    "description": "Remote ID, set by DHCP relay agent.\n"
                },
                "allowDualStackQueue": {
                    "type": "boolean",
                    "description": "Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.\n"
                },
                "alwaysBroadcast": {
                    "type": "boolean",
                    "description": "Send all replies as broadcasts.\n"
                },
                "blockAccess": {
                    "type": "boolean",
                    "description": "Whether to block access for this DHCP client (true|false).\n"
                },
                "blocked": {
                    "type": "boolean",
                    "description": "Whether the lease is blocked.\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "If specified, must match DHCP 'client identifier' option of the request.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcpOption": {
                    "type": "string",
                    "description": "Add additional DHCP options.\n"
                },
                "dhcpOptionSet": {
                    "type": "string",
                    "description": "Add additional set of DHCP options.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Whether the dhcp lease is static or dynamic. Dynamic leases are not guaranteed to continue to be assigned to that\nspecific device. Defaults to false.\n"
                },
                "expiresAfter": {
                    "type": "string",
                    "description": "Time until lease expires.\n"
                },
                "hostName": {
                    "type": "string",
                    "description": "The hostname of the device\n"
                },
                "insertQueueBefore": {
                    "type": "string",
                    "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                },
                "lastSeen": {
                    "type": "string"
                },
                "leaseTime": {
                    "type": "string",
                    "description": "Time that the client may use the address. If set to 0s lease will never expire.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC addreess of the DHCP lease to be created.\n"
                },
                "radius": {
                    "type": "string",
                    "description": "Shows if this dynamic lease is authenticated by RADIUS or not.\n"
                },
                "rateLimit": {
                    "type": "string",
                    "description": "Adds a dynamic simple queue to limit IP's bandwidth to a specified rate. Requires the lease to be static.\n"
                },
                "server": {
                    "type": "string",
                    "description": "Server name which serves this client.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Source MAC address.\n"
                },
                "status": {
                    "type": "string",
                    "description": "Lease status.\n"
                },
                "useSrcMac": {
                    "type": "boolean",
                    "description": "When this option is set server uses source MAC address instead of received CHADDR to assign address.\n"
                }
            },
            "required": [
                "activeAddress",
                "activeClientId",
                "activeHostname",
                "activeMacAddress",
                "activeServer",
                "address",
                "agentCircuitId",
                "agentRemoteId",
                "blocked",
                "expiresAfter",
                "hostName",
                "lastSeen",
                "macAddress",
                "radius",
                "srcMacAddress",
                "status"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "The IP address of the DHCP lease to be created.\n"
                },
                "addressLists": {
                    "type": "string",
                    "description": "Address list to which address will be added if lease is bound.\n"
                },
                "allowDualStackQueue": {
                    "type": "boolean",
                    "description": "Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.\n"
                },
                "alwaysBroadcast": {
                    "type": "boolean",
                    "description": "Send all replies as broadcasts.\n"
                },
                "blockAccess": {
                    "type": "boolean",
                    "description": "Whether to block access for this DHCP client (true|false).\n"
                },
                "clientId": {
                    "type": "string",
                    "description": "If specified, must match DHCP 'client identifier' option of the request.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcpOption": {
                    "type": "string",
                    "description": "Add additional DHCP options.\n"
                },
                "dhcpOptionSet": {
                    "type": "string",
                    "description": "Add additional set of DHCP options.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Whether the dhcp lease is static or dynamic. Dynamic leases are not guaranteed to continue to be assigned to that\nspecific device. Defaults to false.\n"
                },
                "insertQueueBefore": {
                    "type": "string",
                    "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                },
                "leaseTime": {
                    "type": "string",
                    "description": "Time that the client may use the address. If set to 0s lease will never expire.\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "The MAC addreess of the DHCP lease to be created.\n"
                },
                "rateLimit": {
                    "type": "string",
                    "description": "Adds a dynamic simple queue to limit IP's bandwidth to a specified rate. Requires the lease to be static.\n"
                },
                "server": {
                    "type": "string",
                    "description": "Server name which serves this client.\n"
                },
                "useSrcMac": {
                    "type": "boolean",
                    "description": "When this option is set server uses source MAC address instead of received CHADDR to assign address.\n"
                }
            },
            "requiredInputs": [
                "address",
                "macAddress"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DhcpServerLease resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "activeAddress": {
                        "type": "string",
                        "description": "The IP address of the machine currently holding the DHCP lease.\n"
                    },
                    "activeClientId": {
                        "type": "string",
                        "description": "Actual client-id of the client.\n"
                    },
                    "activeHostname": {
                        "type": "string",
                        "description": "The hostname of the machine currently holding the DHCP lease.\n"
                    },
                    "activeMacAddress": {
                        "type": "string",
                        "description": "The MAC address of of the machine currently holding the DHCP lease.\n"
                    },
                    "activeServer": {
                        "type": "string",
                        "description": "Actual dhcp server, which serves this client.\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "The IP address of the DHCP lease to be created.\n"
                    },
                    "addressLists": {
                        "type": "string",
                        "description": "Address list to which address will be added if lease is bound.\n"
                    },
                    "agentCircuitId": {
                        "type": "string",
                        "description": "Circuit ID of DHCP relay agent. If each character should be valid ASCII text symbol or else this value is displayed as\nhex dump.\n"
                    },
                    "agentRemoteId": {
                        "type": "string",
                        "description": "Remote ID, set by DHCP relay agent.\n"
                    },
                    "allowDualStackQueue": {
                        "type": "boolean",
                        "description": "Creates a single simple queue entry for both IPv4 and IPv6 addresses, uses the MAC address and DUID for identification.\n"
                    },
                    "alwaysBroadcast": {
                        "type": "boolean",
                        "description": "Send all replies as broadcasts.\n"
                    },
                    "blockAccess": {
                        "type": "boolean",
                        "description": "Whether to block access for this DHCP client (true|false).\n"
                    },
                    "blocked": {
                        "type": "boolean",
                        "description": "Whether the lease is blocked.\n"
                    },
                    "clientId": {
                        "type": "string",
                        "description": "If specified, must match DHCP 'client identifier' option of the request.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "dhcpOption": {
                        "type": "string",
                        "description": "Add additional DHCP options.\n"
                    },
                    "dhcpOptionSet": {
                        "type": "string",
                        "description": "Add additional set of DHCP options.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Whether the dhcp lease is static or dynamic. Dynamic leases are not guaranteed to continue to be assigned to that\nspecific device. Defaults to false.\n"
                    },
                    "expiresAfter": {
                        "type": "string",
                        "description": "Time until lease expires.\n"
                    },
                    "hostName": {
                        "type": "string",
                        "description": "The hostname of the device\n"
                    },
                    "insertQueueBefore": {
                        "type": "string",
                        "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                    },
                    "lastSeen": {
                        "type": "string"
                    },
                    "leaseTime": {
                        "type": "string",
                        "description": "Time that the client may use the address. If set to 0s lease will never expire.\n"
                    },
                    "macAddress": {
                        "type": "string",
                        "description": "The MAC addreess of the DHCP lease to be created.\n"
                    },
                    "radius": {
                        "type": "string",
                        "description": "Shows if this dynamic lease is authenticated by RADIUS or not.\n"
                    },
                    "rateLimit": {
                        "type": "string",
                        "description": "Adds a dynamic simple queue to limit IP's bandwidth to a specified rate. Requires the lease to be static.\n"
                    },
                    "server": {
                        "type": "string",
                        "description": "Server name which serves this client.\n"
                    },
                    "srcMacAddress": {
                        "type": "string",
                        "description": "Source MAC address.\n"
                    },
                    "status": {
                        "type": "string",
                        "description": "Lease status.\n"
                    },
                    "useSrcMac": {
                        "type": "boolean",
                        "description": "When this option is set server uses source MAC address instead of received CHADDR to assign address.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/dhcpServerNetwork:DhcpServerNetwork": {
            "description": "## # routeros.Ip.DhcpServerNetwork (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Ip.DhcpIpServerNetwork\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "The network DHCP server(s) will lease addresses from.\n"
                },
                "bootFileName": {
                    "type": "string",
                    "description": "Boot filename.\n"
                },
                "capsManager": {
                    "type": "string",
                    "description": "A comma-separated list of IP addresses for one or more CAPsMAN system managers. DHCP Option 138 (capwap) will be used.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcpOption": {
                    "type": "string",
                    "description": "Add additional DHCP options from the option list.\n"
                },
                "dhcpOptionSet": {
                    "type": "string",
                    "description": "Add an additional set of DHCP options.\n"
                },
                "dnsNone": {
                    "type": "boolean",
                    "description": "If set, then DHCP Server will not pass dynamic DNS servers configured on the router to the DHCP clients if no DNS Server\nin DNS-server is set.\n"
                },
                "dnsServer": {
                    "type": "string",
                    "description": "the DHCP client will use these as the default DNS servers. Two comma-separated DNS servers can be specified to be used\nby the DHCP client as primary and secondary DNS servers.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The DHCP client will use this as the 'DNS domain' setting for the network adapter.\n"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The default gateway to be used by DHCP Client.\n"
                },
                "netmask": {
                    "type": "integer",
                    "description": "The actual network mask is to be used by the DHCP client. If set to '0' - netmask from network address will be used.\n"
                },
                "nextServer": {
                    "type": "string",
                    "description": "The IP address of the next server to use in bootstrap.\n"
                },
                "ntpServer": {
                    "type": "string",
                    "description": "The DHCP client will use these as the default NTP servers. Two comma-separated NTP servers can be specified to be used\nby the DHCP client as primary and secondary NTP servers\n"
                },
                "winsServer": {
                    "type": "string",
                    "description": "The Windows DHCP client will use these as the default WINS servers. Two comma-separated WINS servers can be specified to\nbe used by the DHCP client as primary and secondary WINS servers\n"
                }
            },
            "required": [
                "address",
                "dynamic"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "The network DHCP server(s) will lease addresses from.\n"
                },
                "bootFileName": {
                    "type": "string",
                    "description": "Boot filename.\n"
                },
                "capsManager": {
                    "type": "string",
                    "description": "A comma-separated list of IP addresses for one or more CAPsMAN system managers. DHCP Option 138 (capwap) will be used.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcpOption": {
                    "type": "string",
                    "description": "Add additional DHCP options from the option list.\n"
                },
                "dhcpOptionSet": {
                    "type": "string",
                    "description": "Add an additional set of DHCP options.\n"
                },
                "dnsNone": {
                    "type": "boolean",
                    "description": "If set, then DHCP Server will not pass dynamic DNS servers configured on the router to the DHCP clients if no DNS Server\nin DNS-server is set.\n"
                },
                "dnsServer": {
                    "type": "string",
                    "description": "the DHCP client will use these as the default DNS servers. Two comma-separated DNS servers can be specified to be used\nby the DHCP client as primary and secondary DNS servers.\n"
                },
                "domain": {
                    "type": "string",
                    "description": "The DHCP client will use this as the 'DNS domain' setting for the network adapter.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "The default gateway to be used by DHCP Client.\n"
                },
                "netmask": {
                    "type": "integer",
                    "description": "The actual network mask is to be used by the DHCP client. If set to '0' - netmask from network address will be used.\n"
                },
                "nextServer": {
                    "type": "string",
                    "description": "The IP address of the next server to use in bootstrap.\n"
                },
                "ntpServer": {
                    "type": "string",
                    "description": "The DHCP client will use these as the default NTP servers. Two comma-separated NTP servers can be specified to be used\nby the DHCP client as primary and secondary NTP servers\n"
                },
                "winsServer": {
                    "type": "string",
                    "description": "The Windows DHCP client will use these as the default WINS servers. Two comma-separated WINS servers can be specified to\nbe used by the DHCP client as primary and secondary WINS servers\n"
                }
            },
            "requiredInputs": [
                "address"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DhcpServerNetwork resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "The network DHCP server(s) will lease addresses from.\n"
                    },
                    "bootFileName": {
                        "type": "string",
                        "description": "Boot filename.\n"
                    },
                    "capsManager": {
                        "type": "string",
                        "description": "A comma-separated list of IP addresses for one or more CAPsMAN system managers. DHCP Option 138 (capwap) will be used.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "dhcpOption": {
                        "type": "string",
                        "description": "Add additional DHCP options from the option list.\n"
                    },
                    "dhcpOptionSet": {
                        "type": "string",
                        "description": "Add an additional set of DHCP options.\n"
                    },
                    "dnsNone": {
                        "type": "boolean",
                        "description": "If set, then DHCP Server will not pass dynamic DNS servers configured on the router to the DHCP clients if no DNS Server\nin DNS-server is set.\n"
                    },
                    "dnsServer": {
                        "type": "string",
                        "description": "the DHCP client will use these as the default DNS servers. Two comma-separated DNS servers can be specified to be used\nby the DHCP client as primary and secondary DNS servers.\n"
                    },
                    "domain": {
                        "type": "string",
                        "description": "The DHCP client will use this as the 'DNS domain' setting for the network adapter.\n"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "gateway": {
                        "type": "string",
                        "description": "The default gateway to be used by DHCP Client.\n"
                    },
                    "netmask": {
                        "type": "integer",
                        "description": "The actual network mask is to be used by the DHCP client. If set to '0' - netmask from network address will be used.\n"
                    },
                    "nextServer": {
                        "type": "string",
                        "description": "The IP address of the next server to use in bootstrap.\n"
                    },
                    "ntpServer": {
                        "type": "string",
                        "description": "The DHCP client will use these as the default NTP servers. Two comma-separated NTP servers can be specified to be used\nby the DHCP client as primary and secondary NTP servers\n"
                    },
                    "winsServer": {
                        "type": "string",
                        "description": "The Windows DHCP client will use these as the default WINS servers. Two comma-separated WINS servers can be specified to\nbe used by the DHCP client as primary and secondary WINS servers\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/dns:Dns": {
            "description": "## # routeros.Ip.Dns (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Ip.IpDns\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "allowRemoteRequests": {
                    "type": "boolean",
                    "description": "Specifies whether to allow network requests.\n"
                },
                "cacheMaxTtl": {
                    "type": "string",
                    "description": "Maximum time-to-live for cache records. In other words, cache records will expire unconditionally after cache-max-ttl\ntime. Shorter TTL received from DNS servers are respected. *Default: 1w*\n"
                },
                "cacheSize": {
                    "type": "integer",
                    "description": "Specifies the size of DNS cache in KiB (64..4294967295). *Default: 2048*\n"
                },
                "cacheUsed": {
                    "type": "integer",
                    "description": "Shows the currently used cache size in KiB.\n"
                },
                "dohMaxConcurrentQueries": {
                    "type": "integer",
                    "description": "Specifies how many DoH concurrent queries are allowed.\n"
                },
                "dohMaxServerConnections": {
                    "type": "integer",
                    "description": "Specifies how many concurrent connections to the DoH server are allowed.\n"
                },
                "dohTimeout": {
                    "type": "string",
                    "description": "Specifies how long to wait for query response from the DoH server.\n"
                },
                "dynamicServers": {
                    "type": "string",
                    "description": "List of dynamically added DNS server from different services, for example, DHCP.\n"
                },
                "maxConcurrentQueries": {
                    "type": "integer",
                    "description": "Specifies how much concurrent queries are allowed. *Default: 100*\n"
                },
                "maxConcurrentTcpSessions": {
                    "type": "integer",
                    "description": "Specifies how much concurrent TCP sessions are allowed. *Default: 20*\n"
                },
                "maxUdpPacketSize": {
                    "type": "integer",
                    "description": "Maximum size of allowed UDP packet. *Default: 4096*\n"
                },
                "queryServerTimeout": {
                    "type": "string",
                    "description": "Specifies how long to wait for query response from one server. Time can be specified in milliseconds. *Default: 2s*\n"
                },
                "queryTotalTimeout": {
                    "type": "string",
                    "description": "Specifies how long to wait for query response in total. Note that this setting must be configured taking into account\nquery_server_timeout and number of used DNS server. Time can be specified in milliseconds. *Default: 10s*\n"
                },
                "servers": {
                    "type": "string",
                    "description": "List of DNS server IPv4/IPv6 addresses.\n"
                },
                "useDohServer": {
                    "type": "string",
                    "description": "DNS over HTTPS (DoH) server URL. \u003e Mikrotik strongly suggest not use third-party download links for certificate\nfetching. Use the Certificate Authority's own website. \u003e RouterOS prioritize DoH over DNS server if both are configured\non the device.\n"
                },
                "verifyDohCert": {
                    "type": "boolean",
                    "description": "DoH certificate verification. [See docs](https://wiki.mikrotik.com/wiki/Manual:IP/DNS#DNS_over_HTTPS).\n"
                }
            },
            "required": [
                "cacheMaxTtl",
                "cacheSize",
                "cacheUsed",
                "dohMaxConcurrentQueries",
                "dohMaxServerConnections",
                "dohTimeout",
                "dynamicServers",
                "maxConcurrentQueries",
                "maxConcurrentTcpSessions",
                "maxUdpPacketSize",
                "queryServerTimeout",
                "queryTotalTimeout"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "allowRemoteRequests": {
                    "type": "boolean",
                    "description": "Specifies whether to allow network requests.\n"
                },
                "cacheMaxTtl": {
                    "type": "string",
                    "description": "Maximum time-to-live for cache records. In other words, cache records will expire unconditionally after cache-max-ttl\ntime. Shorter TTL received from DNS servers are respected. *Default: 1w*\n"
                },
                "cacheSize": {
                    "type": "integer",
                    "description": "Specifies the size of DNS cache in KiB (64..4294967295). *Default: 2048*\n"
                },
                "dohMaxConcurrentQueries": {
                    "type": "integer",
                    "description": "Specifies how many DoH concurrent queries are allowed.\n"
                },
                "dohMaxServerConnections": {
                    "type": "integer",
                    "description": "Specifies how many concurrent connections to the DoH server are allowed.\n"
                },
                "dohTimeout": {
                    "type": "string",
                    "description": "Specifies how long to wait for query response from the DoH server.\n"
                },
                "maxConcurrentQueries": {
                    "type": "integer",
                    "description": "Specifies how much concurrent queries are allowed. *Default: 100*\n"
                },
                "maxConcurrentTcpSessions": {
                    "type": "integer",
                    "description": "Specifies how much concurrent TCP sessions are allowed. *Default: 20*\n"
                },
                "maxUdpPacketSize": {
                    "type": "integer",
                    "description": "Maximum size of allowed UDP packet. *Default: 4096*\n"
                },
                "queryServerTimeout": {
                    "type": "string",
                    "description": "Specifies how long to wait for query response from one server. Time can be specified in milliseconds. *Default: 2s*\n"
                },
                "queryTotalTimeout": {
                    "type": "string",
                    "description": "Specifies how long to wait for query response in total. Note that this setting must be configured taking into account\nquery_server_timeout and number of used DNS server. Time can be specified in milliseconds. *Default: 10s*\n"
                },
                "servers": {
                    "type": "string",
                    "description": "List of DNS server IPv4/IPv6 addresses.\n"
                },
                "useDohServer": {
                    "type": "string",
                    "description": "DNS over HTTPS (DoH) server URL. \u003e Mikrotik strongly suggest not use third-party download links for certificate\nfetching. Use the Certificate Authority's own website. \u003e RouterOS prioritize DoH over DNS server if both are configured\non the device.\n"
                },
                "verifyDohCert": {
                    "type": "boolean",
                    "description": "DoH certificate verification. [See docs](https://wiki.mikrotik.com/wiki/Manual:IP/DNS#DNS_over_HTTPS).\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Dns resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "allowRemoteRequests": {
                        "type": "boolean",
                        "description": "Specifies whether to allow network requests.\n"
                    },
                    "cacheMaxTtl": {
                        "type": "string",
                        "description": "Maximum time-to-live for cache records. In other words, cache records will expire unconditionally after cache-max-ttl\ntime. Shorter TTL received from DNS servers are respected. *Default: 1w*\n"
                    },
                    "cacheSize": {
                        "type": "integer",
                        "description": "Specifies the size of DNS cache in KiB (64..4294967295). *Default: 2048*\n"
                    },
                    "cacheUsed": {
                        "type": "integer",
                        "description": "Shows the currently used cache size in KiB.\n"
                    },
                    "dohMaxConcurrentQueries": {
                        "type": "integer",
                        "description": "Specifies how many DoH concurrent queries are allowed.\n"
                    },
                    "dohMaxServerConnections": {
                        "type": "integer",
                        "description": "Specifies how many concurrent connections to the DoH server are allowed.\n"
                    },
                    "dohTimeout": {
                        "type": "string",
                        "description": "Specifies how long to wait for query response from the DoH server.\n"
                    },
                    "dynamicServers": {
                        "type": "string",
                        "description": "List of dynamically added DNS server from different services, for example, DHCP.\n"
                    },
                    "maxConcurrentQueries": {
                        "type": "integer",
                        "description": "Specifies how much concurrent queries are allowed. *Default: 100*\n"
                    },
                    "maxConcurrentTcpSessions": {
                        "type": "integer",
                        "description": "Specifies how much concurrent TCP sessions are allowed. *Default: 20*\n"
                    },
                    "maxUdpPacketSize": {
                        "type": "integer",
                        "description": "Maximum size of allowed UDP packet. *Default: 4096*\n"
                    },
                    "queryServerTimeout": {
                        "type": "string",
                        "description": "Specifies how long to wait for query response from one server. Time can be specified in milliseconds. *Default: 2s*\n"
                    },
                    "queryTotalTimeout": {
                        "type": "string",
                        "description": "Specifies how long to wait for query response in total. Note that this setting must be configured taking into account\nquery_server_timeout and number of used DNS server. Time can be specified in milliseconds. *Default: 10s*\n"
                    },
                    "servers": {
                        "type": "string",
                        "description": "List of DNS server IPv4/IPv6 addresses.\n"
                    },
                    "useDohServer": {
                        "type": "string",
                        "description": "DNS over HTTPS (DoH) server URL. \u003e Mikrotik strongly suggest not use third-party download links for certificate\nfetching. Use the Certificate Authority's own website. \u003e RouterOS prioritize DoH over DNS server if both are configured\non the device.\n"
                    },
                    "verifyDohCert": {
                        "type": "boolean",
                        "description": "DoH certificate verification. [See docs](https://wiki.mikrotik.com/wiki/Manual:IP/DNS#DNS_over_HTTPS).\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/dnsRecord:DnsRecord": {
            "description": "## # routeros.Ip.DnsRecord (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Ip.IpDnsRecord\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "The A record to be returend from the DNS hostname.\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Name of the Firewall address list to which address must be dynamically added when some request matches the entry.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Alias name for a domain name.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "forwardTo": {
                    "type": "string",
                    "description": "The IP address of a domain name server to which a particular DNS request must be forwarded.\n"
                },
                "matchSubdomain": {
                    "type": "boolean",
                    "description": "Whether the record will match requests for subdomains.\n"
                },
                "mxExchange": {
                    "type": "string",
                    "description": "The domain name of the MX server.\n"
                },
                "mxPreference": {
                    "type": "integer",
                    "description": "Preference of the particular MX record.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the DNS hostname to be created.\n"
                },
                "ns": {
                    "type": "string",
                    "description": "Name of the authoritative domain name server for the particular record.\n"
                },
                "regexp": {
                    "type": "string",
                    "description": "DNS regexp. Regexp entries are case sensitive, but since DNS requests are not case sensitive, RouterOS converts DNS\nnames to lowercase, you should write regex only with lowercase letters.\n"
                },
                "srvPort": {
                    "type": "integer",
                    "description": "The TCP or UDP port on which the service is to be found.\n"
                },
                "srvPriority": {
                    "type": "integer",
                    "description": "Priority of the particular SRV record.\n"
                },
                "srvTarget": {
                    "type": "string",
                    "description": "The canonical hostname of the machine providing the service ends in a dot.\n"
                },
                "srvWeight": {
                    "type": "string",
                    "description": "Weight of the particular SRC record.\n"
                },
                "text": {
                    "type": "string",
                    "description": "Textual information about the domain name.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The ttl of the DNS record.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the DNS record. Available values are: A, AAAA, CNAME, FWD, MX, NS, NXDOMAIN, SRV, TXT\n"
                }
            },
            "required": [
                "dynamic",
                "mxPreference",
                "name",
                "srvPort",
                "srvPriority",
                "srvWeight",
                "ttl",
                "type"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "The A record to be returend from the DNS hostname.\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Name of the Firewall address list to which address must be dynamically added when some request matches the entry.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Alias name for a domain name.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "forwardTo": {
                    "type": "string",
                    "description": "The IP address of a domain name server to which a particular DNS request must be forwarded.\n"
                },
                "matchSubdomain": {
                    "type": "boolean",
                    "description": "Whether the record will match requests for subdomains.\n"
                },
                "mxExchange": {
                    "type": "string",
                    "description": "The domain name of the MX server.\n"
                },
                "mxPreference": {
                    "type": "integer",
                    "description": "Preference of the particular MX record.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the DNS hostname to be created.\n"
                },
                "ns": {
                    "type": "string",
                    "description": "Name of the authoritative domain name server for the particular record.\n"
                },
                "regexp": {
                    "type": "string",
                    "description": "DNS regexp. Regexp entries are case sensitive, but since DNS requests are not case sensitive, RouterOS converts DNS\nnames to lowercase, you should write regex only with lowercase letters.\n"
                },
                "srvPort": {
                    "type": "integer",
                    "description": "The TCP or UDP port on which the service is to be found.\n"
                },
                "srvPriority": {
                    "type": "integer",
                    "description": "Priority of the particular SRV record.\n"
                },
                "srvTarget": {
                    "type": "string",
                    "description": "The canonical hostname of the machine providing the service ends in a dot.\n"
                },
                "srvWeight": {
                    "type": "string",
                    "description": "Weight of the particular SRC record.\n"
                },
                "text": {
                    "type": "string",
                    "description": "Textual information about the domain name.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The ttl of the DNS record.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the DNS record. Available values are: A, AAAA, CNAME, FWD, MX, NS, NXDOMAIN, SRV, TXT\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering DnsRecord resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "The A record to be returend from the DNS hostname.\n"
                    },
                    "addressList": {
                        "type": "string",
                        "description": "Name of the Firewall address list to which address must be dynamically added when some request matches the entry.\n"
                    },
                    "cname": {
                        "type": "string",
                        "description": "Alias name for a domain name.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "forwardTo": {
                        "type": "string",
                        "description": "The IP address of a domain name server to which a particular DNS request must be forwarded.\n"
                    },
                    "matchSubdomain": {
                        "type": "boolean",
                        "description": "Whether the record will match requests for subdomains.\n"
                    },
                    "mxExchange": {
                        "type": "string",
                        "description": "The domain name of the MX server.\n"
                    },
                    "mxPreference": {
                        "type": "integer",
                        "description": "Preference of the particular MX record.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the DNS hostname to be created.\n"
                    },
                    "ns": {
                        "type": "string",
                        "description": "Name of the authoritative domain name server for the particular record.\n"
                    },
                    "regexp": {
                        "type": "string",
                        "description": "DNS regexp. Regexp entries are case sensitive, but since DNS requests are not case sensitive, RouterOS converts DNS\nnames to lowercase, you should write regex only with lowercase letters.\n"
                    },
                    "srvPort": {
                        "type": "integer",
                        "description": "The TCP or UDP port on which the service is to be found.\n"
                    },
                    "srvPriority": {
                        "type": "integer",
                        "description": "Priority of the particular SRV record.\n"
                    },
                    "srvTarget": {
                        "type": "string",
                        "description": "The canonical hostname of the machine providing the service ends in a dot.\n"
                    },
                    "srvWeight": {
                        "type": "string",
                        "description": "Weight of the particular SRC record.\n"
                    },
                    "text": {
                        "type": "string",
                        "description": "Textual information about the domain name.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "The ttl of the DNS record.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the DNS record. Available values are: A, AAAA, CNAME, FWD, MX, NS, NXDOMAIN, SRV, TXT\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/firewallAddrList:FirewallAddrList": {
            "description": "## # routeros.Ip.FirewallAddrList (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Ip.IpFirewallAddrList\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "A single IP address or range of IPs to add to address list or DNS name. You can input for example,\n'192.168.0.0-192.168.1.255' and it will auto modify the typed entry to 192.168.0.0/23 on saving.\n"
                },
                "comment": {
                    "type": "string"
                },
                "creationTime": {
                    "type": "string",
                    "description": "Rule creation time\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "list": {
                    "type": "string",
                    "description": "Name for the address list of the added IP address.\n"
                },
                "timeout": {
                    "type": "string",
                    "description": "Time after address will be removed from address list. If timeout is not specified, the address will be stored into the\naddress list permanently. \u003e Please plan your work logic based on the fact that after the timeout \u003e the resource has been\ndestroyed outside of Terraform.\n"
                }
            },
            "required": [
                "address",
                "creationTime",
                "dynamic",
                "list"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "A single IP address or range of IPs to add to address list or DNS name. You can input for example,\n'192.168.0.0-192.168.1.255' and it will auto modify the typed entry to 192.168.0.0/23 on saving.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "list": {
                    "type": "string",
                    "description": "Name for the address list of the added IP address.\n"
                },
                "timeout": {
                    "type": "string",
                    "description": "Time after address will be removed from address list. If timeout is not specified, the address will be stored into the\naddress list permanently. \u003e Please plan your work logic based on the fact that after the timeout \u003e the resource has been\ndestroyed outside of Terraform.\n"
                }
            },
            "requiredInputs": [
                "address",
                "list"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FirewallAddrList resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "A single IP address or range of IPs to add to address list or DNS name. You can input for example,\n'192.168.0.0-192.168.1.255' and it will auto modify the typed entry to 192.168.0.0/23 on saving.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "creationTime": {
                        "type": "string",
                        "description": "Rule creation time\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "list": {
                        "type": "string",
                        "description": "Name for the address list of the added IP address.\n"
                    },
                    "timeout": {
                        "type": "string",
                        "description": "Time after address will be removed from address list. If timeout is not specified, the address will be stored into the\naddress list permanently. \u003e Please plan your work logic based on the fact that after the timeout \u003e the resource has been\ndestroyed outside of Terraform.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/firewallFilter:FirewallFilter": {
            "description": "## # routeros.Ip.FirewallFilter (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Ip.IpFirewallFilter\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "bytes": {
                    "type": "integer",
                    "description": "The total amount of bytes matched by the rule.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionNatState": {
                    "type": "string",
                    "description": "Can match connections that are srcnatted, dstnatted or both.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionState": {
                    "type": "string",
                    "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "fragment": {
                    "type": "boolean",
                    "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                },
                "hotspot": {
                    "type": "string",
                    "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                },
                "hwOffload": {
                    "type": "boolean",
                    "description": "Connection offloading for Fasttrack.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "ipv4Options": {
                    "type": "string",
                    "description": "Matches IPv4 header options.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "layer7Protocol": {
                    "type": "string",
                    "description": "Layer7 filter name.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "packets": {
                    "type": "integer",
                    "description": "The total amount of packets matched by the rule.\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n"
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "psd": {
                    "type": "string",
                    "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "rejectWith": {
                    "type": "string",
                    "description": "Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "routingTable": {
                    "type": "string",
                    "description": "Matches packets which destination address is resolved in specific a routing table.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpFlags": {
                    "type": "string",
                    "description": "Matches specified TCP flags.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "tlsHost": {
                    "type": "string",
                    "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Matches packets TTL value.\n"
                }
            },
            "required": [
                "action",
                "bytes",
                "chain",
                "dynamic",
                "invalid",
                "packets"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionNatState": {
                    "type": "string",
                    "description": "Can match connections that are srcnatted, dstnatted or both.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionState": {
                    "type": "string",
                    "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "fragment": {
                    "type": "boolean",
                    "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                },
                "hotspot": {
                    "type": "string",
                    "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                },
                "hwOffload": {
                    "type": "boolean",
                    "description": "Connection offloading for Fasttrack.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "ipv4Options": {
                    "type": "string",
                    "description": "Matches IPv4 header options.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "layer7Protocol": {
                    "type": "string",
                    "description": "Layer7 filter name.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "psd": {
                    "type": "string",
                    "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "rejectWith": {
                    "type": "string",
                    "description": "Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "routingTable": {
                    "type": "string",
                    "description": "Matches packets which destination address is resolved in specific a routing table.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpFlags": {
                    "type": "string",
                    "description": "Matches specified TCP flags.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "tlsHost": {
                    "type": "string",
                    "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Matches packets TTL value.\n"
                }
            },
            "requiredInputs": [
                "action",
                "chain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FirewallFilter resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "action": {
                        "type": "string",
                        "description": "Action to take if a packet is matched by the rule\n"
                    },
                    "addressListTimeout": {
                        "type": "string",
                        "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                    },
                    "bytes": {
                        "type": "integer",
                        "description": "The total amount of bytes matched by the rule.\n"
                    },
                    "chain": {
                        "type": "string",
                        "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "connectionBytes": {
                        "type": "string",
                        "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                    },
                    "connectionLimit": {
                        "type": "string",
                        "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                    },
                    "connectionMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                    },
                    "connectionNatState": {
                        "type": "string",
                        "description": "Can match connections that are srcnatted, dstnatted or both.\n"
                    },
                    "connectionRate": {
                        "type": "string",
                        "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                    },
                    "connectionState": {
                        "type": "string",
                        "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                    },
                    "connectionType": {
                        "type": "string",
                        "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "Match packets that contain specified text.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dscp": {
                        "type": "integer",
                        "description": "Matches DSCP IP header field.\n"
                    },
                    "dstAddress": {
                        "type": "string",
                        "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                    },
                    "dstAddressList": {
                        "type": "string",
                        "description": "Matches destination address of a packet against user-defined address list.\n"
                    },
                    "dstAddressType": {
                        "type": "string",
                        "description": "Matches destination address type.\n"
                    },
                    "dstLimit": {
                        "type": "string",
                        "description": "Matches packets until a given rate is exceeded.\n"
                    },
                    "dstPort": {
                        "type": "string",
                        "description": "List of destination port numbers or port number ranges.\n"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "fragment": {
                        "type": "boolean",
                        "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                    },
                    "hotspot": {
                        "type": "string",
                        "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                    },
                    "hwOffload": {
                        "type": "boolean",
                        "description": "Connection offloading for Fasttrack.\n"
                    },
                    "icmpOptions": {
                        "type": "string",
                        "description": "Matches ICMP type: code fields.\n"
                    },
                    "inBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "inBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                    },
                    "inInterface": {
                        "type": "string",
                        "description": "Interface the packet has entered the router.\n"
                    },
                    "inInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                    },
                    "ingressPriority": {
                        "type": "integer",
                        "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "ipsecPolicy": {
                        "type": "string",
                        "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                    },
                    "ipv4Options": {
                        "type": "string",
                        "description": "Matches IPv4 header options.\n"
                    },
                    "jumpTarget": {
                        "type": "string",
                        "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                    },
                    "layer7Protocol": {
                        "type": "string",
                        "description": "Layer7 filter name.\n"
                    },
                    "limit": {
                        "type": "string",
                        "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                    },
                    "log": {
                        "type": "boolean",
                        "description": "Add a message to the system log.\n"
                    },
                    "logPrefix": {
                        "type": "string",
                        "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                    },
                    "nth": {
                        "type": "string",
                        "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                    },
                    "outBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "outBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                    },
                    "outInterface": {
                        "type": "string",
                        "description": "Interface the packet is leaving the router.\n"
                    },
                    "outInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                    },
                    "packetMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                    },
                    "packetSize": {
                        "type": "string",
                        "description": "Matches packets of specified size or size range in bytes.\n"
                    },
                    "packets": {
                        "type": "integer",
                        "description": "The total amount of packets matched by the rule.\n"
                    },
                    "perConnectionClassifier": {
                        "type": "string",
                        "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                    },
                    "placeBefore": {
                        "type": "string",
                        "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                        "willReplaceOnChanges": true
                    },
                    "port": {
                        "type": "string",
                        "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Matches particular IP protocol specified by protocol name or number.\n"
                    },
                    "psd": {
                        "type": "string",
                        "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                    },
                    "random": {
                        "type": "integer",
                        "description": "Matches packets randomly with a given probability.\n"
                    },
                    "rejectWith": {
                        "type": "string",
                        "description": "Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.\n"
                    },
                    "routingMark": {
                        "type": "string",
                        "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                    },
                    "routingTable": {
                        "type": "string",
                        "description": "Matches packets which destination address is resolved in specific a routing table.\n"
                    },
                    "srcAddress": {
                        "type": "string",
                        "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                    },
                    "srcAddressList": {
                        "type": "string",
                        "description": "Matches source address of a packet against user-defined address list.\n"
                    },
                    "srcAddressType": {
                        "type": "string",
                        "description": "Matches source address type.\n"
                    },
                    "srcMacAddress": {
                        "type": "string",
                        "description": "Matches source MAC address of the packet.\n"
                    },
                    "srcPort": {
                        "type": "string",
                        "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                    },
                    "tcpFlags": {
                        "type": "string",
                        "description": "Matches specified TCP flags.\n"
                    },
                    "tcpMss": {
                        "type": "string",
                        "description": "Matches TCP MSS value of an IP packet.\n"
                    },
                    "time": {
                        "type": "string",
                        "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                    },
                    "tlsHost": {
                        "type": "string",
                        "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Matches packets TTL value.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/firewallMangle:FirewallMangle": {
            "description": "## # routeros.Ip.FirewallMangle (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Ip.IpFirewallMangle\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule.\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "bytes": {
                    "type": "integer",
                    "description": "The total amount of bytes matched by the rule.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionNatState": {
                    "type": "string",
                    "description": "Can match connections that are srcnatted, dstnatted or both.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionState": {
                    "type": "string",
                    "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "fragment": {
                    "type": "boolean",
                    "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                },
                "hotspot": {
                    "type": "string",
                    "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "ipv4Options": {
                    "type": "string",
                    "description": "Matches IPv4 header options.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "layer7Protocol": {
                    "type": "string",
                    "description": "Layer7 filter name.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "newConnectionMark": {
                    "type": "string",
                    "description": "Sets a new connection-mark value.\n"
                },
                "newDscp": {
                    "type": "integer",
                    "description": "Sets a new DSCP value for a packet.\n"
                },
                "newMss": {
                    "type": "string",
                    "description": "Sets a new MSS for a packet. \u003e clamp-to-pmtu feature sets (DF) bit in the IP header to dynamically discover the PMTU of\na path. \u003e Host sends all datagrams on that path with the DF bit set until receives ICMP. \u003e Destination Unreachable\nmessages with a code meaning \"fragmentation needed and DF set\". \u003e Upon receipt of such a message, the source host\nreduces its assumed PMTU for the path.\n"
                },
                "newPacketMark": {
                    "type": "string",
                    "description": "Sets a new packet-mark value.\n"
                },
                "newPriority": {
                    "type": "string",
                    "description": "Sets a new priority for a packet. This can be the VLAN, WMM, DSCP or MPLS EXP priority. This property can also be used\nto set an internal priority.\n"
                },
                "newRoutingMark": {
                    "type": "string",
                    "description": "Sets a new routing-mark value.\n"
                },
                "newTtl": {
                    "type": "string",
                    "description": "Sets a new TTL for a packet.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "packets": {
                    "type": "integer",
                    "description": "The total amount of packets matched by the rule.\n"
                },
                "passthrough": {
                    "type": "boolean",
                    "description": "Whether to let the packet to pass further (like action passthrough) into the firewall or not (property only valid some\nactions).\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n"
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "psd": {
                    "type": "string",
                    "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "routeDst": {
                    "type": "string",
                    "description": "Matches packets with a specific gateway.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpFlags": {
                    "type": "string",
                    "description": "Matches specified TCP flags.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "tlsHost": {
                    "type": "string",
                    "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Matches packets TTL value.\n"
                }
            },
            "required": [
                "action",
                "bytes",
                "chain",
                "dynamic",
                "invalid",
                "packets",
                "passthrough"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule.\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionNatState": {
                    "type": "string",
                    "description": "Can match connections that are srcnatted, dstnatted or both.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionState": {
                    "type": "string",
                    "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "fragment": {
                    "type": "boolean",
                    "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                },
                "hotspot": {
                    "type": "string",
                    "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "ipv4Options": {
                    "type": "string",
                    "description": "Matches IPv4 header options.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "layer7Protocol": {
                    "type": "string",
                    "description": "Layer7 filter name.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "newConnectionMark": {
                    "type": "string",
                    "description": "Sets a new connection-mark value.\n"
                },
                "newDscp": {
                    "type": "integer",
                    "description": "Sets a new DSCP value for a packet.\n"
                },
                "newMss": {
                    "type": "string",
                    "description": "Sets a new MSS for a packet. \u003e clamp-to-pmtu feature sets (DF) bit in the IP header to dynamically discover the PMTU of\na path. \u003e Host sends all datagrams on that path with the DF bit set until receives ICMP. \u003e Destination Unreachable\nmessages with a code meaning \"fragmentation needed and DF set\". \u003e Upon receipt of such a message, the source host\nreduces its assumed PMTU for the path.\n"
                },
                "newPacketMark": {
                    "type": "string",
                    "description": "Sets a new packet-mark value.\n"
                },
                "newPriority": {
                    "type": "string",
                    "description": "Sets a new priority for a packet. This can be the VLAN, WMM, DSCP or MPLS EXP priority. This property can also be used\nto set an internal priority.\n"
                },
                "newRoutingMark": {
                    "type": "string",
                    "description": "Sets a new routing-mark value.\n"
                },
                "newTtl": {
                    "type": "string",
                    "description": "Sets a new TTL for a packet.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "passthrough": {
                    "type": "boolean",
                    "description": "Whether to let the packet to pass further (like action passthrough) into the firewall or not (property only valid some\nactions).\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "psd": {
                    "type": "string",
                    "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "routeDst": {
                    "type": "string",
                    "description": "Matches packets with a specific gateway.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpFlags": {
                    "type": "string",
                    "description": "Matches specified TCP flags.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "tlsHost": {
                    "type": "string",
                    "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Matches packets TTL value.\n"
                }
            },
            "requiredInputs": [
                "action",
                "chain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FirewallMangle resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "action": {
                        "type": "string",
                        "description": "Action to take if a packet is matched by the rule.\n"
                    },
                    "addressList": {
                        "type": "string",
                        "description": "Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.\n"
                    },
                    "addressListTimeout": {
                        "type": "string",
                        "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                    },
                    "bytes": {
                        "type": "integer",
                        "description": "The total amount of bytes matched by the rule.\n"
                    },
                    "chain": {
                        "type": "string",
                        "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "connectionBytes": {
                        "type": "string",
                        "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                    },
                    "connectionLimit": {
                        "type": "string",
                        "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                    },
                    "connectionMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                    },
                    "connectionNatState": {
                        "type": "string",
                        "description": "Can match connections that are srcnatted, dstnatted or both.\n"
                    },
                    "connectionRate": {
                        "type": "string",
                        "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                    },
                    "connectionState": {
                        "type": "string",
                        "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                    },
                    "connectionType": {
                        "type": "string",
                        "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "Match packets that contain specified text.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dscp": {
                        "type": "integer",
                        "description": "Matches DSCP IP header field.\n"
                    },
                    "dstAddress": {
                        "type": "string",
                        "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                    },
                    "dstAddressList": {
                        "type": "string",
                        "description": "Matches destination address of a packet against user-defined address list.\n"
                    },
                    "dstAddressType": {
                        "type": "string",
                        "description": "Matches destination address type.\n"
                    },
                    "dstLimit": {
                        "type": "string",
                        "description": "Matches packets until a given rate is exceeded.\n"
                    },
                    "dstPort": {
                        "type": "string",
                        "description": "List of destination port numbers or port number ranges.\n"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "fragment": {
                        "type": "boolean",
                        "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                    },
                    "hotspot": {
                        "type": "string",
                        "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                    },
                    "icmpOptions": {
                        "type": "string",
                        "description": "Matches ICMP type: code fields.\n"
                    },
                    "inBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "inBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                    },
                    "inInterface": {
                        "type": "string",
                        "description": "Interface the packet has entered the router.\n"
                    },
                    "inInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                    },
                    "ingressPriority": {
                        "type": "integer",
                        "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "ipsecPolicy": {
                        "type": "string",
                        "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                    },
                    "ipv4Options": {
                        "type": "string",
                        "description": "Matches IPv4 header options.\n"
                    },
                    "jumpTarget": {
                        "type": "string",
                        "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                    },
                    "layer7Protocol": {
                        "type": "string",
                        "description": "Layer7 filter name.\n"
                    },
                    "limit": {
                        "type": "string",
                        "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                    },
                    "log": {
                        "type": "boolean",
                        "description": "Add a message to the system log.\n"
                    },
                    "logPrefix": {
                        "type": "string",
                        "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                    },
                    "newConnectionMark": {
                        "type": "string",
                        "description": "Sets a new connection-mark value.\n"
                    },
                    "newDscp": {
                        "type": "integer",
                        "description": "Sets a new DSCP value for a packet.\n"
                    },
                    "newMss": {
                        "type": "string",
                        "description": "Sets a new MSS for a packet. \u003e clamp-to-pmtu feature sets (DF) bit in the IP header to dynamically discover the PMTU of\na path. \u003e Host sends all datagrams on that path with the DF bit set until receives ICMP. \u003e Destination Unreachable\nmessages with a code meaning \"fragmentation needed and DF set\". \u003e Upon receipt of such a message, the source host\nreduces its assumed PMTU for the path.\n"
                    },
                    "newPacketMark": {
                        "type": "string",
                        "description": "Sets a new packet-mark value.\n"
                    },
                    "newPriority": {
                        "type": "string",
                        "description": "Sets a new priority for a packet. This can be the VLAN, WMM, DSCP or MPLS EXP priority. This property can also be used\nto set an internal priority.\n"
                    },
                    "newRoutingMark": {
                        "type": "string",
                        "description": "Sets a new routing-mark value.\n"
                    },
                    "newTtl": {
                        "type": "string",
                        "description": "Sets a new TTL for a packet.\n"
                    },
                    "nth": {
                        "type": "string",
                        "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                    },
                    "outBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "outBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                    },
                    "outInterface": {
                        "type": "string",
                        "description": "Interface the packet is leaving the router.\n"
                    },
                    "outInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                    },
                    "packetMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                    },
                    "packetSize": {
                        "type": "string",
                        "description": "Matches packets of specified size or size range in bytes.\n"
                    },
                    "packets": {
                        "type": "integer",
                        "description": "The total amount of packets matched by the rule.\n"
                    },
                    "passthrough": {
                        "type": "boolean",
                        "description": "Whether to let the packet to pass further (like action passthrough) into the firewall or not (property only valid some\nactions).\n"
                    },
                    "perConnectionClassifier": {
                        "type": "string",
                        "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                    },
                    "placeBefore": {
                        "type": "string",
                        "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                        "willReplaceOnChanges": true
                    },
                    "port": {
                        "type": "string",
                        "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Matches particular IP protocol specified by protocol name or number.\n"
                    },
                    "psd": {
                        "type": "string",
                        "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                    },
                    "random": {
                        "type": "integer",
                        "description": "Matches packets randomly with a given probability.\n"
                    },
                    "routeDst": {
                        "type": "string",
                        "description": "Matches packets with a specific gateway.\n"
                    },
                    "routingMark": {
                        "type": "string",
                        "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                    },
                    "srcAddress": {
                        "type": "string",
                        "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                    },
                    "srcAddressList": {
                        "type": "string",
                        "description": "Matches source address of a packet against user-defined address list.\n"
                    },
                    "srcAddressType": {
                        "type": "string",
                        "description": "Matches source address type.\n"
                    },
                    "srcMacAddress": {
                        "type": "string",
                        "description": "Matches source MAC address of the packet.\n"
                    },
                    "srcPort": {
                        "type": "string",
                        "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                    },
                    "tcpFlags": {
                        "type": "string",
                        "description": "Matches specified TCP flags.\n"
                    },
                    "tcpMss": {
                        "type": "string",
                        "description": "Matches TCP MSS value of an IP packet.\n"
                    },
                    "time": {
                        "type": "string",
                        "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                    },
                    "tlsHost": {
                        "type": "string",
                        "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Matches packets TTL value.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/firewallNat:FirewallNat": {
            "description": "## # routeros.Ip.FirewallNat (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.Ip.IpFirewallNat\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "bytes": {
                    "type": "integer",
                    "description": "The total amount of bytes matched by the rule.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "fragment": {
                    "type": "boolean",
                    "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                },
                "hotspot": {
                    "type": "string",
                    "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "ipv4Options": {
                    "type": "string",
                    "description": "Matches IPv4 header options.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "layer7Protocol": {
                    "type": "string",
                    "description": "Layer7 filter name.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "packets": {
                    "type": "integer",
                    "description": "The total amount of packets matched by the rule.\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n"
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "psd": {
                    "type": "string",
                    "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "sameNotByDst": {
                    "type": "boolean",
                    "description": "Specifies whether to take into account or not destination IP address when selecting a new source IP address. Applicable\nif action=same\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "toAddresses": {
                    "type": "string",
                    "description": "Replace original address with specified one. Applicable if action is dst-nat, netmap, same, src-nat.\n"
                },
                "toPorts": {
                    "type": "string",
                    "description": "Replace the original port with the specified one. Applicable if action is dst-nat, redirect, masquerade, netmap, same,\nsrc-nat.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Matches packets TTL value.\n"
                }
            },
            "required": [
                "action",
                "bytes",
                "chain",
                "dynamic",
                "invalid",
                "packets"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "fragment": {
                    "type": "boolean",
                    "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                },
                "hotspot": {
                    "type": "string",
                    "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "ipv4Options": {
                    "type": "string",
                    "description": "Matches IPv4 header options.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "layer7Protocol": {
                    "type": "string",
                    "description": "Layer7 filter name.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "psd": {
                    "type": "string",
                    "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "sameNotByDst": {
                    "type": "boolean",
                    "description": "Specifies whether to take into account or not destination IP address when selecting a new source IP address. Applicable\nif action=same\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "toAddresses": {
                    "type": "string",
                    "description": "Replace original address with specified one. Applicable if action is dst-nat, netmap, same, src-nat.\n"
                },
                "toPorts": {
                    "type": "string",
                    "description": "Replace the original port with the specified one. Applicable if action is dst-nat, redirect, masquerade, netmap, same,\nsrc-nat.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Matches packets TTL value.\n"
                }
            },
            "requiredInputs": [
                "action",
                "chain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FirewallNat resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "action": {
                        "type": "string",
                        "description": "Action to take if a packet is matched by the rule\n"
                    },
                    "addressList": {
                        "type": "string",
                        "description": "Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.\n"
                    },
                    "addressListTimeout": {
                        "type": "string",
                        "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                    },
                    "bytes": {
                        "type": "integer",
                        "description": "The total amount of bytes matched by the rule.\n"
                    },
                    "chain": {
                        "type": "string",
                        "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "connectionBytes": {
                        "type": "string",
                        "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                    },
                    "connectionLimit": {
                        "type": "string",
                        "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                    },
                    "connectionMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                    },
                    "connectionRate": {
                        "type": "string",
                        "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                    },
                    "connectionType": {
                        "type": "string",
                        "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "Match packets that contain specified text.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dscp": {
                        "type": "integer",
                        "description": "Matches DSCP IP header field.\n"
                    },
                    "dstAddress": {
                        "type": "string",
                        "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                    },
                    "dstAddressList": {
                        "type": "string",
                        "description": "Matches destination address of a packet against user-defined address list.\n"
                    },
                    "dstAddressType": {
                        "type": "string",
                        "description": "Matches destination address type.\n"
                    },
                    "dstLimit": {
                        "type": "string",
                        "description": "Matches packets until a given rate is exceeded.\n"
                    },
                    "dstPort": {
                        "type": "string",
                        "description": "List of destination port numbers or port number ranges.\n"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "fragment": {
                        "type": "boolean",
                        "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                    },
                    "hotspot": {
                        "type": "string",
                        "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                    },
                    "icmpOptions": {
                        "type": "string",
                        "description": "Matches ICMP type: code fields.\n"
                    },
                    "inBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "inBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                    },
                    "inInterface": {
                        "type": "string",
                        "description": "Interface the packet has entered the router.\n"
                    },
                    "inInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                    },
                    "ingressPriority": {
                        "type": "integer",
                        "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "ipsecPolicy": {
                        "type": "string",
                        "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                    },
                    "ipv4Options": {
                        "type": "string",
                        "description": "Matches IPv4 header options.\n"
                    },
                    "jumpTarget": {
                        "type": "string",
                        "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                    },
                    "layer7Protocol": {
                        "type": "string",
                        "description": "Layer7 filter name.\n"
                    },
                    "limit": {
                        "type": "string",
                        "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                    },
                    "log": {
                        "type": "boolean",
                        "description": "Add a message to the system log.\n"
                    },
                    "logPrefix": {
                        "type": "string",
                        "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                    },
                    "nth": {
                        "type": "string",
                        "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                    },
                    "outBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "outBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                    },
                    "outInterface": {
                        "type": "string",
                        "description": "Interface the packet is leaving the router.\n"
                    },
                    "outInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                    },
                    "packetMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                    },
                    "packetSize": {
                        "type": "string",
                        "description": "Matches packets of specified size or size range in bytes.\n"
                    },
                    "packets": {
                        "type": "integer",
                        "description": "The total amount of packets matched by the rule.\n"
                    },
                    "perConnectionClassifier": {
                        "type": "string",
                        "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                    },
                    "placeBefore": {
                        "type": "string",
                        "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                        "willReplaceOnChanges": true
                    },
                    "port": {
                        "type": "string",
                        "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Matches particular IP protocol specified by protocol name or number.\n"
                    },
                    "psd": {
                        "type": "string",
                        "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                    },
                    "random": {
                        "type": "integer",
                        "description": "Matches packets randomly with a given probability.\n"
                    },
                    "routingMark": {
                        "type": "string",
                        "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                    },
                    "sameNotByDst": {
                        "type": "boolean",
                        "description": "Specifies whether to take into account or not destination IP address when selecting a new source IP address. Applicable\nif action=same\n"
                    },
                    "srcAddress": {
                        "type": "string",
                        "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                    },
                    "srcAddressList": {
                        "type": "string",
                        "description": "Matches source address of a packet against user-defined address list.\n"
                    },
                    "srcAddressType": {
                        "type": "string",
                        "description": "Matches source address type.\n"
                    },
                    "srcMacAddress": {
                        "type": "string",
                        "description": "Matches source MAC address of the packet.\n"
                    },
                    "srcPort": {
                        "type": "string",
                        "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                    },
                    "tcpMss": {
                        "type": "string",
                        "description": "Matches TCP MSS value of an IP packet.\n"
                    },
                    "time": {
                        "type": "string",
                        "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                    },
                    "toAddresses": {
                        "type": "string",
                        "description": "Replace original address with specified one. Applicable if action is dst-nat, netmap, same, src-nat.\n"
                    },
                    "toPorts": {
                        "type": "string",
                        "description": "Replace the original port with the specified one. Applicable if action is dst-nat, redirect, masquerade, netmap, same,\nsrc-nat.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Matches packets TTL value.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/ipDns:IpDns": {
            "description": "## # routeros.Ip.IpDns (Resource)\n\nA MikroTik router with DNS feature enabled can be set as a DNS server for any DNS-compliant client.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst dns_server = new routeros.ip.Dns(\"dns-server\", {\n    allowRemoteRequests: true,\n    servers: \"2606:4700:4700::1111,1.1.1.1,2606:4700:4700::1001,1.0.0.1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ndns_server = routeros.ip.Dns(\"dns-server\",\n    allow_remote_requests=True,\n    servers=\"2606:4700:4700::1111,1.1.1.1,2606:4700:4700::1001,1.0.0.1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var dns_server = new Routeros.Ip.Dns(\"dns-server\", new()\n    {\n        AllowRemoteRequests = true,\n        Servers = \"2606:4700:4700::1111,1.1.1.1,2606:4700:4700::1001,1.0.0.1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ip.NewDns(ctx, \"dns-server\", \u0026Ip.DnsArgs{\n\t\t\tAllowRemoteRequests: pulumi.Bool(true),\n\t\t\tServers:             pulumi.String(\"2606:4700:4700::1111,1.1.1.1,2606:4700:4700::1001,1.0.0.1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.Dns;\nimport com.pulumi.routeros.Ip.DnsArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var dns_server = new Dns(\"dns-server\", DnsArgs.builder()        \n            .allowRemoteRequests(true)\n            .servers(\"2606:4700:4700::1111,1.1.1.1,2606:4700:4700::1001,1.0.0.1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  dns-server:\n    type: routeros:Ip:Dns\n    properties:\n      allowRemoteRequests: true\n      servers: 2606:4700:4700::1111,1.1.1.1,2606:4700:4700::1001,1.0.0.1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The DNS Settings can not be imported.\n\n#Terraform will ignore the current settings and will overwrite the current settings with the settings defined in Terraform. ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "allowRemoteRequests": {
                    "type": "boolean",
                    "description": "Specifies whether to allow network requests.\n"
                },
                "cacheMaxTtl": {
                    "type": "string",
                    "description": "Maximum time-to-live for cache records. In other words, cache records will expire unconditionally after cache-max-ttl\ntime. Shorter TTL received from DNS servers are respected. *Default: 1w*\n"
                },
                "cacheSize": {
                    "type": "integer",
                    "description": "Specifies the size of DNS cache in KiB (64..4294967295). *Default: 2048*\n"
                },
                "cacheUsed": {
                    "type": "integer",
                    "description": "Shows the currently used cache size in KiB.\n"
                },
                "dohMaxConcurrentQueries": {
                    "type": "integer",
                    "description": "Specifies how many DoH concurrent queries are allowed.\n"
                },
                "dohMaxServerConnections": {
                    "type": "integer",
                    "description": "Specifies how many concurrent connections to the DoH server are allowed.\n"
                },
                "dohTimeout": {
                    "type": "string",
                    "description": "Specifies how long to wait for query response from the DoH server.\n"
                },
                "dynamicServers": {
                    "type": "string",
                    "description": "List of dynamically added DNS server from different services, for example, DHCP.\n"
                },
                "maxConcurrentQueries": {
                    "type": "integer",
                    "description": "Specifies how much concurrent queries are allowed. *Default: 100*\n"
                },
                "maxConcurrentTcpSessions": {
                    "type": "integer",
                    "description": "Specifies how much concurrent TCP sessions are allowed. *Default: 20*\n"
                },
                "maxUdpPacketSize": {
                    "type": "integer",
                    "description": "Maximum size of allowed UDP packet. *Default: 4096*\n"
                },
                "queryServerTimeout": {
                    "type": "string",
                    "description": "Specifies how long to wait for query response from one server. Time can be specified in milliseconds. *Default: 2s*\n"
                },
                "queryTotalTimeout": {
                    "type": "string",
                    "description": "Specifies how long to wait for query response in total. Note that this setting must be configured taking into account\nquery_server_timeout and number of used DNS server. Time can be specified in milliseconds. *Default: 10s*\n"
                },
                "servers": {
                    "type": "string",
                    "description": "List of DNS server IPv4/IPv6 addresses.\n"
                },
                "useDohServer": {
                    "type": "string",
                    "description": "DNS over HTTPS (DoH) server URL. \u003e Mikrotik strongly suggest not use third-party download links for certificate\nfetching. Use the Certificate Authority's own website. \u003e RouterOS prioritize DoH over DNS server if both are configured\non the device.\n"
                },
                "verifyDohCert": {
                    "type": "boolean",
                    "description": "DoH certificate verification. [See docs](https://wiki.mikrotik.com/wiki/Manual:IP/DNS#DNS_over_HTTPS).\n"
                }
            },
            "required": [
                "cacheMaxTtl",
                "cacheSize",
                "cacheUsed",
                "dohMaxConcurrentQueries",
                "dohMaxServerConnections",
                "dohTimeout",
                "dynamicServers",
                "maxConcurrentQueries",
                "maxConcurrentTcpSessions",
                "maxUdpPacketSize",
                "queryServerTimeout",
                "queryTotalTimeout"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "allowRemoteRequests": {
                    "type": "boolean",
                    "description": "Specifies whether to allow network requests.\n"
                },
                "cacheMaxTtl": {
                    "type": "string",
                    "description": "Maximum time-to-live for cache records. In other words, cache records will expire unconditionally after cache-max-ttl\ntime. Shorter TTL received from DNS servers are respected. *Default: 1w*\n"
                },
                "cacheSize": {
                    "type": "integer",
                    "description": "Specifies the size of DNS cache in KiB (64..4294967295). *Default: 2048*\n"
                },
                "dohMaxConcurrentQueries": {
                    "type": "integer",
                    "description": "Specifies how many DoH concurrent queries are allowed.\n"
                },
                "dohMaxServerConnections": {
                    "type": "integer",
                    "description": "Specifies how many concurrent connections to the DoH server are allowed.\n"
                },
                "dohTimeout": {
                    "type": "string",
                    "description": "Specifies how long to wait for query response from the DoH server.\n"
                },
                "maxConcurrentQueries": {
                    "type": "integer",
                    "description": "Specifies how much concurrent queries are allowed. *Default: 100*\n"
                },
                "maxConcurrentTcpSessions": {
                    "type": "integer",
                    "description": "Specifies how much concurrent TCP sessions are allowed. *Default: 20*\n"
                },
                "maxUdpPacketSize": {
                    "type": "integer",
                    "description": "Maximum size of allowed UDP packet. *Default: 4096*\n"
                },
                "queryServerTimeout": {
                    "type": "string",
                    "description": "Specifies how long to wait for query response from one server. Time can be specified in milliseconds. *Default: 2s*\n"
                },
                "queryTotalTimeout": {
                    "type": "string",
                    "description": "Specifies how long to wait for query response in total. Note that this setting must be configured taking into account\nquery_server_timeout and number of used DNS server. Time can be specified in milliseconds. *Default: 10s*\n"
                },
                "servers": {
                    "type": "string",
                    "description": "List of DNS server IPv4/IPv6 addresses.\n"
                },
                "useDohServer": {
                    "type": "string",
                    "description": "DNS over HTTPS (DoH) server URL. \u003e Mikrotik strongly suggest not use third-party download links for certificate\nfetching. Use the Certificate Authority's own website. \u003e RouterOS prioritize DoH over DNS server if both are configured\non the device.\n"
                },
                "verifyDohCert": {
                    "type": "boolean",
                    "description": "DoH certificate verification. [See docs](https://wiki.mikrotik.com/wiki/Manual:IP/DNS#DNS_over_HTTPS).\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpDns resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "allowRemoteRequests": {
                        "type": "boolean",
                        "description": "Specifies whether to allow network requests.\n"
                    },
                    "cacheMaxTtl": {
                        "type": "string",
                        "description": "Maximum time-to-live for cache records. In other words, cache records will expire unconditionally after cache-max-ttl\ntime. Shorter TTL received from DNS servers are respected. *Default: 1w*\n"
                    },
                    "cacheSize": {
                        "type": "integer",
                        "description": "Specifies the size of DNS cache in KiB (64..4294967295). *Default: 2048*\n"
                    },
                    "cacheUsed": {
                        "type": "integer",
                        "description": "Shows the currently used cache size in KiB.\n"
                    },
                    "dohMaxConcurrentQueries": {
                        "type": "integer",
                        "description": "Specifies how many DoH concurrent queries are allowed.\n"
                    },
                    "dohMaxServerConnections": {
                        "type": "integer",
                        "description": "Specifies how many concurrent connections to the DoH server are allowed.\n"
                    },
                    "dohTimeout": {
                        "type": "string",
                        "description": "Specifies how long to wait for query response from the DoH server.\n"
                    },
                    "dynamicServers": {
                        "type": "string",
                        "description": "List of dynamically added DNS server from different services, for example, DHCP.\n"
                    },
                    "maxConcurrentQueries": {
                        "type": "integer",
                        "description": "Specifies how much concurrent queries are allowed. *Default: 100*\n"
                    },
                    "maxConcurrentTcpSessions": {
                        "type": "integer",
                        "description": "Specifies how much concurrent TCP sessions are allowed. *Default: 20*\n"
                    },
                    "maxUdpPacketSize": {
                        "type": "integer",
                        "description": "Maximum size of allowed UDP packet. *Default: 4096*\n"
                    },
                    "queryServerTimeout": {
                        "type": "string",
                        "description": "Specifies how long to wait for query response from one server. Time can be specified in milliseconds. *Default: 2s*\n"
                    },
                    "queryTotalTimeout": {
                        "type": "string",
                        "description": "Specifies how long to wait for query response in total. Note that this setting must be configured taking into account\nquery_server_timeout and number of used DNS server. Time can be specified in milliseconds. *Default: 10s*\n"
                    },
                    "servers": {
                        "type": "string",
                        "description": "List of DNS server IPv4/IPv6 addresses.\n"
                    },
                    "useDohServer": {
                        "type": "string",
                        "description": "DNS over HTTPS (DoH) server URL. \u003e Mikrotik strongly suggest not use third-party download links for certificate\nfetching. Use the Certificate Authority's own website. \u003e RouterOS prioritize DoH over DNS server if both are configured\non the device.\n"
                    },
                    "verifyDohCert": {
                        "type": "boolean",
                        "description": "DoH certificate verification. [See docs](https://wiki.mikrotik.com/wiki/Manual:IP/DNS#DNS_over_HTTPS).\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/ipDnsRecord:IpDnsRecord": {
            "description": "## # routeros.Ip.IpDnsRecord (Resource)\n\nCreates a DNS record on the MikroTik device.\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst nameRecord = new routeros.ip.IpDnsRecord(\"nameRecord\", {\n    address: \"192.168.88.1\",\n    type: \"A\",\n});\nconst regexpRecord = new routeros.ip.IpDnsRecord(\"regexpRecord\", {\n    address: \"192.168.88.1\",\n    regexp: \".*pool.ntp.org\",\n    type: \"A\",\n});\nconst aaaaRecord = new routeros.ip.DnsRecord(\"aaaaRecord\", {\n    address: \"ff00::1\",\n    type: \"AAAA\",\n});\nconst cnameRecord = new routeros.ip.DnsRecord(\"cnameRecord\", {\n    cname: \"ipv4.lan\",\n    type: \"CNAME\",\n});\nconst fwdRecord = new routeros.ip.DnsRecord(\"fwdRecord\", {\n    forwardTo: \"127.0.0.1\",\n    type: \"FWD\",\n});\nconst mxRecord = new routeros.ip.DnsRecord(\"mxRecord\", {\n    mxExchange: \"127.0.0.1\",\n    mxPreference: 10,\n    type: \"MX\",\n});\nconst nsRecord = new routeros.ip.DnsRecord(\"nsRecord\", {\n    ns: \"127.0.0.1\",\n    type: \"NS\",\n});\nconst nxdomainRecord = new routeros.ip.DnsRecord(\"nxdomainRecord\", {type: \"NXDOMAIN\"});\nconst srvRecord = new routeros.ip.DnsRecord(\"srvRecord\", {\n    srvPort: 8080,\n    srvPriority: 10,\n    srvTarget: \"127.0.0.1\",\n    srvWeight: \"100\",\n    type: \"SRV\",\n});\nconst txtRecord = new routeros.ip.DnsRecord(\"txtRecord\", {\n    text: \"dW6MrI3nBy3eJgYWH3QAg1Cwk_TvjFESOuKo+mp6nm1\",\n    type: \"TXT\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nname_record = routeros.ip.IpDnsRecord(\"nameRecord\",\n    address=\"192.168.88.1\",\n    type=\"A\")\nregexp_record = routeros.ip.IpDnsRecord(\"regexpRecord\",\n    address=\"192.168.88.1\",\n    regexp=\".*pool.ntp.org\",\n    type=\"A\")\naaaa_record = routeros.ip.DnsRecord(\"aaaaRecord\",\n    address=\"ff00::1\",\n    type=\"AAAA\")\ncname_record = routeros.ip.DnsRecord(\"cnameRecord\",\n    cname=\"ipv4.lan\",\n    type=\"CNAME\")\nfwd_record = routeros.ip.DnsRecord(\"fwdRecord\",\n    forward_to=\"127.0.0.1\",\n    type=\"FWD\")\nmx_record = routeros.ip.DnsRecord(\"mxRecord\",\n    mx_exchange=\"127.0.0.1\",\n    mx_preference=10,\n    type=\"MX\")\nns_record = routeros.ip.DnsRecord(\"nsRecord\",\n    ns=\"127.0.0.1\",\n    type=\"NS\")\nnxdomain_record = routeros.ip.DnsRecord(\"nxdomainRecord\", type=\"NXDOMAIN\")\nsrv_record = routeros.ip.DnsRecord(\"srvRecord\",\n    srv_port=8080,\n    srv_priority=10,\n    srv_target=\"127.0.0.1\",\n    srv_weight=\"100\",\n    type=\"SRV\")\ntxt_record = routeros.ip.DnsRecord(\"txtRecord\",\n    text=\"dW6MrI3nBy3eJgYWH3QAg1Cwk_TvjFESOuKo+mp6nm1\",\n    type=\"TXT\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var nameRecord = new Routeros.Ip.IpDnsRecord(\"nameRecord\", new()\n    {\n        Address = \"192.168.88.1\",\n        Type = \"A\",\n    });\n\n    var regexpRecord = new Routeros.Ip.IpDnsRecord(\"regexpRecord\", new()\n    {\n        Address = \"192.168.88.1\",\n        Regexp = \".*pool.ntp.org\",\n        Type = \"A\",\n    });\n\n    var aaaaRecord = new Routeros.Ip.DnsRecord(\"aaaaRecord\", new()\n    {\n        Address = \"ff00::1\",\n        Type = \"AAAA\",\n    });\n\n    var cnameRecord = new Routeros.Ip.DnsRecord(\"cnameRecord\", new()\n    {\n        Cname = \"ipv4.lan\",\n        Type = \"CNAME\",\n    });\n\n    var fwdRecord = new Routeros.Ip.DnsRecord(\"fwdRecord\", new()\n    {\n        ForwardTo = \"127.0.0.1\",\n        Type = \"FWD\",\n    });\n\n    var mxRecord = new Routeros.Ip.DnsRecord(\"mxRecord\", new()\n    {\n        MxExchange = \"127.0.0.1\",\n        MxPreference = 10,\n        Type = \"MX\",\n    });\n\n    var nsRecord = new Routeros.Ip.DnsRecord(\"nsRecord\", new()\n    {\n        Ns = \"127.0.0.1\",\n        Type = \"NS\",\n    });\n\n    var nxdomainRecord = new Routeros.Ip.DnsRecord(\"nxdomainRecord\", new()\n    {\n        Type = \"NXDOMAIN\",\n    });\n\n    var srvRecord = new Routeros.Ip.DnsRecord(\"srvRecord\", new()\n    {\n        SrvPort = 8080,\n        SrvPriority = 10,\n        SrvTarget = \"127.0.0.1\",\n        SrvWeight = \"100\",\n        Type = \"SRV\",\n    });\n\n    var txtRecord = new Routeros.Ip.DnsRecord(\"txtRecord\", new()\n    {\n        Text = \"dW6MrI3nBy3eJgYWH3QAg1Cwk_TvjFESOuKo+mp6nm1\",\n        Type = \"TXT\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ip.NewIpDnsRecord(ctx, \"nameRecord\", \u0026Ip.IpDnsRecordArgs{\n\t\t\tAddress: pulumi.String(\"192.168.88.1\"),\n\t\t\tType:    pulumi.String(\"A\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = Ip.NewIpDnsRecord(ctx, \"regexpRecord\", \u0026Ip.IpDnsRecordArgs{\n\t\t\tAddress: pulumi.String(\"192.168.88.1\"),\n\t\t\tRegexp:  pulumi.String(\".*pool.ntp.org\"),\n\t\t\tType:    pulumi.String(\"A\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = Ip.NewDnsRecord(ctx, \"aaaaRecord\", \u0026Ip.DnsRecordArgs{\n\t\t\tAddress: pulumi.String(\"ff00::1\"),\n\t\t\tType:    pulumi.String(\"AAAA\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = Ip.NewDnsRecord(ctx, \"cnameRecord\", \u0026Ip.DnsRecordArgs{\n\t\t\tCname: pulumi.String(\"ipv4.lan\"),\n\t\t\tType:  pulumi.String(\"CNAME\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = Ip.NewDnsRecord(ctx, \"fwdRecord\", \u0026Ip.DnsRecordArgs{\n\t\t\tForwardTo: pulumi.String(\"127.0.0.1\"),\n\t\t\tType:      pulumi.String(\"FWD\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = Ip.NewDnsRecord(ctx, \"mxRecord\", \u0026Ip.DnsRecordArgs{\n\t\t\tMxExchange:   pulumi.String(\"127.0.0.1\"),\n\t\t\tMxPreference: pulumi.Int(10),\n\t\t\tType:         pulumi.String(\"MX\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = Ip.NewDnsRecord(ctx, \"nsRecord\", \u0026Ip.DnsRecordArgs{\n\t\t\tNs:   pulumi.String(\"127.0.0.1\"),\n\t\t\tType: pulumi.String(\"NS\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = Ip.NewDnsRecord(ctx, \"nxdomainRecord\", \u0026Ip.DnsRecordArgs{\n\t\t\tType: pulumi.String(\"NXDOMAIN\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = Ip.NewDnsRecord(ctx, \"srvRecord\", \u0026Ip.DnsRecordArgs{\n\t\t\tSrvPort:     pulumi.Int(8080),\n\t\t\tSrvPriority: pulumi.Int(10),\n\t\t\tSrvTarget:   pulumi.String(\"127.0.0.1\"),\n\t\t\tSrvWeight:   pulumi.String(\"100\"),\n\t\t\tType:        pulumi.String(\"SRV\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = Ip.NewDnsRecord(ctx, \"txtRecord\", \u0026Ip.DnsRecordArgs{\n\t\t\tText: pulumi.String(\"dW6MrI3nBy3eJgYWH3QAg1Cwk_TvjFESOuKo+mp6nm1\"),\n\t\t\tType: pulumi.String(\"TXT\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.IpDnsRecord;\nimport com.pulumi.routeros.Ip.IpDnsRecordArgs;\nimport com.pulumi.routeros.Ip.DnsRecord;\nimport com.pulumi.routeros.Ip.DnsRecordArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var nameRecord = new IpDnsRecord(\"nameRecord\", IpDnsRecordArgs.builder()        \n            .address(\"192.168.88.1\")\n            .type(\"A\")\n            .build());\n\n        var regexpRecord = new IpDnsRecord(\"regexpRecord\", IpDnsRecordArgs.builder()        \n            .address(\"192.168.88.1\")\n            .regexp(\".*pool.ntp.org\")\n            .type(\"A\")\n            .build());\n\n        var aaaaRecord = new DnsRecord(\"aaaaRecord\", DnsRecordArgs.builder()        \n            .address(\"ff00::1\")\n            .type(\"AAAA\")\n            .build());\n\n        var cnameRecord = new DnsRecord(\"cnameRecord\", DnsRecordArgs.builder()        \n            .cname(\"ipv4.lan\")\n            .type(\"CNAME\")\n            .build());\n\n        var fwdRecord = new DnsRecord(\"fwdRecord\", DnsRecordArgs.builder()        \n            .forwardTo(\"127.0.0.1\")\n            .type(\"FWD\")\n            .build());\n\n        var mxRecord = new DnsRecord(\"mxRecord\", DnsRecordArgs.builder()        \n            .mxExchange(\"127.0.0.1\")\n            .mxPreference(10)\n            .type(\"MX\")\n            .build());\n\n        var nsRecord = new DnsRecord(\"nsRecord\", DnsRecordArgs.builder()        \n            .ns(\"127.0.0.1\")\n            .type(\"NS\")\n            .build());\n\n        var nxdomainRecord = new DnsRecord(\"nxdomainRecord\", DnsRecordArgs.builder()        \n            .type(\"NXDOMAIN\")\n            .build());\n\n        var srvRecord = new DnsRecord(\"srvRecord\", DnsRecordArgs.builder()        \n            .srvPort(8080)\n            .srvPriority(10)\n            .srvTarget(\"127.0.0.1\")\n            .srvWeight(100)\n            .type(\"SRV\")\n            .build());\n\n        var txtRecord = new DnsRecord(\"txtRecord\", DnsRecordArgs.builder()        \n            .text(\"dW6MrI3nBy3eJgYWH3QAg1Cwk_TvjFESOuKo+mp6nm1\")\n            .type(\"TXT\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  nameRecord:\n    type: routeros:Ip:IpDnsRecord\n    properties:\n      address: 192.168.88.1\n      type: A\n  regexpRecord:\n    type: routeros:Ip:IpDnsRecord\n    properties:\n      address: 192.168.88.1\n      regexp: .*pool.ntp.org\n      type: A\n  aaaaRecord:\n    type: routeros:Ip:DnsRecord\n    properties:\n      address: ff00::1\n      type: AAAA\n  cnameRecord:\n    type: routeros:Ip:DnsRecord\n    properties:\n      cname: ipv4.lan\n      type: CNAME\n  fwdRecord:\n    type: routeros:Ip:DnsRecord\n    properties:\n      forwardTo: 127.0.0.1\n      type: FWD\n  mxRecord:\n    type: routeros:Ip:DnsRecord\n    properties:\n      mxExchange: 127.0.0.1\n      mxPreference: 10\n      type: MX\n  nsRecord:\n    type: routeros:Ip:DnsRecord\n    properties:\n      ns: 127.0.0.1\n      type: NS\n  nxdomainRecord:\n    type: routeros:Ip:DnsRecord\n    properties:\n      type: NXDOMAIN\n  srvRecord:\n    type: routeros:Ip:DnsRecord\n    properties:\n      srvPort: 8080\n      srvPriority: 10\n      srvTarget: 127.0.0.1\n      srvWeight: 100\n      type: SRV\n  txtRecord:\n    type: routeros:Ip:DnsRecord\n    properties:\n      text: dW6MrI3nBy3eJgYWH3QAg1Cwk_TvjFESOuKo+mp6nm1\n      type: TXT\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ip/dns/static get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ip/ipDnsRecord:IpDnsRecord name_record \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "The A record to be returend from the DNS hostname.\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Name of the Firewall address list to which address must be dynamically added when some request matches the entry.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Alias name for a domain name.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                },
                "forwardTo": {
                    "type": "string",
                    "description": "The IP address of a domain name server to which a particular DNS request must be forwarded.\n"
                },
                "matchSubdomain": {
                    "type": "boolean",
                    "description": "Whether the record will match requests for subdomains.\n"
                },
                "mxExchange": {
                    "type": "string",
                    "description": "The domain name of the MX server.\n"
                },
                "mxPreference": {
                    "type": "integer",
                    "description": "Preference of the particular MX record.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the DNS hostname to be created.\n"
                },
                "ns": {
                    "type": "string",
                    "description": "Name of the authoritative domain name server for the particular record.\n"
                },
                "regexp": {
                    "type": "string",
                    "description": "DNS regexp. Regexp entries are case sensitive, but since DNS requests are not case sensitive, RouterOS converts DNS names to lowercase, you should write regex only with lowercase letters.\n"
                },
                "srvPort": {
                    "type": "integer",
                    "description": "The TCP or UDP port on which the service is to be found.\n"
                },
                "srvPriority": {
                    "type": "integer",
                    "description": "Priority of the particular SRV record.\n"
                },
                "srvTarget": {
                    "type": "string",
                    "description": "The canonical hostname of the machine providing the service ends in a dot.\n"
                },
                "srvWeight": {
                    "type": "string",
                    "description": "Weight of the particular SRC record.\n"
                },
                "text": {
                    "type": "string",
                    "description": "Textual information about the domain name.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The ttl of the DNS record.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the DNS record. Available values are: A, AAAA, CNAME, FWD, MX, NS, NXDOMAIN, SRV, TXT\n"
                }
            },
            "required": [
                "dynamic",
                "mxPreference",
                "name",
                "srvPort",
                "srvPriority",
                "srvWeight",
                "ttl",
                "type"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "The A record to be returend from the DNS hostname.\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Name of the Firewall address list to which address must be dynamically added when some request matches the entry.\n"
                },
                "cname": {
                    "type": "string",
                    "description": "Alias name for a domain name.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "forwardTo": {
                    "type": "string",
                    "description": "The IP address of a domain name server to which a particular DNS request must be forwarded.\n"
                },
                "matchSubdomain": {
                    "type": "boolean",
                    "description": "Whether the record will match requests for subdomains.\n"
                },
                "mxExchange": {
                    "type": "string",
                    "description": "The domain name of the MX server.\n"
                },
                "mxPreference": {
                    "type": "integer",
                    "description": "Preference of the particular MX record.\n"
                },
                "name": {
                    "type": "string",
                    "description": "The name of the DNS hostname to be created.\n"
                },
                "ns": {
                    "type": "string",
                    "description": "Name of the authoritative domain name server for the particular record.\n"
                },
                "regexp": {
                    "type": "string",
                    "description": "DNS regexp. Regexp entries are case sensitive, but since DNS requests are not case sensitive, RouterOS converts DNS names to lowercase, you should write regex only with lowercase letters.\n"
                },
                "srvPort": {
                    "type": "integer",
                    "description": "The TCP or UDP port on which the service is to be found.\n"
                },
                "srvPriority": {
                    "type": "integer",
                    "description": "Priority of the particular SRV record.\n"
                },
                "srvTarget": {
                    "type": "string",
                    "description": "The canonical hostname of the machine providing the service ends in a dot.\n"
                },
                "srvWeight": {
                    "type": "string",
                    "description": "Weight of the particular SRC record.\n"
                },
                "text": {
                    "type": "string",
                    "description": "Textual information about the domain name.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "The ttl of the DNS record.\n"
                },
                "type": {
                    "type": "string",
                    "description": "Type of the DNS record. Available values are: A, AAAA, CNAME, FWD, MX, NS, NXDOMAIN, SRV, TXT\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "type"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpDnsRecord resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "The A record to be returend from the DNS hostname.\n"
                    },
                    "addressList": {
                        "type": "string",
                        "description": "Name of the Firewall address list to which address must be dynamically added when some request matches the entry.\n"
                    },
                    "cname": {
                        "type": "string",
                        "description": "Alias name for a domain name.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                    },
                    "forwardTo": {
                        "type": "string",
                        "description": "The IP address of a domain name server to which a particular DNS request must be forwarded.\n"
                    },
                    "matchSubdomain": {
                        "type": "boolean",
                        "description": "Whether the record will match requests for subdomains.\n"
                    },
                    "mxExchange": {
                        "type": "string",
                        "description": "The domain name of the MX server.\n"
                    },
                    "mxPreference": {
                        "type": "integer",
                        "description": "Preference of the particular MX record.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "The name of the DNS hostname to be created.\n"
                    },
                    "ns": {
                        "type": "string",
                        "description": "Name of the authoritative domain name server for the particular record.\n"
                    },
                    "regexp": {
                        "type": "string",
                        "description": "DNS regexp. Regexp entries are case sensitive, but since DNS requests are not case sensitive, RouterOS converts DNS names to lowercase, you should write regex only with lowercase letters.\n"
                    },
                    "srvPort": {
                        "type": "integer",
                        "description": "The TCP or UDP port on which the service is to be found.\n"
                    },
                    "srvPriority": {
                        "type": "integer",
                        "description": "Priority of the particular SRV record.\n"
                    },
                    "srvTarget": {
                        "type": "string",
                        "description": "The canonical hostname of the machine providing the service ends in a dot.\n"
                    },
                    "srvWeight": {
                        "type": "string",
                        "description": "Weight of the particular SRC record.\n"
                    },
                    "text": {
                        "type": "string",
                        "description": "Textual information about the domain name.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "The ttl of the DNS record.\n"
                    },
                    "type": {
                        "type": "string",
                        "description": "Type of the DNS record. Available values are: A, AAAA, CNAME, FWD, MX, NS, NXDOMAIN, SRV, TXT\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/ipFirewallAddrList:IpFirewallAddrList": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst exampleList = new routeros.ip.IpFirewallAddrList(\"exampleList\", {\n    address: \"1.1.1.1\",\n    list: \"Example List\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nexample_list = routeros.ip.IpFirewallAddrList(\"exampleList\",\n    address=\"1.1.1.1\",\n    list=\"Example List\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var exampleList = new Routeros.Ip.IpFirewallAddrList(\"exampleList\", new()\n    {\n        Address = \"1.1.1.1\",\n        List = \"Example List\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ip.NewIpFirewallAddrList(ctx, \"exampleList\", \u0026Ip.IpFirewallAddrListArgs{\n\t\t\tAddress: pulumi.String(\"1.1.1.1\"),\n\t\t\tList:    pulumi.String(\"Example List\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.IpFirewallAddrList;\nimport com.pulumi.routeros.Ip.IpFirewallAddrListArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var exampleList = new IpFirewallAddrList(\"exampleList\", IpFirewallAddrListArgs.builder()        \n            .address(\"1.1.1.1\")\n            .list(\"Example List\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  exampleList:\n    type: routeros:Ip:IpFirewallAddrList\n    properties:\n      address: 1.1.1.1\n      list: Example List\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ip/firewall/address-list get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ip/ipFirewallAddrList:IpFirewallAddrList example_list \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "A single IP address or range of IPs to add to address list or DNS name. You can input for example,\n'192.168.0.0-192.168.1.255' and it will auto modify the typed entry to 192.168.0.0/23 on saving.\n"
                },
                "comment": {
                    "type": "string"
                },
                "creationTime": {
                    "type": "string",
                    "description": "Rule creation time\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "list": {
                    "type": "string",
                    "description": "Name for the address list of the added IP address.\n"
                },
                "timeout": {
                    "type": "string",
                    "description": "Time after address will be removed from address list. If timeout is not specified, the address will be stored into the\naddress list permanently. \u003e Please plan your work logic based on the fact that after the timeout \u003e the resource has been\ndestroyed outside of Terraform.\n"
                }
            },
            "required": [
                "address",
                "creationTime",
                "dynamic",
                "list"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "A single IP address or range of IPs to add to address list or DNS name. You can input for example,\n'192.168.0.0-192.168.1.255' and it will auto modify the typed entry to 192.168.0.0/23 on saving.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "list": {
                    "type": "string",
                    "description": "Name for the address list of the added IP address.\n"
                },
                "timeout": {
                    "type": "string",
                    "description": "Time after address will be removed from address list. If timeout is not specified, the address will be stored into the\naddress list permanently. \u003e Please plan your work logic based on the fact that after the timeout \u003e the resource has been\ndestroyed outside of Terraform.\n"
                }
            },
            "requiredInputs": [
                "address",
                "list"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpFirewallAddrList resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "A single IP address or range of IPs to add to address list or DNS name. You can input for example,\n'192.168.0.0-192.168.1.255' and it will auto modify the typed entry to 192.168.0.0/23 on saving.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "creationTime": {
                        "type": "string",
                        "description": "Rule creation time\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "list": {
                        "type": "string",
                        "description": "Name for the address list of the added IP address.\n"
                    },
                    "timeout": {
                        "type": "string",
                        "description": "Time after address will be removed from address list. If timeout is not specified, the address will be stored into the\naddress list permanently. \u003e Please plan your work logic based on the fact that after the timeout \u003e the resource has been\ndestroyed outside of Terraform.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/ipFirewallFilter:IpFirewallFilter": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst rule = new routeros.ip.IpFirewallFilter(\"rule\", {\n    action: \"accept\",\n    chain: \"forward\",\n    dstAddress: \"10.0.1.1\",\n    dstPort: \"443\",\n    protocol: \"tcp\",\n    srcAddress: \"10.0.0.1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nrule = routeros.ip.IpFirewallFilter(\"rule\",\n    action=\"accept\",\n    chain=\"forward\",\n    dst_address=\"10.0.1.1\",\n    dst_port=\"443\",\n    protocol=\"tcp\",\n    src_address=\"10.0.0.1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var rule = new Routeros.Ip.IpFirewallFilter(\"rule\", new()\n    {\n        Action = \"accept\",\n        Chain = \"forward\",\n        DstAddress = \"10.0.1.1\",\n        DstPort = \"443\",\n        Protocol = \"tcp\",\n        SrcAddress = \"10.0.0.1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ip.NewIpFirewallFilter(ctx, \"rule\", \u0026Ip.IpFirewallFilterArgs{\n\t\t\tAction:     pulumi.String(\"accept\"),\n\t\t\tChain:      pulumi.String(\"forward\"),\n\t\t\tDstAddress: pulumi.String(\"10.0.1.1\"),\n\t\t\tDstPort:    pulumi.String(\"443\"),\n\t\t\tProtocol:   pulumi.String(\"tcp\"),\n\t\t\tSrcAddress: pulumi.String(\"10.0.0.1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.IpFirewallFilter;\nimport com.pulumi.routeros.Ip.IpFirewallFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var rule = new IpFirewallFilter(\"rule\", IpFirewallFilterArgs.builder()        \n            .action(\"accept\")\n            .chain(\"forward\")\n            .dstAddress(\"10.0.1.1\")\n            .dstPort(\"443\")\n            .protocol(\"tcp\")\n            .srcAddress(\"10.0.0.1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  rule:\n    type: routeros:Ip:IpFirewallFilter\n    properties:\n      action: accept\n      chain: forward\n      dstAddress: 10.0.1.1\n      dstPort: '443'\n      protocol: tcp\n      srcAddress: 10.0.0.1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ip/firewall/filter get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ip/ipFirewallFilter:IpFirewallFilter rule \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "bytes": {
                    "type": "integer",
                    "description": "The total amount of bytes matched by the rule.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionNatState": {
                    "type": "string",
                    "description": "Can match connections that are srcnatted, dstnatted or both.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionState": {
                    "type": "string",
                    "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "fragment": {
                    "type": "boolean",
                    "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                },
                "hotspot": {
                    "type": "string",
                    "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                },
                "hwOffload": {
                    "type": "boolean",
                    "description": "Connection offloading for Fasttrack.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "ipv4Options": {
                    "type": "string",
                    "description": "Matches IPv4 header options.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "layer7Protocol": {
                    "type": "string",
                    "description": "Layer7 filter name.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "packets": {
                    "type": "integer",
                    "description": "The total amount of packets matched by the rule.\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n"
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "psd": {
                    "type": "string",
                    "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "rejectWith": {
                    "type": "string",
                    "description": "Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "routingTable": {
                    "type": "string",
                    "description": "Matches packets which destination address is resolved in specific a routing table.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpFlags": {
                    "type": "string",
                    "description": "Matches specified TCP flags.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "tlsHost": {
                    "type": "string",
                    "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Matches packets TTL value.\n"
                }
            },
            "required": [
                "action",
                "bytes",
                "chain",
                "dynamic",
                "invalid",
                "packets"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionNatState": {
                    "type": "string",
                    "description": "Can match connections that are srcnatted, dstnatted or both.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionState": {
                    "type": "string",
                    "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "fragment": {
                    "type": "boolean",
                    "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                },
                "hotspot": {
                    "type": "string",
                    "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                },
                "hwOffload": {
                    "type": "boolean",
                    "description": "Connection offloading for Fasttrack.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "ipv4Options": {
                    "type": "string",
                    "description": "Matches IPv4 header options.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "layer7Protocol": {
                    "type": "string",
                    "description": "Layer7 filter name.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "psd": {
                    "type": "string",
                    "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "rejectWith": {
                    "type": "string",
                    "description": "Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "routingTable": {
                    "type": "string",
                    "description": "Matches packets which destination address is resolved in specific a routing table.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpFlags": {
                    "type": "string",
                    "description": "Matches specified TCP flags.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "tlsHost": {
                    "type": "string",
                    "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Matches packets TTL value.\n"
                }
            },
            "requiredInputs": [
                "action",
                "chain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpFirewallFilter resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "action": {
                        "type": "string",
                        "description": "Action to take if a packet is matched by the rule\n"
                    },
                    "addressListTimeout": {
                        "type": "string",
                        "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                    },
                    "bytes": {
                        "type": "integer",
                        "description": "The total amount of bytes matched by the rule.\n"
                    },
                    "chain": {
                        "type": "string",
                        "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "connectionBytes": {
                        "type": "string",
                        "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                    },
                    "connectionLimit": {
                        "type": "string",
                        "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                    },
                    "connectionMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                    },
                    "connectionNatState": {
                        "type": "string",
                        "description": "Can match connections that are srcnatted, dstnatted or both.\n"
                    },
                    "connectionRate": {
                        "type": "string",
                        "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                    },
                    "connectionState": {
                        "type": "string",
                        "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                    },
                    "connectionType": {
                        "type": "string",
                        "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "Match packets that contain specified text.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dscp": {
                        "type": "integer",
                        "description": "Matches DSCP IP header field.\n"
                    },
                    "dstAddress": {
                        "type": "string",
                        "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                    },
                    "dstAddressList": {
                        "type": "string",
                        "description": "Matches destination address of a packet against user-defined address list.\n"
                    },
                    "dstAddressType": {
                        "type": "string",
                        "description": "Matches destination address type.\n"
                    },
                    "dstLimit": {
                        "type": "string",
                        "description": "Matches packets until a given rate is exceeded.\n"
                    },
                    "dstPort": {
                        "type": "string",
                        "description": "List of destination port numbers or port number ranges.\n"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "fragment": {
                        "type": "boolean",
                        "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                    },
                    "hotspot": {
                        "type": "string",
                        "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                    },
                    "hwOffload": {
                        "type": "boolean",
                        "description": "Connection offloading for Fasttrack.\n"
                    },
                    "icmpOptions": {
                        "type": "string",
                        "description": "Matches ICMP type: code fields.\n"
                    },
                    "inBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "inBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                    },
                    "inInterface": {
                        "type": "string",
                        "description": "Interface the packet has entered the router.\n"
                    },
                    "inInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                    },
                    "ingressPriority": {
                        "type": "integer",
                        "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "ipsecPolicy": {
                        "type": "string",
                        "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                    },
                    "ipv4Options": {
                        "type": "string",
                        "description": "Matches IPv4 header options.\n"
                    },
                    "jumpTarget": {
                        "type": "string",
                        "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                    },
                    "layer7Protocol": {
                        "type": "string",
                        "description": "Layer7 filter name.\n"
                    },
                    "limit": {
                        "type": "string",
                        "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                    },
                    "log": {
                        "type": "boolean",
                        "description": "Add a message to the system log.\n"
                    },
                    "logPrefix": {
                        "type": "string",
                        "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                    },
                    "nth": {
                        "type": "string",
                        "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                    },
                    "outBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "outBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                    },
                    "outInterface": {
                        "type": "string",
                        "description": "Interface the packet is leaving the router.\n"
                    },
                    "outInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                    },
                    "packetMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                    },
                    "packetSize": {
                        "type": "string",
                        "description": "Matches packets of specified size or size range in bytes.\n"
                    },
                    "packets": {
                        "type": "integer",
                        "description": "The total amount of packets matched by the rule.\n"
                    },
                    "perConnectionClassifier": {
                        "type": "string",
                        "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                    },
                    "placeBefore": {
                        "type": "string",
                        "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                        "willReplaceOnChanges": true
                    },
                    "port": {
                        "type": "string",
                        "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Matches particular IP protocol specified by protocol name or number.\n"
                    },
                    "psd": {
                        "type": "string",
                        "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                    },
                    "random": {
                        "type": "integer",
                        "description": "Matches packets randomly with a given probability.\n"
                    },
                    "rejectWith": {
                        "type": "string",
                        "description": "Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.\n"
                    },
                    "routingMark": {
                        "type": "string",
                        "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                    },
                    "routingTable": {
                        "type": "string",
                        "description": "Matches packets which destination address is resolved in specific a routing table.\n"
                    },
                    "srcAddress": {
                        "type": "string",
                        "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                    },
                    "srcAddressList": {
                        "type": "string",
                        "description": "Matches source address of a packet against user-defined address list.\n"
                    },
                    "srcAddressType": {
                        "type": "string",
                        "description": "Matches source address type.\n"
                    },
                    "srcMacAddress": {
                        "type": "string",
                        "description": "Matches source MAC address of the packet.\n"
                    },
                    "srcPort": {
                        "type": "string",
                        "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                    },
                    "tcpFlags": {
                        "type": "string",
                        "description": "Matches specified TCP flags.\n"
                    },
                    "tcpMss": {
                        "type": "string",
                        "description": "Matches TCP MSS value of an IP packet.\n"
                    },
                    "time": {
                        "type": "string",
                        "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                    },
                    "tlsHost": {
                        "type": "string",
                        "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Matches packets TTL value.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/ipFirewallMangle:IpFirewallMangle": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.IpFirewallMangle;\nimport com.pulumi.routeros.Ip.IpFirewallMangleArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var rule = new IpFirewallMangle(\"rule\", IpFirewallMangleArgs.builder()        \n            .action(\"change-mss\")\n            .chain(\"forward\")\n            .new_mss(\"1130\")\n            .out_interface(\"pppoe-out\")\n            .protocol(\"tcp\")\n            .tcp_flags(\"syn\")\n            .tcp_mss(\"1301-65535\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  rule:\n    type: routeros:Ip:IpFirewallMangle\n    properties:\n      action: change-mss\n      chain: forward\n      new-mss: '1130'\n      out-interface: pppoe-out\n      protocol: tcp\n      tcp-flags: syn\n      tcp-mss: 1301-65535\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ip/firewall/mangle get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ip/ipFirewallMangle:IpFirewallMangle rule \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule.\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "bytes": {
                    "type": "integer",
                    "description": "The total amount of bytes matched by the rule.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionNatState": {
                    "type": "string",
                    "description": "Can match connections that are srcnatted, dstnatted or both.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionState": {
                    "type": "string",
                    "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "fragment": {
                    "type": "boolean",
                    "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                },
                "hotspot": {
                    "type": "string",
                    "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "ipv4Options": {
                    "type": "string",
                    "description": "Matches IPv4 header options.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "layer7Protocol": {
                    "type": "string",
                    "description": "Layer7 filter name.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "newConnectionMark": {
                    "type": "string",
                    "description": "Sets a new connection-mark value.\n"
                },
                "newDscp": {
                    "type": "integer",
                    "description": "Sets a new DSCP value for a packet.\n"
                },
                "newMss": {
                    "type": "string",
                    "description": "Sets a new MSS for a packet. \u003e clamp-to-pmtu feature sets (DF) bit in the IP header to dynamically discover the PMTU of\na path. \u003e Host sends all datagrams on that path with the DF bit set until receives ICMP. \u003e Destination Unreachable\nmessages with a code meaning \"fragmentation needed and DF set\". \u003e Upon receipt of such a message, the source host\nreduces its assumed PMTU for the path.\n"
                },
                "newPacketMark": {
                    "type": "string",
                    "description": "Sets a new packet-mark value.\n"
                },
                "newPriority": {
                    "type": "string",
                    "description": "Sets a new priority for a packet. This can be the VLAN, WMM, DSCP or MPLS EXP priority. This property can also be used\nto set an internal priority.\n"
                },
                "newRoutingMark": {
                    "type": "string",
                    "description": "Sets a new routing-mark value.\n"
                },
                "newTtl": {
                    "type": "string",
                    "description": "Sets a new TTL for a packet.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "packets": {
                    "type": "integer",
                    "description": "The total amount of packets matched by the rule.\n"
                },
                "passthrough": {
                    "type": "boolean",
                    "description": "Whether to let the packet to pass further (like action passthrough) into the firewall or not (property only valid some\nactions).\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n"
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "psd": {
                    "type": "string",
                    "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "routeDst": {
                    "type": "string",
                    "description": "Matches packets with a specific gateway.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpFlags": {
                    "type": "string",
                    "description": "Matches specified TCP flags.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "tlsHost": {
                    "type": "string",
                    "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Matches packets TTL value.\n"
                }
            },
            "required": [
                "action",
                "bytes",
                "chain",
                "dynamic",
                "invalid",
                "packets",
                "passthrough"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule.\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionNatState": {
                    "type": "string",
                    "description": "Can match connections that are srcnatted, dstnatted or both.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionState": {
                    "type": "string",
                    "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "fragment": {
                    "type": "boolean",
                    "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                },
                "hotspot": {
                    "type": "string",
                    "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "ipv4Options": {
                    "type": "string",
                    "description": "Matches IPv4 header options.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "layer7Protocol": {
                    "type": "string",
                    "description": "Layer7 filter name.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "newConnectionMark": {
                    "type": "string",
                    "description": "Sets a new connection-mark value.\n"
                },
                "newDscp": {
                    "type": "integer",
                    "description": "Sets a new DSCP value for a packet.\n"
                },
                "newMss": {
                    "type": "string",
                    "description": "Sets a new MSS for a packet. \u003e clamp-to-pmtu feature sets (DF) bit in the IP header to dynamically discover the PMTU of\na path. \u003e Host sends all datagrams on that path with the DF bit set until receives ICMP. \u003e Destination Unreachable\nmessages with a code meaning \"fragmentation needed and DF set\". \u003e Upon receipt of such a message, the source host\nreduces its assumed PMTU for the path.\n"
                },
                "newPacketMark": {
                    "type": "string",
                    "description": "Sets a new packet-mark value.\n"
                },
                "newPriority": {
                    "type": "string",
                    "description": "Sets a new priority for a packet. This can be the VLAN, WMM, DSCP or MPLS EXP priority. This property can also be used\nto set an internal priority.\n"
                },
                "newRoutingMark": {
                    "type": "string",
                    "description": "Sets a new routing-mark value.\n"
                },
                "newTtl": {
                    "type": "string",
                    "description": "Sets a new TTL for a packet.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "passthrough": {
                    "type": "boolean",
                    "description": "Whether to let the packet to pass further (like action passthrough) into the firewall or not (property only valid some\nactions).\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "psd": {
                    "type": "string",
                    "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "routeDst": {
                    "type": "string",
                    "description": "Matches packets with a specific gateway.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpFlags": {
                    "type": "string",
                    "description": "Matches specified TCP flags.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "tlsHost": {
                    "type": "string",
                    "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Matches packets TTL value.\n"
                }
            },
            "requiredInputs": [
                "action",
                "chain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpFirewallMangle resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "action": {
                        "type": "string",
                        "description": "Action to take if a packet is matched by the rule.\n"
                    },
                    "addressList": {
                        "type": "string",
                        "description": "Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.\n"
                    },
                    "addressListTimeout": {
                        "type": "string",
                        "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                    },
                    "bytes": {
                        "type": "integer",
                        "description": "The total amount of bytes matched by the rule.\n"
                    },
                    "chain": {
                        "type": "string",
                        "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "connectionBytes": {
                        "type": "string",
                        "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                    },
                    "connectionLimit": {
                        "type": "string",
                        "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                    },
                    "connectionMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                    },
                    "connectionNatState": {
                        "type": "string",
                        "description": "Can match connections that are srcnatted, dstnatted or both.\n"
                    },
                    "connectionRate": {
                        "type": "string",
                        "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                    },
                    "connectionState": {
                        "type": "string",
                        "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                    },
                    "connectionType": {
                        "type": "string",
                        "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "Match packets that contain specified text.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dscp": {
                        "type": "integer",
                        "description": "Matches DSCP IP header field.\n"
                    },
                    "dstAddress": {
                        "type": "string",
                        "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                    },
                    "dstAddressList": {
                        "type": "string",
                        "description": "Matches destination address of a packet against user-defined address list.\n"
                    },
                    "dstAddressType": {
                        "type": "string",
                        "description": "Matches destination address type.\n"
                    },
                    "dstLimit": {
                        "type": "string",
                        "description": "Matches packets until a given rate is exceeded.\n"
                    },
                    "dstPort": {
                        "type": "string",
                        "description": "List of destination port numbers or port number ranges.\n"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "fragment": {
                        "type": "boolean",
                        "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                    },
                    "hotspot": {
                        "type": "string",
                        "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                    },
                    "icmpOptions": {
                        "type": "string",
                        "description": "Matches ICMP type: code fields.\n"
                    },
                    "inBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "inBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                    },
                    "inInterface": {
                        "type": "string",
                        "description": "Interface the packet has entered the router.\n"
                    },
                    "inInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                    },
                    "ingressPriority": {
                        "type": "integer",
                        "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "ipsecPolicy": {
                        "type": "string",
                        "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                    },
                    "ipv4Options": {
                        "type": "string",
                        "description": "Matches IPv4 header options.\n"
                    },
                    "jumpTarget": {
                        "type": "string",
                        "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                    },
                    "layer7Protocol": {
                        "type": "string",
                        "description": "Layer7 filter name.\n"
                    },
                    "limit": {
                        "type": "string",
                        "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                    },
                    "log": {
                        "type": "boolean",
                        "description": "Add a message to the system log.\n"
                    },
                    "logPrefix": {
                        "type": "string",
                        "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                    },
                    "newConnectionMark": {
                        "type": "string",
                        "description": "Sets a new connection-mark value.\n"
                    },
                    "newDscp": {
                        "type": "integer",
                        "description": "Sets a new DSCP value for a packet.\n"
                    },
                    "newMss": {
                        "type": "string",
                        "description": "Sets a new MSS for a packet. \u003e clamp-to-pmtu feature sets (DF) bit in the IP header to dynamically discover the PMTU of\na path. \u003e Host sends all datagrams on that path with the DF bit set until receives ICMP. \u003e Destination Unreachable\nmessages with a code meaning \"fragmentation needed and DF set\". \u003e Upon receipt of such a message, the source host\nreduces its assumed PMTU for the path.\n"
                    },
                    "newPacketMark": {
                        "type": "string",
                        "description": "Sets a new packet-mark value.\n"
                    },
                    "newPriority": {
                        "type": "string",
                        "description": "Sets a new priority for a packet. This can be the VLAN, WMM, DSCP or MPLS EXP priority. This property can also be used\nto set an internal priority.\n"
                    },
                    "newRoutingMark": {
                        "type": "string",
                        "description": "Sets a new routing-mark value.\n"
                    },
                    "newTtl": {
                        "type": "string",
                        "description": "Sets a new TTL for a packet.\n"
                    },
                    "nth": {
                        "type": "string",
                        "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                    },
                    "outBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "outBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                    },
                    "outInterface": {
                        "type": "string",
                        "description": "Interface the packet is leaving the router.\n"
                    },
                    "outInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                    },
                    "packetMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                    },
                    "packetSize": {
                        "type": "string",
                        "description": "Matches packets of specified size or size range in bytes.\n"
                    },
                    "packets": {
                        "type": "integer",
                        "description": "The total amount of packets matched by the rule.\n"
                    },
                    "passthrough": {
                        "type": "boolean",
                        "description": "Whether to let the packet to pass further (like action passthrough) into the firewall or not (property only valid some\nactions).\n"
                    },
                    "perConnectionClassifier": {
                        "type": "string",
                        "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                    },
                    "placeBefore": {
                        "type": "string",
                        "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                        "willReplaceOnChanges": true
                    },
                    "port": {
                        "type": "string",
                        "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Matches particular IP protocol specified by protocol name or number.\n"
                    },
                    "psd": {
                        "type": "string",
                        "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                    },
                    "random": {
                        "type": "integer",
                        "description": "Matches packets randomly with a given probability.\n"
                    },
                    "routeDst": {
                        "type": "string",
                        "description": "Matches packets with a specific gateway.\n"
                    },
                    "routingMark": {
                        "type": "string",
                        "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                    },
                    "srcAddress": {
                        "type": "string",
                        "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                    },
                    "srcAddressList": {
                        "type": "string",
                        "description": "Matches source address of a packet against user-defined address list.\n"
                    },
                    "srcAddressType": {
                        "type": "string",
                        "description": "Matches source address type.\n"
                    },
                    "srcMacAddress": {
                        "type": "string",
                        "description": "Matches source MAC address of the packet.\n"
                    },
                    "srcPort": {
                        "type": "string",
                        "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                    },
                    "tcpFlags": {
                        "type": "string",
                        "description": "Matches specified TCP flags.\n"
                    },
                    "tcpMss": {
                        "type": "string",
                        "description": "Matches TCP MSS value of an IP packet.\n"
                    },
                    "time": {
                        "type": "string",
                        "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                    },
                    "tlsHost": {
                        "type": "string",
                        "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Matches packets TTL value.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/ipFirewallNat:IpFirewallNat": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst rule = new routeros.ip.IpFirewallNat(\"rule\", {\n    action: \"masquerade\",\n    chain: \"srcnat\",\n    outInterface: \"ether16\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nrule = routeros.ip.IpFirewallNat(\"rule\",\n    action=\"masquerade\",\n    chain=\"srcnat\",\n    out_interface=\"ether16\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var rule = new Routeros.Ip.IpFirewallNat(\"rule\", new()\n    {\n        Action = \"masquerade\",\n        Chain = \"srcnat\",\n        OutInterface = \"ether16\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ip.NewIpFirewallNat(ctx, \"rule\", \u0026Ip.IpFirewallNatArgs{\n\t\t\tAction:       pulumi.String(\"masquerade\"),\n\t\t\tChain:        pulumi.String(\"srcnat\"),\n\t\t\tOutInterface: pulumi.String(\"ether16\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.IpFirewallNat;\nimport com.pulumi.routeros.Ip.IpFirewallNatArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var rule = new IpFirewallNat(\"rule\", IpFirewallNatArgs.builder()        \n            .action(\"masquerade\")\n            .chain(\"srcnat\")\n            .outInterface(\"ether16\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  rule:\n    type: routeros:Ip:IpFirewallNat\n    properties:\n      action: masquerade\n      chain: srcnat\n      outInterface: ether16\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ip/firewall/nat get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ip/ipFirewallNat:IpFirewallNat rule \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "bytes": {
                    "type": "integer",
                    "description": "The total amount of bytes matched by the rule.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "fragment": {
                    "type": "boolean",
                    "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                },
                "hotspot": {
                    "type": "string",
                    "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "ipv4Options": {
                    "type": "string",
                    "description": "Matches IPv4 header options.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "layer7Protocol": {
                    "type": "string",
                    "description": "Layer7 filter name.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "packets": {
                    "type": "integer",
                    "description": "The total amount of packets matched by the rule.\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n"
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "psd": {
                    "type": "string",
                    "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "sameNotByDst": {
                    "type": "boolean",
                    "description": "Specifies whether to take into account or not destination IP address when selecting a new source IP address. Applicable\nif action=same\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "toAddresses": {
                    "type": "string",
                    "description": "Replace original address with specified one. Applicable if action is dst-nat, netmap, same, src-nat.\n"
                },
                "toPorts": {
                    "type": "string",
                    "description": "Replace the original port with the specified one. Applicable if action is dst-nat, redirect, masquerade, netmap, same,\nsrc-nat.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Matches packets TTL value.\n"
                }
            },
            "required": [
                "action",
                "bytes",
                "chain",
                "dynamic",
                "invalid",
                "packets"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "fragment": {
                    "type": "boolean",
                    "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                },
                "hotspot": {
                    "type": "string",
                    "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "ipv4Options": {
                    "type": "string",
                    "description": "Matches IPv4 header options.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "layer7Protocol": {
                    "type": "string",
                    "description": "Layer7 filter name.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "psd": {
                    "type": "string",
                    "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "sameNotByDst": {
                    "type": "boolean",
                    "description": "Specifies whether to take into account or not destination IP address when selecting a new source IP address. Applicable\nif action=same\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "toAddresses": {
                    "type": "string",
                    "description": "Replace original address with specified one. Applicable if action is dst-nat, netmap, same, src-nat.\n"
                },
                "toPorts": {
                    "type": "string",
                    "description": "Replace the original port with the specified one. Applicable if action is dst-nat, redirect, masquerade, netmap, same,\nsrc-nat.\n"
                },
                "ttl": {
                    "type": "string",
                    "description": "Matches packets TTL value.\n"
                }
            },
            "requiredInputs": [
                "action",
                "chain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering IpFirewallNat resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "action": {
                        "type": "string",
                        "description": "Action to take if a packet is matched by the rule\n"
                    },
                    "addressList": {
                        "type": "string",
                        "description": "Name of the address list to be used. Applicable if action is add-dst-to-address-list or add-src-to-address-list.\n"
                    },
                    "addressListTimeout": {
                        "type": "string",
                        "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                    },
                    "bytes": {
                        "type": "integer",
                        "description": "The total amount of bytes matched by the rule.\n"
                    },
                    "chain": {
                        "type": "string",
                        "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "connectionBytes": {
                        "type": "string",
                        "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                    },
                    "connectionLimit": {
                        "type": "string",
                        "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                    },
                    "connectionMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                    },
                    "connectionRate": {
                        "type": "string",
                        "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                    },
                    "connectionType": {
                        "type": "string",
                        "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "Match packets that contain specified text.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dscp": {
                        "type": "integer",
                        "description": "Matches DSCP IP header field.\n"
                    },
                    "dstAddress": {
                        "type": "string",
                        "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                    },
                    "dstAddressList": {
                        "type": "string",
                        "description": "Matches destination address of a packet against user-defined address list.\n"
                    },
                    "dstAddressType": {
                        "type": "string",
                        "description": "Matches destination address type.\n"
                    },
                    "dstLimit": {
                        "type": "string",
                        "description": "Matches packets until a given rate is exceeded.\n"
                    },
                    "dstPort": {
                        "type": "string",
                        "description": "List of destination port numbers or port number ranges.\n"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "fragment": {
                        "type": "boolean",
                        "description": "Matches fragmented packets. First (starting) fragment does not count. If connection tracking is enabled there will be no\nfragments as system automatically assembles every packet\n"
                    },
                    "hotspot": {
                        "type": "string",
                        "description": "Matches packets received from HotSpot clients against various HotSpot matchers.\n"
                    },
                    "icmpOptions": {
                        "type": "string",
                        "description": "Matches ICMP type: code fields.\n"
                    },
                    "inBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "inBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                    },
                    "inInterface": {
                        "type": "string",
                        "description": "Interface the packet has entered the router.\n"
                    },
                    "inInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                    },
                    "ingressPriority": {
                        "type": "integer",
                        "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "ipsecPolicy": {
                        "type": "string",
                        "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                    },
                    "ipv4Options": {
                        "type": "string",
                        "description": "Matches IPv4 header options.\n"
                    },
                    "jumpTarget": {
                        "type": "string",
                        "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                    },
                    "layer7Protocol": {
                        "type": "string",
                        "description": "Layer7 filter name.\n"
                    },
                    "limit": {
                        "type": "string",
                        "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                    },
                    "log": {
                        "type": "boolean",
                        "description": "Add a message to the system log.\n"
                    },
                    "logPrefix": {
                        "type": "string",
                        "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                    },
                    "nth": {
                        "type": "string",
                        "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                    },
                    "outBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "outBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                    },
                    "outInterface": {
                        "type": "string",
                        "description": "Interface the packet is leaving the router.\n"
                    },
                    "outInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                    },
                    "packetMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                    },
                    "packetSize": {
                        "type": "string",
                        "description": "Matches packets of specified size or size range in bytes.\n"
                    },
                    "packets": {
                        "type": "integer",
                        "description": "The total amount of packets matched by the rule.\n"
                    },
                    "perConnectionClassifier": {
                        "type": "string",
                        "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                    },
                    "placeBefore": {
                        "type": "string",
                        "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                        "willReplaceOnChanges": true
                    },
                    "port": {
                        "type": "string",
                        "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Matches particular IP protocol specified by protocol name or number.\n"
                    },
                    "psd": {
                        "type": "string",
                        "description": "Attempts to detect TCP and UDP scans. Parameters are in the following format WeightThreshold, DelayThreshold,\nLowPortWeight, HighPortWeight.\n"
                    },
                    "random": {
                        "type": "integer",
                        "description": "Matches packets randomly with a given probability.\n"
                    },
                    "routingMark": {
                        "type": "string",
                        "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                    },
                    "sameNotByDst": {
                        "type": "boolean",
                        "description": "Specifies whether to take into account or not destination IP address when selecting a new source IP address. Applicable\nif action=same\n"
                    },
                    "srcAddress": {
                        "type": "string",
                        "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                    },
                    "srcAddressList": {
                        "type": "string",
                        "description": "Matches source address of a packet against user-defined address list.\n"
                    },
                    "srcAddressType": {
                        "type": "string",
                        "description": "Matches source address type.\n"
                    },
                    "srcMacAddress": {
                        "type": "string",
                        "description": "Matches source MAC address of the packet.\n"
                    },
                    "srcPort": {
                        "type": "string",
                        "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                    },
                    "tcpMss": {
                        "type": "string",
                        "description": "Matches TCP MSS value of an IP packet.\n"
                    },
                    "time": {
                        "type": "string",
                        "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                    },
                    "toAddresses": {
                        "type": "string",
                        "description": "Replace original address with specified one. Applicable if action is dst-nat, netmap, same, src-nat.\n"
                    },
                    "toPorts": {
                        "type": "string",
                        "description": "Replace the original port with the specified one. Applicable if action is dst-nat, redirect, masquerade, netmap, same,\nsrc-nat.\n"
                    },
                    "ttl": {
                        "type": "string",
                        "description": "Matches packets TTL value.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/pool:Pool": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst pool = new routeros.ip.Pool(\"pool\", {ranges: [\"10.0.0.100-10.0.0.200\"]});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\npool = routeros.ip.Pool(\"pool\", ranges=[\"10.0.0.100-10.0.0.200\"])\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var pool = new Routeros.Ip.Pool(\"pool\", new()\n    {\n        Ranges = new[]\n        {\n            \"10.0.0.100-10.0.0.200\",\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ip.NewPool(ctx, \"pool\", \u0026Ip.PoolArgs{\n\t\t\tRanges: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"10.0.0.100-10.0.0.200\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.Pool;\nimport com.pulumi.routeros.Ip.PoolArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var pool = new Pool(\"pool\", PoolArgs.builder()        \n            .ranges(\"10.0.0.100-10.0.0.200\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  pool:\n    type: routeros:Ip:Pool\n    properties:\n      ranges:\n        - 10.0.0.100-10.0.0.200\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport with the name of the ip pool in case of the example use my_ip_pool\n\n```sh\n $ pulumi import routeros:Ip/pool:Pool pool my_ip_pool\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "nextPool": {
                    "type": "string",
                    "description": "When address is acquired from pool that has no free addresses, and next-pool property is set to another pool, then next IP address will be acquired from next-pool.\n"
                },
                "ranges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP address list of non-overlapping IP address ranges in form of: [\"from1-to1\", \"from2-to2\", ..., \"fromN-toN\"]. For example, [\"10.0.0.1-10.0.0.27\", \"10.0.0.32-10.0.0.47\"]\n"
                }
            },
            "required": [
                "name",
                "ranges"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "nextPool": {
                    "type": "string",
                    "description": "When address is acquired from pool that has no free addresses, and next-pool property is set to another pool, then next IP address will be acquired from next-pool.\n"
                },
                "ranges": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP address list of non-overlapping IP address ranges in form of: [\"from1-to1\", \"from2-to2\", ..., \"fromN-toN\"]. For example, [\"10.0.0.1-10.0.0.27\", \"10.0.0.32-10.0.0.47\"]\n"
                }
            },
            "requiredInputs": [
                "ranges"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Pool resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "nextPool": {
                        "type": "string",
                        "description": "When address is acquired from pool that has no free addresses, and next-pool property is set to another pool, then next IP address will be acquired from next-pool.\n"
                    },
                    "ranges": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "IP address list of non-overlapping IP address ranges in form of: [\"from1-to1\", \"from2-to2\", ..., \"fromN-toN\"]. For example, [\"10.0.0.1-10.0.0.27\", \"10.0.0.32-10.0.0.47\"]\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/route:Route": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst aRoute = new routeros.ip.Route(\"aRoute\", {\n    dstAddress: \"0.0.0.0/0\",\n    gateway: \"10.0.0.1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\na_route = routeros.ip.Route(\"aRoute\",\n    dst_address=\"0.0.0.0/0\",\n    gateway=\"10.0.0.1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var aRoute = new Routeros.Ip.Route(\"aRoute\", new()\n    {\n        DstAddress = \"0.0.0.0/0\",\n        Gateway = \"10.0.0.1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ip.NewRoute(ctx, \"aRoute\", \u0026Ip.RouteArgs{\n\t\t\tDstAddress: pulumi.String(\"0.0.0.0/0\"),\n\t\t\tGateway:    pulumi.String(\"10.0.0.1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.Route;\nimport com.pulumi.routeros.Ip.RouteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var aRoute = new Route(\"aRoute\", RouteArgs.builder()        \n            .dstAddress(\"0.0.0.0/0\")\n            .gateway(\"10.0.0.1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  aRoute:\n    type: routeros:Ip:Route\n    properties:\n      dstAddress: 0.0.0.0/0\n      gateway: 10.0.0.1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ip/route get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ip/route:Route a_route \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "A flag indicates whether the route is elected as Active and eligible to be added to the FIB.\n"
                },
                "blackhole": {
                    "type": "boolean",
                    "description": "It's a blackhole route.\n"
                },
                "checkGateway": {
                    "type": "string",
                    "description": "Currently used check-gateway option.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcp": {
                    "type": "boolean",
                    "description": "A flag indicates whether the route was added by the DHCP service.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "distance": {
                    "type": "integer",
                    "description": "Value used in route selection. Routes with smaller distance value are given preference.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "IP prefix of route, specifies destination addresses that this route can be used for.\n"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                },
                "ecmp": {
                    "type": "boolean",
                    "description": "A flag indicates whether the route is added as an Equal-Cost Multi-Path route in the FIB.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Array of IP addresses or interface names. Specifies which host or interface packets should be sent to (IP | interface | IP%interface | IP@table[, IP | string, [..]]).\n"
                },
                "hwOffloaded": {
                    "type": "boolean",
                    "description": "Indicates whether the route is eligible to be hardware offloaded on supported hardware.\n"
                },
                "immediateGw": {
                    "type": "string",
                    "description": "Shows actual (resolved) gateway and interface that will be used for packet forwarding.\n"
                },
                "inactive": {
                    "type": "boolean"
                },
                "prefSrc": {
                    "type": "string",
                    "description": "Which of the local IP addresses to use for locally originated packets that are sent via this route. Value of this property has no effect on forwarded packets. If value of this property is set to IP address that is not local address of this router then the route will be inactive (in ROS v6, ROS v7 allows IP spoofing).\n"
                },
                "routingTable": {
                    "type": "string",
                    "description": "Routing table this route belongs to.\n"
                },
                "scope": {
                    "type": "integer",
                    "description": "Used in nexthop resolution. Route can resolve nexthop only through routes that have scope less than or equal to the target-scope of this route.\n"
                },
                "static": {
                    "type": "boolean"
                },
                "suppressHwOffload": {
                    "type": "boolean"
                },
                "targetScope": {
                    "type": "integer",
                    "description": "Used in nexthop resolution. This is the maximum value of scope for a route through which a nexthop of this route can be resolved.\n"
                },
                "vrfInterface": {
                    "type": "string",
                    "description": "VRF interface name.\n"
                }
            },
            "required": [
                "active",
                "dhcp",
                "dynamic",
                "ecmp",
                "gateway",
                "hwOffloaded",
                "immediateGw",
                "inactive",
                "static",
                "suppressHwOffload",
                "vrfInterface"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "blackhole": {
                    "type": "boolean",
                    "description": "It's a blackhole route.\n"
                },
                "checkGateway": {
                    "type": "string",
                    "description": "Currently used check-gateway option.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "distance": {
                    "type": "integer",
                    "description": "Value used in route selection. Routes with smaller distance value are given preference.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "IP prefix of route, specifies destination addresses that this route can be used for.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Array of IP addresses or interface names. Specifies which host or interface packets should be sent to (IP | interface | IP%interface | IP@table[, IP | string, [..]]).\n"
                },
                "prefSrc": {
                    "type": "string",
                    "description": "Which of the local IP addresses to use for locally originated packets that are sent via this route. Value of this property has no effect on forwarded packets. If value of this property is set to IP address that is not local address of this router then the route will be inactive (in ROS v6, ROS v7 allows IP spoofing).\n"
                },
                "routingTable": {
                    "type": "string",
                    "description": "Routing table this route belongs to.\n"
                },
                "scope": {
                    "type": "integer",
                    "description": "Used in nexthop resolution. Route can resolve nexthop only through routes that have scope less than or equal to the target-scope of this route.\n"
                },
                "targetScope": {
                    "type": "integer",
                    "description": "Used in nexthop resolution. This is the maximum value of scope for a route through which a nexthop of this route can be resolved.\n"
                },
                "vrfInterface": {
                    "type": "string",
                    "description": "VRF interface name.\n"
                }
            },
            "requiredInputs": [
                "gateway"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Route resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "active": {
                        "type": "boolean",
                        "description": "A flag indicates whether the route is elected as Active and eligible to be added to the FIB.\n"
                    },
                    "blackhole": {
                        "type": "boolean",
                        "description": "It's a blackhole route.\n"
                    },
                    "checkGateway": {
                        "type": "string",
                        "description": "Currently used check-gateway option.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "dhcp": {
                        "type": "boolean",
                        "description": "A flag indicates whether the route was added by the DHCP service.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "distance": {
                        "type": "integer",
                        "description": "Value used in route selection. Routes with smaller distance value are given preference.\n"
                    },
                    "dstAddress": {
                        "type": "string",
                        "description": "IP prefix of route, specifies destination addresses that this route can be used for.\n"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                    },
                    "ecmp": {
                        "type": "boolean",
                        "description": "A flag indicates whether the route is added as an Equal-Cost Multi-Path route in the FIB.\n"
                    },
                    "gateway": {
                        "type": "string",
                        "description": "Array of IP addresses or interface names. Specifies which host or interface packets should be sent to (IP | interface | IP%interface | IP@table[, IP | string, [..]]).\n"
                    },
                    "hwOffloaded": {
                        "type": "boolean",
                        "description": "Indicates whether the route is eligible to be hardware offloaded on supported hardware.\n"
                    },
                    "immediateGw": {
                        "type": "string",
                        "description": "Shows actual (resolved) gateway and interface that will be used for packet forwarding.\n"
                    },
                    "inactive": {
                        "type": "boolean"
                    },
                    "prefSrc": {
                        "type": "string",
                        "description": "Which of the local IP addresses to use for locally originated packets that are sent via this route. Value of this property has no effect on forwarded packets. If value of this property is set to IP address that is not local address of this router then the route will be inactive (in ROS v6, ROS v7 allows IP spoofing).\n"
                    },
                    "routingTable": {
                        "type": "string",
                        "description": "Routing table this route belongs to.\n"
                    },
                    "scope": {
                        "type": "integer",
                        "description": "Used in nexthop resolution. Route can resolve nexthop only through routes that have scope less than or equal to the target-scope of this route.\n"
                    },
                    "static": {
                        "type": "boolean"
                    },
                    "suppressHwOffload": {
                        "type": "boolean"
                    },
                    "targetScope": {
                        "type": "integer",
                        "description": "Used in nexthop resolution. This is the maximum value of scope for a route through which a nexthop of this route can be resolved.\n"
                    },
                    "vrfInterface": {
                        "type": "string",
                        "description": "VRF interface name.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/service:Service": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst tlsService = {\n    \"api-ssl\": 8729,\n    \"www-ssl\": 443,\n};\nconst disableService = {\n    api: 8728,\n    ftp: 21,\n    telnet: 23,\n    www: 80,\n};\nconst enableService = {\n    ssh: 22,\n    winbox: 8291,\n};\nconst tlsCert = new routeros.system.Certificate(\"tlsCert\", {\n    commonName: \"Mikrotik Router\",\n    daysValid: 3650,\n    keyUsages: [\n        \"key-cert-sign\",\n        \"crl-sign\",\n        \"digital-signature\",\n        \"key-agreement\",\n        \"tls-server\",\n    ],\n    keySize: \"prime256v1\",\n    signs: [{}],\n});\n// terraform state rm 'routeros_ip_service.tls[\"www-ssl\"]'\n// terraform import 'routeros_ip_service.tls[\"www-ssl\"]' www-ssl\nconst tls: routeros.ip.Service[] = [];\nfor (const range of Object.entries(tlsService).map(([k, v]) =\u003e ({key: k, value: v}))) {\n    tls.push(new routeros.ip.Service(`tls-${range.key}`, {\n        numbers: range.key,\n        port: range.value,\n        certificate: tlsCert.name,\n        tlsVersion: \"only-1.2\",\n        disabled: false,\n    }));\n}\nconst disabled: routeros.ip.Service[] = [];\nfor (const range of Object.entries(disableService).map(([k, v]) =\u003e ({key: k, value: v}))) {\n    disabled.push(new routeros.ip.Service(`disabled-${range.key}`, {\n        numbers: range.key,\n        port: range.value,\n        disabled: true,\n    }));\n}\nconst enabled: routeros.ip.Service[] = [];\nfor (const range of Object.entries(enableService).map(([k, v]) =\u003e ({key: k, value: v}))) {\n    enabled.push(new routeros.ip.Service(`enabled-${range.key}`, {\n        numbers: range.key,\n        port: range.value,\n        disabled: false,\n    }));\n}\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntls_service = {\n    \"api-ssl\": 8729,\n    \"www-ssl\": 443,\n}\ndisable_service = {\n    \"api\": 8728,\n    \"ftp\": 21,\n    \"telnet\": 23,\n    \"www\": 80,\n}\nenable_service = {\n    \"ssh\": 22,\n    \"winbox\": 8291,\n}\ntls_cert = routeros.system.Certificate(\"tlsCert\",\n    common_name=\"Mikrotik Router\",\n    days_valid=3650,\n    key_usages=[\n        \"key-cert-sign\",\n        \"crl-sign\",\n        \"digital-signature\",\n        \"key-agreement\",\n        \"tls-server\",\n    ],\n    key_size=\"prime256v1\",\n    signs=[routeros.system.CertificateSignArgs()])\n# terraform state rm 'routeros_ip_service.tls[\"www-ssl\"]'\n# terraform import 'routeros_ip_service.tls[\"www-ssl\"]' www-ssl\ntls = []\nfor range in [{\"key\": k, \"value\": v} for [k, v] in enumerate(tls_service)]:\n    tls.append(routeros.ip.Service(f\"tls-{range['key']}\",\n        numbers=range[\"key\"],\n        port=range[\"value\"],\n        certificate=tls_cert.name,\n        tls_version=\"only-1.2\",\n        disabled=False))\ndisabled = []\nfor range in [{\"key\": k, \"value\": v} for [k, v] in enumerate(disable_service)]:\n    disabled.append(routeros.ip.Service(f\"disabled-{range['key']}\",\n        numbers=range[\"key\"],\n        port=range[\"value\"],\n        disabled=True))\nenabled = []\nfor range in [{\"key\": k, \"value\": v} for [k, v] in enumerate(enable_service)]:\n    enabled.append(routeros.ip.Service(f\"enabled-{range['key']}\",\n        numbers=range[\"key\"],\n        port=range[\"value\"],\n        disabled=False))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var tlsService = \n    {\n        { \"api-ssl\", 8729 },\n        { \"www-ssl\", 443 },\n    };\n\n    var disableService = \n    {\n        { \"api\", 8728 },\n        { \"ftp\", 21 },\n        { \"telnet\", 23 },\n        { \"www\", 80 },\n    };\n\n    var enableService = \n    {\n        { \"ssh\", 22 },\n        { \"winbox\", 8291 },\n    };\n\n    var tlsCert = new Routeros.System.Certificate(\"tlsCert\", new()\n    {\n        CommonName = \"Mikrotik Router\",\n        DaysValid = 3650,\n        KeyUsages = new[]\n        {\n            \"key-cert-sign\",\n            \"crl-sign\",\n            \"digital-signature\",\n            \"key-agreement\",\n            \"tls-server\",\n        },\n        KeySize = \"prime256v1\",\n        Signs = new[]\n        {\n            null,\n        },\n    });\n\n    // terraform state rm 'routeros_ip_service.tls[\"www-ssl\"]'\n    // terraform import 'routeros_ip_service.tls[\"www-ssl\"]' www-ssl\n    var tls = new List\u003cRouteros.Ip.Service\u003e();\n    foreach (var range in tlsService.Select(pair =\u003e new { pair.Key, pair.Value }))\n    {\n        tls.Add(new Routeros.Ip.Service($\"tls-{range.Key}\", new()\n        {\n            Numbers = range.Key,\n            Port = range.Value,\n            Certificate = tlsCert.Name,\n            TlsVersion = \"only-1.2\",\n            Disabled = false,\n        }));\n    }\n    var disabled = new List\u003cRouteros.Ip.Service\u003e();\n    foreach (var range in disableService.Select(pair =\u003e new { pair.Key, pair.Value }))\n    {\n        disabled.Add(new Routeros.Ip.Service($\"disabled-{range.Key}\", new()\n        {\n            Numbers = range.Key,\n            Port = range.Value,\n            Disabled = true,\n        }));\n    }\n    var enabled = new List\u003cRouteros.Ip.Service\u003e();\n    foreach (var range in enableService.Select(pair =\u003e new { pair.Key, pair.Value }))\n    {\n        enabled.Add(new Routeros.Ip.Service($\"enabled-{range.Key}\", new()\n        {\n            Numbers = range.Key,\n            Port = range.Value,\n            Disabled = false,\n        }));\n    }\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/System\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\ttlsService := map[string]interface{}{\n\t\t\t\"api-ssl\": 8729,\n\t\t\t\"www-ssl\": 443,\n\t\t}\n\t\tdisableService := map[string]interface{}{\n\t\t\t\"api\":    8728,\n\t\t\t\"ftp\":    21,\n\t\t\t\"telnet\": 23,\n\t\t\t\"www\":    80,\n\t\t}\n\t\tenableService := map[string]interface{}{\n\t\t\t\"ssh\":    22,\n\t\t\t\"winbox\": 8291,\n\t\t}\n\t\ttlsCert, err := System.NewCertificate(ctx, \"tlsCert\", \u0026System.CertificateArgs{\n\t\t\tCommonName: pulumi.String(\"Mikrotik Router\"),\n\t\t\tDaysValid:  pulumi.Int(3650),\n\t\t\tKeyUsages: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"key-cert-sign\"),\n\t\t\t\tpulumi.String(\"crl-sign\"),\n\t\t\t\tpulumi.String(\"digital-signature\"),\n\t\t\t\tpulumi.String(\"key-agreement\"),\n\t\t\t\tpulumi.String(\"tls-server\"),\n\t\t\t},\n\t\t\tKeySize: pulumi.String(\"prime256v1\"),\n\t\t\tSigns: system.CertificateSignArray{\n\t\t\t\tnil,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tvar tls []*Ip.Service\n\t\tfor key0, val0 := range tlsService {\n\t\t\t__res, err := Ip.NewService(ctx, fmt.Sprintf(\"tls-%v\", key0), \u0026Ip.ServiceArgs{\n\t\t\t\tNumbers:     pulumi.String(key0),\n\t\t\t\tPort:        pulumi.Float64(val0),\n\t\t\t\tCertificate: tlsCert.Name,\n\t\t\t\tTlsVersion:  pulumi.String(\"only-1.2\"),\n\t\t\t\tDisabled:    pulumi.Bool(false),\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\ttls = append(tls, __res)\n\t\t}\n\t\tvar disabled []*Ip.Service\n\t\tfor key0, val0 := range disableService {\n\t\t\t__res, err := Ip.NewService(ctx, fmt.Sprintf(\"disabled-%v\", key0), \u0026Ip.ServiceArgs{\n\t\t\t\tNumbers:  pulumi.String(key0),\n\t\t\t\tPort:     pulumi.Float64(val0),\n\t\t\t\tDisabled: pulumi.Bool(true),\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdisabled = append(disabled, __res)\n\t\t}\n\t\tvar enabled []*Ip.Service\n\t\tfor key0, val0 := range enableService {\n\t\t\t__res, err := Ip.NewService(ctx, fmt.Sprintf(\"enabled-%v\", key0), \u0026Ip.ServiceArgs{\n\t\t\t\tNumbers:  pulumi.String(key0),\n\t\t\t\tPort:     pulumi.Float64(val0),\n\t\t\t\tDisabled: pulumi.Bool(false),\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tenabled = append(enabled, __res)\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.System.Certificate;\nimport com.pulumi.routeros.System.CertificateArgs;\nimport com.pulumi.routeros.System.inputs.CertificateSignArgs;\nimport com.pulumi.routeros.Ip.Service;\nimport com.pulumi.routeros.Ip.ServiceArgs;\nimport com.pulumi.codegen.internal.KeyedValue;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        final var tlsService = %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);\n\n        final var disableService = %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);\n\n        final var enableService = %!v(PANIC=Format method: runtime error: invalid memory address or nil pointer dereference);\n\n        var tlsCert = new Certificate(\"tlsCert\", CertificateArgs.builder()        \n            .commonName(\"Mikrotik Router\")\n            .daysValid(3650)\n            .keyUsages(            \n                \"key-cert-sign\",\n                \"crl-sign\",\n                \"digital-signature\",\n                \"key-agreement\",\n                \"tls-server\")\n            .keySize(\"prime256v1\")\n            .signs()\n            .build());\n\n        for (var range : KeyedValue.of(tlsService)) {\n            new Service(\"tls-\" + range.key(), ServiceArgs.builder()            \n                .numbers(range.key())\n                .port(range.value())\n                .certificate(tlsCert.name())\n                .tlsVersion(\"only-1.2\")\n                .disabled(false)\n                .build());\n        }\n\n        for (var range : KeyedValue.of(disableService)) {\n            new Service(\"disabled-\" + range.key(), ServiceArgs.builder()            \n                .numbers(range.key())\n                .port(range.value())\n                .disabled(true)\n                .build());\n        }\n\n        for (var range : KeyedValue.of(enableService)) {\n            new Service(\"enabled-\" + range.key(), ServiceArgs.builder()            \n                .numbers(range.key())\n                .port(range.value())\n                .disabled(false)\n                .build());\n        }\n\n    }\n}\n```\n```yaml\nresources:\n  tlsCert:\n    type: routeros:System:Certificate\n    properties:\n      commonName: Mikrotik Router\n      daysValid: 3650\n      keyUsages:\n        - key-cert-sign\n        - crl-sign\n        - digital-signature\n        - key-agreement\n        - tls-server\n      keySize: prime256v1\n      signs:\n        - {}\n  # terraform state rm 'routeros_ip_service.tls[\"www-ssl\"]'\n  # terraform import 'routeros_ip_service.tls[\"www-ssl\"]' www-ssl\n  tls:\n    type: routeros:Ip:Service\n    properties:\n      numbers: ${range.key}\n      port: ${range.value}\n      certificate: ${tlsCert.name}\n      tlsVersion: only-1.2\n      disabled: false\n    options: {}\n  disabled:\n    type: routeros:Ip:Service\n    properties:\n      numbers: ${range.key}\n      port: ${range.value}\n      disabled: true\n    options: {}\n  enabled:\n    type: routeros:Ip:Service\n    properties:\n      numbers: ${range.key}\n      port: ${range.value}\n      disabled: false\n    options: {}\nvariables:\n  tlsService:\n    api-ssl: 8729\n    www-ssl: 443\n  disableService:\n    api: 8728\n    ftp: 21\n    telnet: 23\n    www: 80\n  enableService:\n    ssh: 22\n    winbox: 8291\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\nImport with the name of the ip service in case of the example use www-ssl\n\n```sh\n $ pulumi import routeros:Ip/service:Service www_ssl www-ssl\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "List of IP/IPv6 prefixes from which the service is accessible.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The name of the certificate used by a particular service. Applicable only for services that depend on certificates ( www-ssl, api-ssl ).\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "invalid": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string",
                    "description": "Service name.\n"
                },
                "numbers": {
                    "type": "string",
                    "description": "The name of the service whose settings will be changed ( api, api-ssl, ftp, ssh, telnet, winbox, www, www-ssl ).\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port particular service listens on.\n"
                },
                "tlsVersion": {
                    "type": "string",
                    "description": "Specifies which TLS versions to allow by a particular service.\n"
                },
                "vrf": {
                    "type": "string",
                    "description": "Specify which VRF instance to use by a particular service.\n"
                }
            },
            "required": [
                "invalid",
                "name",
                "numbers",
                "port"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "List of IP/IPv6 prefixes from which the service is accessible.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "The name of the certificate used by a particular service. Applicable only for services that depend on certificates ( www-ssl, api-ssl ).\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "numbers": {
                    "type": "string",
                    "description": "The name of the service whose settings will be changed ( api, api-ssl, ftp, ssh, telnet, winbox, www, www-ssl ).\n"
                },
                "port": {
                    "type": "integer",
                    "description": "The port particular service listens on.\n"
                },
                "tlsVersion": {
                    "type": "string",
                    "description": "Specifies which TLS versions to allow by a particular service.\n"
                },
                "vrf": {
                    "type": "string",
                    "description": "Specify which VRF instance to use by a particular service.\n"
                }
            },
            "requiredInputs": [
                "numbers",
                "port"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Service resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "List of IP/IPv6 prefixes from which the service is accessible.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "The name of the certificate used by a particular service. Applicable only for services that depend on certificates ( www-ssl, api-ssl ).\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string",
                        "description": "Service name.\n"
                    },
                    "numbers": {
                        "type": "string",
                        "description": "The name of the service whose settings will be changed ( api, api-ssl, ftp, ssh, telnet, winbox, www, www-ssl ).\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "The port particular service listens on.\n"
                    },
                    "tlsVersion": {
                        "type": "string",
                        "description": "Specifies which TLS versions to allow by a particular service.\n"
                    },
                    "vrf": {
                        "type": "string",
                        "description": "Specify which VRF instance to use by a particular service.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ip/v4Address:V4Address": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst address = new routeros.ip.V4Address(\"address\", {\n    address: \"10.0.0.1\",\n    \"interface\": \"bridge\",\n    network: \"10.0.0.0/24\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\naddress = routeros.ip.V4Address(\"address\",\n    address=\"10.0.0.1\",\n    interface=\"bridge\",\n    network=\"10.0.0.0/24\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var address = new Routeros.Ip.V4Address(\"address\", new()\n    {\n        Address = \"10.0.0.1\",\n        Interface = \"bridge\",\n        Network = \"10.0.0.0/24\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ip.NewV4Address(ctx, \"address\", \u0026Ip.V4AddressArgs{\n\t\t\tAddress:   pulumi.String(\"10.0.0.1\"),\n\t\t\tInterface: pulumi.String(\"bridge\"),\n\t\t\tNetwork:   pulumi.String(\"10.0.0.0/24\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.V4Address;\nimport com.pulumi.routeros.Ip.V4AddressArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var address = new V4Address(\"address\", V4AddressArgs.builder()        \n            .address(\"10.0.0.1\")\n            .interface_(\"bridge\")\n            .network(\"10.0.0.0/24\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  address:\n    type: routeros:Ip:V4Address\n    properties:\n      address: 10.0.0.1\n      interface: bridge\n      network: 10.0.0.0/24\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ip/address get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ip/v4Address:V4Address address \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "actualInterface": {
                    "type": "string",
                    "description": "Name of the actual interface the logical one is bound to.\n"
                },
                "address": {
                    "type": "string",
                    "description": "IP address.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "network": {
                    "type": "string",
                    "description": "IP address for the network. For point-to-point links it should be the address of the remote end. Starting from v5RC6 this parameter is configurable only for addresses with /32 netmask (point to point links)\n"
                }
            },
            "required": [
                "actualInterface",
                "address",
                "dynamic",
                "interface",
                "invalid",
                "network"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "IP address.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "network": {
                    "type": "string",
                    "description": "IP address for the network. For point-to-point links it should be the address of the remote end. Starting from v5RC6 this parameter is configurable only for addresses with /32 netmask (point to point links)\n"
                }
            },
            "requiredInputs": [
                "address",
                "interface"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering V4Address resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "actualInterface": {
                        "type": "string",
                        "description": "Name of the actual interface the logical one is bound to.\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "IP address.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "network": {
                        "type": "string",
                        "description": "IP address for the network. For point-to-point links it should be the address of the remote end. Starting from v5RC6 this parameter is configurable only for addresses with /32 netmask (point to point links)\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ipv6/firewallFilter:FirewallFilter": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst rule = new routeros.ipv6.FirewallFilter(\"rule\", {\n    action: \"accept\",\n    chain: \"forward\",\n    dstAddress: \"2001:DB8:2000::1\",\n    dstPort: \"443\",\n    protocol: \"tcp\",\n    srcAddress: \"2001:DB8:1000::1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nrule = routeros.ipv6.FirewallFilter(\"rule\",\n    action=\"accept\",\n    chain=\"forward\",\n    dst_address=\"2001:DB8:2000::1\",\n    dst_port=\"443\",\n    protocol=\"tcp\",\n    src_address=\"2001:DB8:1000::1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var rule = new Routeros.Ipv6.FirewallFilter(\"rule\", new()\n    {\n        Action = \"accept\",\n        Chain = \"forward\",\n        DstAddress = \"2001:DB8:2000::1\",\n        DstPort = \"443\",\n        Protocol = \"tcp\",\n        SrcAddress = \"2001:DB8:1000::1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ipv6\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ipv6.NewFirewallFilter(ctx, \"rule\", \u0026Ipv6.FirewallFilterArgs{\n\t\t\tAction:     pulumi.String(\"accept\"),\n\t\t\tChain:      pulumi.String(\"forward\"),\n\t\t\tDstAddress: pulumi.String(\"2001:DB8:2000::1\"),\n\t\t\tDstPort:    pulumi.String(\"443\"),\n\t\t\tProtocol:   pulumi.String(\"tcp\"),\n\t\t\tSrcAddress: pulumi.String(\"2001:DB8:1000::1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ipv6.FirewallFilter;\nimport com.pulumi.routeros.Ipv6.FirewallFilterArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var rule = new FirewallFilter(\"rule\", FirewallFilterArgs.builder()        \n            .action(\"accept\")\n            .chain(\"forward\")\n            .dstAddress(\"2001:DB8:2000::1\")\n            .dstPort(\"443\")\n            .protocol(\"tcp\")\n            .srcAddress(\"2001:DB8:1000::1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  rule:\n    type: routeros:Ipv6:FirewallFilter\n    properties:\n      action: accept\n      chain: forward\n      dstAddress: 2001:DB8:2000::1\n      dstPort: '443'\n      protocol: tcp\n      srcAddress: 2001:DB8:1000::1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ipv6/firewall/filter get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ipv6/firewallFilter:FirewallFilter rule \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "bytes": {
                    "type": "integer",
                    "description": "The total amount of bytes matched by the rule.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionState": {
                    "type": "string",
                    "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                },
                "headers": {
                    "type": "string",
                    "description": "Extension headers. Look at the Extras tab in the v6 filter rules.\n"
                },
                "hopLimit": {
                    "type": "string",
                    "description": "IPv6 TTL. Look at the Extras tab in the v6 filter rules.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "packets": {
                    "type": "integer",
                    "description": "The total amount of packets matched by the rule.\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n"
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "rejectWith": {
                    "type": "string",
                    "description": "Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpFlags": {
                    "type": "string",
                    "description": "Matches specified TCP flags.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "tlsHost": {
                    "type": "string",
                    "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                }
            },
            "required": [
                "action",
                "addressListTimeout",
                "bytes",
                "chain",
                "dynamic",
                "invalid",
                "packets"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "action": {
                    "type": "string",
                    "description": "Action to take if a packet is matched by the rule\n"
                },
                "addressListTimeout": {
                    "type": "string",
                    "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                },
                "chain": {
                    "type": "string",
                    "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                },
                "comment": {
                    "type": "string"
                },
                "connectionBytes": {
                    "type": "string",
                    "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                },
                "connectionLimit": {
                    "type": "string",
                    "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                },
                "connectionMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                },
                "connectionRate": {
                    "type": "string",
                    "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                },
                "connectionState": {
                    "type": "string",
                    "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                },
                "connectionType": {
                    "type": "string",
                    "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                },
                "content": {
                    "type": "string",
                    "description": "Match packets that contain specified text.\n"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dscp": {
                    "type": "integer",
                    "description": "Matches DSCP IP header field.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                },
                "dstAddressList": {
                    "type": "string",
                    "description": "Matches destination address of a packet against user-defined address list.\n"
                },
                "dstAddressType": {
                    "type": "string",
                    "description": "Matches destination address type.\n"
                },
                "dstLimit": {
                    "type": "string",
                    "description": "Matches packets until a given rate is exceeded.\n"
                },
                "dstPort": {
                    "type": "string",
                    "description": "List of destination port numbers or port number ranges.\n"
                },
                "headers": {
                    "type": "string",
                    "description": "Extension headers. Look at the Extras tab in the v6 filter rules.\n"
                },
                "hopLimit": {
                    "type": "string",
                    "description": "IPv6 TTL. Look at the Extras tab in the v6 filter rules.\n"
                },
                "icmpOptions": {
                    "type": "string",
                    "description": "Matches ICMP type: code fields.\n"
                },
                "inBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "inBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                },
                "inInterface": {
                    "type": "string",
                    "description": "Interface the packet has entered the router.\n"
                },
                "inInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                },
                "ingressPriority": {
                    "type": "integer",
                    "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                },
                "ipsecPolicy": {
                    "type": "string",
                    "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                },
                "jumpTarget": {
                    "type": "string",
                    "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                },
                "limit": {
                    "type": "string",
                    "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                },
                "log": {
                    "type": "boolean",
                    "description": "Add a message to the system log.\n"
                },
                "logPrefix": {
                    "type": "string",
                    "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                },
                "nth": {
                    "type": "string",
                    "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                },
                "outBridgePort": {
                    "type": "string",
                    "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                },
                "outBridgePortList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                },
                "outInterface": {
                    "type": "string",
                    "description": "Interface the packet is leaving the router.\n"
                },
                "outInterfaceList": {
                    "type": "string",
                    "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                },
                "packetMark": {
                    "type": "string",
                    "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                },
                "packetSize": {
                    "type": "string",
                    "description": "Matches packets of specified size or size range in bytes.\n"
                },
                "perConnectionClassifier": {
                    "type": "string",
                    "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                },
                "placeBefore": {
                    "type": "string",
                    "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                    "willReplaceOnChanges": true
                },
                "port": {
                    "type": "string",
                    "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                },
                "priority": {
                    "type": "integer",
                    "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "Matches particular IP protocol specified by protocol name or number.\n"
                },
                "random": {
                    "type": "integer",
                    "description": "Matches packets randomly with a given probability.\n"
                },
                "rejectWith": {
                    "type": "string",
                    "description": "Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.\n"
                },
                "routingMark": {
                    "type": "string",
                    "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                },
                "srcAddress": {
                    "type": "string",
                    "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                },
                "srcAddressList": {
                    "type": "string",
                    "description": "Matches source address of a packet against user-defined address list.\n"
                },
                "srcAddressType": {
                    "type": "string",
                    "description": "Matches source address type.\n"
                },
                "srcMacAddress": {
                    "type": "string",
                    "description": "Matches source MAC address of the packet.\n"
                },
                "srcPort": {
                    "type": "string",
                    "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                },
                "tcpFlags": {
                    "type": "string",
                    "description": "Matches specified TCP flags.\n"
                },
                "tcpMss": {
                    "type": "string",
                    "description": "Matches TCP MSS value of an IP packet.\n"
                },
                "time": {
                    "type": "string",
                    "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                },
                "tlsHost": {
                    "type": "string",
                    "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                }
            },
            "requiredInputs": [
                "action",
                "chain"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering FirewallFilter resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "action": {
                        "type": "string",
                        "description": "Action to take if a packet is matched by the rule\n"
                    },
                    "addressListTimeout": {
                        "type": "string",
                        "description": "Time interval after which the address will be removed from the address list specified by address-list parameter. Used in\nconjunction with add-dst-to-address-list or add-src-to-address-list actions.\n"
                    },
                    "bytes": {
                        "type": "integer",
                        "description": "The total amount of bytes matched by the rule.\n"
                    },
                    "chain": {
                        "type": "string",
                        "description": "Specifies to which chain rule will be added. If the input does not match the name of an already defined chain, a new\nchain will be created.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "connectionBytes": {
                        "type": "string",
                        "description": "Matches packets only if a given amount of bytes has been transfered through the particular connection.\n"
                    },
                    "connectionLimit": {
                        "type": "string",
                        "description": "Matches connections per address or address block after given value is reached. Should be used together with\nconnection-state=new and/or with tcp-flags=syn because matcher is very resource intensive.\n"
                    },
                    "connectionMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular connection mark. If no-mark is set, rule will match any\nunmarked connection.\n"
                    },
                    "connectionRate": {
                        "type": "string",
                        "description": "Connection Rate is a firewall matcher that allow to capture traffic based on present speed of the connection\n(0..4294967295).\n"
                    },
                    "connectionState": {
                        "type": "string",
                        "description": "Interprets the connection tracking analysis data for a particular packet.\n"
                    },
                    "connectionType": {
                        "type": "string",
                        "description": "Matches packets from related connections based on information from their connection tracking helpers.\n"
                    },
                    "content": {
                        "type": "string",
                        "description": "Match packets that contain specified text.\n"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dscp": {
                        "type": "integer",
                        "description": "Matches DSCP IP header field.\n"
                    },
                    "dstAddress": {
                        "type": "string",
                        "description": "Matches packets which destination is equal to specified IP or falls into specified IP range.\n"
                    },
                    "dstAddressList": {
                        "type": "string",
                        "description": "Matches destination address of a packet against user-defined address list.\n"
                    },
                    "dstAddressType": {
                        "type": "string",
                        "description": "Matches destination address type.\n"
                    },
                    "dstLimit": {
                        "type": "string",
                        "description": "Matches packets until a given rate is exceeded.\n"
                    },
                    "dstPort": {
                        "type": "string",
                        "description": "List of destination port numbers or port number ranges.\n"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly\nmodified.\n"
                    },
                    "headers": {
                        "type": "string",
                        "description": "Extension headers. Look at the Extras tab in the v6 filter rules.\n"
                    },
                    "hopLimit": {
                        "type": "string",
                        "description": "IPv6 TTL. Look at the Extras tab in the v6 filter rules.\n"
                    },
                    "icmpOptions": {
                        "type": "string",
                        "description": "Matches ICMP type: code fields.\n"
                    },
                    "inBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet has entered the router if the incoming interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "inBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-bridge-port.\n"
                    },
                    "inInterface": {
                        "type": "string",
                        "description": "Interface the packet has entered the router.\n"
                    },
                    "inInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as in-interface.\n"
                    },
                    "ingressPriority": {
                        "type": "integer",
                        "description": "Matches the priority of an ingress packet. Priority may be derived from VLAN, WMM, DSCP, or MPLS EXP bit.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "ipsecPolicy": {
                        "type": "string",
                        "description": "Matches the policy used by IPsec. Value is written in the following format: direction, policy.\n"
                    },
                    "jumpTarget": {
                        "type": "string",
                        "description": "Name of the target chain to jump to. Applicable only if action=jump.\n"
                    },
                    "limit": {
                        "type": "string",
                        "description": "Matches packets up to a limited rate (packet rate or bit rate). A rule using this matcher will match until this limit is\nreached. Parameters are written in the following format: rate[/time],burst:mode.\n"
                    },
                    "log": {
                        "type": "boolean",
                        "description": "Add a message to the system log.\n"
                    },
                    "logPrefix": {
                        "type": "string",
                        "description": "Adds specified text at the beginning of every log message. Applicable if action=log or log=yes configured.\n"
                    },
                    "nth": {
                        "type": "string",
                        "description": "Matches every nth packet: nth=2,1 rule will match every first packet of 2, hence, 50% of all the traffic that is matched\nby the rule\n"
                    },
                    "outBridgePort": {
                        "type": "string",
                        "description": "Actual interface the packet is leaving the router if the outgoing interface is a bridge. Works only if use-ip-firewall\nis enabled in bridge settings.\n"
                    },
                    "outBridgePortList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-bridge-port.\n"
                    },
                    "outInterface": {
                        "type": "string",
                        "description": "Interface the packet is leaving the router.\n"
                    },
                    "outInterfaceList": {
                        "type": "string",
                        "description": "Set of interfaces defined in interface list. Works the same as out-interface.\n"
                    },
                    "packetMark": {
                        "type": "string",
                        "description": "Matches packets marked via mangle facility with particular packet mark. If no-mark is set, the rule will match any\nunmarked packet.\n"
                    },
                    "packetSize": {
                        "type": "string",
                        "description": "Matches packets of specified size or size range in bytes.\n"
                    },
                    "packets": {
                        "type": "integer",
                        "description": "The total amount of packets matched by the rule.\n"
                    },
                    "perConnectionClassifier": {
                        "type": "string",
                        "description": "PCC matcher allows dividing traffic into equal streams with the ability to keep packets with a specific set of options\nin one particular stream.\n"
                    },
                    "placeBefore": {
                        "type": "string",
                        "description": "Before which position the rule will be inserted. \u003e Please check the effect of this option, as it does not work as you\nthink! \u003e Best way to use in conjunction with a data source. See [example](../data-sources/firewall.md#example-usage).\n",
                        "willReplaceOnChanges": true
                    },
                    "port": {
                        "type": "string",
                        "description": "Matches if any (source or destination) port matches the specified list of ports or port ranges. Applicable only if\nprotocol is TCP or UDP\n"
                    },
                    "priority": {
                        "type": "integer",
                        "description": "Matches the packet's priority after a new priority has been set. Priority may be derived from VLAN, WMM, DSCP, MPLS EXP\nbit, or from the priority that has been set using the set-priority action.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "Matches particular IP protocol specified by protocol name or number.\n"
                    },
                    "random": {
                        "type": "integer",
                        "description": "Matches packets randomly with a given probability.\n"
                    },
                    "rejectWith": {
                        "type": "string",
                        "description": "Specifies ICMP error to be sent back if the packet is rejected. Applicable if action=reject.\n"
                    },
                    "routingMark": {
                        "type": "string",
                        "description": "Matches packets marked by mangle facility with particular routing mark.\n"
                    },
                    "srcAddress": {
                        "type": "string",
                        "description": "Matches packets which source is equal to specified IP or falls into a specified IP range.\n"
                    },
                    "srcAddressList": {
                        "type": "string",
                        "description": "Matches source address of a packet against user-defined address list.\n"
                    },
                    "srcAddressType": {
                        "type": "string",
                        "description": "Matches source address type.\n"
                    },
                    "srcMacAddress": {
                        "type": "string",
                        "description": "Matches source MAC address of the packet.\n"
                    },
                    "srcPort": {
                        "type": "string",
                        "description": "List of source ports and ranges of source ports. Applicable only if a protocol is TCP or UDP.\n"
                    },
                    "tcpFlags": {
                        "type": "string",
                        "description": "Matches specified TCP flags.\n"
                    },
                    "tcpMss": {
                        "type": "string",
                        "description": "Matches TCP MSS value of an IP packet.\n"
                    },
                    "time": {
                        "type": "string",
                        "description": "Allows to create a filter based on the packets' arrival time and date or, for locally generated packets, departure time\nand date.\n"
                    },
                    "tlsHost": {
                        "type": "string",
                        "description": "Allows matching HTTPS traffic based on TLS SNI hostname.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ipv6/route:Route": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst aRoute = new routeros.ipv6.Route(\"aRoute\", {\n    dstAddress: \"::/0\",\n    gateway: \"2001:DB8:1000::1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\na_route = routeros.ipv6.Route(\"aRoute\",\n    dst_address=\"::/0\",\n    gateway=\"2001:DB8:1000::1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var aRoute = new Routeros.Ipv6.Route(\"aRoute\", new()\n    {\n        DstAddress = \"::/0\",\n        Gateway = \"2001:DB8:1000::1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ipv6\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ipv6.NewRoute(ctx, \"aRoute\", \u0026Ipv6.RouteArgs{\n\t\t\tDstAddress: pulumi.String(\"::/0\"),\n\t\t\tGateway:    pulumi.String(\"2001:DB8:1000::1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ipv6.Route;\nimport com.pulumi.routeros.Ipv6.RouteArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var aRoute = new Route(\"aRoute\", RouteArgs.builder()        \n            .dstAddress(\"::/0\")\n            .gateway(\"2001:DB8:1000::1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  aRoute:\n    type: routeros:Ipv6:Route\n    properties:\n      dstAddress: ::/0\n      gateway: 2001:DB8:1000::1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ipv6/route get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ipv6/route:Route a_route \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "active": {
                    "type": "boolean",
                    "description": "A flag indicates whether the route is elected as Active and eligible to be added to the FIB.\n"
                },
                "blackhole": {
                    "type": "boolean",
                    "description": "It's a blackhole route.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "distance": {
                    "type": "integer",
                    "description": "Value used in route selection. Routes with smaller distance value are given preference.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "IP prefix of route, specifies destination addresses that this route can be used for.\n"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                },
                "ecmp": {
                    "type": "boolean",
                    "description": "A flag indicates whether the route is added as an Equal-Cost Multi-Path route in the FIB.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Array of IP addresses or interface names. Specifies which host or interface packets should be sent to (IP | interface | IP%interface | IP@table[, IP | string, [..]]).\n"
                },
                "hwOffloaded": {
                    "type": "boolean",
                    "description": "Indicates whether the route is eligible to be hardware offloaded on supported hardware.\n"
                },
                "immediateGw": {
                    "type": "string",
                    "description": "Shows actual (resolved) gateway and interface that will be used for packet forwarding.\n"
                },
                "inactive": {
                    "type": "boolean"
                },
                "prefSrc": {
                    "type": "string",
                    "description": "Which of the local IP addresses to use for locally originated packets that are sent via this route. Value of this property has no effect on forwarded packets. If value of this property is set to IP address that is not local address of this router then the route will be inactive (in ROS v6, ROS v7 allows IP spoofing).\n"
                },
                "routingTable": {
                    "type": "string",
                    "description": "Routing table this route belongs to.\n"
                },
                "scope": {
                    "type": "integer",
                    "description": "Used in nexthop resolution. Route can resolve nexthop only through routes that have scope less than or equal to the target-scope of this route.\n"
                },
                "static": {
                    "type": "boolean"
                },
                "suppressHwOffload": {
                    "type": "boolean"
                },
                "targetScope": {
                    "type": "integer",
                    "description": "Used in nexthop resolution. This is the maximum value of scope for a route through which a nexthop of this route can be resolved.\n"
                },
                "vrfInterface": {
                    "type": "string",
                    "description": "VRF interface name.\n"
                }
            },
            "required": [
                "active",
                "dstAddress",
                "dynamic",
                "ecmp",
                "gateway",
                "hwOffloaded",
                "immediateGw",
                "inactive",
                "static",
                "suppressHwOffload",
                "vrfInterface"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "blackhole": {
                    "type": "boolean",
                    "description": "It's a blackhole route.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "distance": {
                    "type": "integer",
                    "description": "Value used in route selection. Routes with smaller distance value are given preference.\n"
                },
                "dstAddress": {
                    "type": "string",
                    "description": "IP prefix of route, specifies destination addresses that this route can be used for.\n"
                },
                "gateway": {
                    "type": "string",
                    "description": "Array of IP addresses or interface names. Specifies which host or interface packets should be sent to (IP | interface | IP%interface | IP@table[, IP | string, [..]]).\n"
                },
                "prefSrc": {
                    "type": "string",
                    "description": "Which of the local IP addresses to use for locally originated packets that are sent via this route. Value of this property has no effect on forwarded packets. If value of this property is set to IP address that is not local address of this router then the route will be inactive (in ROS v6, ROS v7 allows IP spoofing).\n"
                },
                "routingTable": {
                    "type": "string",
                    "description": "Routing table this route belongs to.\n"
                },
                "scope": {
                    "type": "integer",
                    "description": "Used in nexthop resolution. Route can resolve nexthop only through routes that have scope less than or equal to the target-scope of this route.\n"
                },
                "targetScope": {
                    "type": "integer",
                    "description": "Used in nexthop resolution. This is the maximum value of scope for a route through which a nexthop of this route can be resolved.\n"
                },
                "vrfInterface": {
                    "type": "string",
                    "description": "VRF interface name.\n"
                }
            },
            "requiredInputs": [
                "dstAddress",
                "gateway"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Route resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "active": {
                        "type": "boolean",
                        "description": "A flag indicates whether the route is elected as Active and eligible to be added to the FIB.\n"
                    },
                    "blackhole": {
                        "type": "boolean",
                        "description": "It's a blackhole route.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "distance": {
                        "type": "integer",
                        "description": "Value used in route selection. Routes with smaller distance value are given preference.\n"
                    },
                    "dstAddress": {
                        "type": "string",
                        "description": "IP prefix of route, specifies destination addresses that this route can be used for.\n"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                    },
                    "ecmp": {
                        "type": "boolean",
                        "description": "A flag indicates whether the route is added as an Equal-Cost Multi-Path route in the FIB.\n"
                    },
                    "gateway": {
                        "type": "string",
                        "description": "Array of IP addresses or interface names. Specifies which host or interface packets should be sent to (IP | interface | IP%interface | IP@table[, IP | string, [..]]).\n"
                    },
                    "hwOffloaded": {
                        "type": "boolean",
                        "description": "Indicates whether the route is eligible to be hardware offloaded on supported hardware.\n"
                    },
                    "immediateGw": {
                        "type": "string",
                        "description": "Shows actual (resolved) gateway and interface that will be used for packet forwarding.\n"
                    },
                    "inactive": {
                        "type": "boolean"
                    },
                    "prefSrc": {
                        "type": "string",
                        "description": "Which of the local IP addresses to use for locally originated packets that are sent via this route. Value of this property has no effect on forwarded packets. If value of this property is set to IP address that is not local address of this router then the route will be inactive (in ROS v6, ROS v7 allows IP spoofing).\n"
                    },
                    "routingTable": {
                        "type": "string",
                        "description": "Routing table this route belongs to.\n"
                    },
                    "scope": {
                        "type": "integer",
                        "description": "Used in nexthop resolution. Route can resolve nexthop only through routes that have scope less than or equal to the target-scope of this route.\n"
                    },
                    "static": {
                        "type": "boolean"
                    },
                    "suppressHwOffload": {
                        "type": "boolean"
                    },
                    "targetScope": {
                        "type": "integer",
                        "description": "Used in nexthop resolution. This is the maximum value of scope for a route through which a nexthop of this route can be resolved.\n"
                    },
                    "vrfInterface": {
                        "type": "string",
                        "description": "VRF interface name.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ipv6/v6Address:V6Address": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst ipv6Address = new routeros.ipv6.V6Address(\"ipv6Address\", {\n    address: \"fd55::1/64\",\n    disabled: false,\n    \"interface\": \"ether1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nipv6_address = routeros.ipv6.V6Address(\"ipv6Address\",\n    address=\"fd55::1/64\",\n    disabled=False,\n    interface=\"ether1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ipv6Address = new Routeros.Ipv6.V6Address(\"ipv6Address\", new()\n    {\n        Address = \"fd55::1/64\",\n        Disabled = false,\n        Interface = \"ether1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ipv6\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ipv6.NewV6Address(ctx, \"ipv6Address\", \u0026Ipv6.V6AddressArgs{\n\t\t\tAddress:   pulumi.String(\"fd55::1/64\"),\n\t\t\tDisabled:  pulumi.Bool(false),\n\t\t\tInterface: pulumi.String(\"ether1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ipv6.V6Address;\nimport com.pulumi.routeros.Ipv6.V6AddressArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ipv6Address = new V6Address(\"ipv6Address\", V6AddressArgs.builder()        \n            .address(\"fd55::1/64\")\n            .disabled(false)\n            .interface_(\"ether1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ipv6Address:\n    type: routeros:Ipv6:V6Address\n    properties:\n      address: fd55::1/64\n      disabled: false\n      interface: ether1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ipv6/address get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ipv6/v6Address:V6Address ipv6_address \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "actualInterface": {
                    "type": "string",
                    "description": "Name of the actual interface the logical one is bound to.\n"
                },
                "address": {
                    "type": "string",
                    "description": "IPv6 address. Using the eui*64 and from*pool options can transform the original address! [See docs](https://wiki.mikrotik.com/wiki/Manual:IPv6/Address#Properties)\n"
                },
                "advertise": {
                    "type": "boolean",
                    "description": "Whether to enable stateless address configuration. The prefix of that address is automatically advertised to hosts using ICMPv6 protocol. The option is set by default for addresses with prefix length 64.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                },
                "eui64": {
                    "type": "boolean",
                    "description": "Whether to calculate EUI-64 address and use it as last 64 bits of the IPv6 address.\n"
                },
                "fromPool": {
                    "type": "string",
                    "description": "Name of the pool from which prefix will be taken to construct IPv6 address taking last part of the address from address property.\n"
                },
                "global": {
                    "type": "boolean",
                    "description": "Whether address is global.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "linkLocal": {
                    "type": "boolean",
                    "description": "Whether address is link local.\n"
                },
                "noDad": {
                    "type": "boolean",
                    "description": "If set indicates that address is anycast address and Duplicate Address Detection should not be performed.\n"
                }
            },
            "required": [
                "actualInterface",
                "address",
                "dynamic",
                "global",
                "interface",
                "invalid",
                "linkLocal"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "IPv6 address. Using the eui*64 and from*pool options can transform the original address! [See docs](https://wiki.mikrotik.com/wiki/Manual:IPv6/Address#Properties)\n"
                },
                "advertise": {
                    "type": "boolean",
                    "description": "Whether to enable stateless address configuration. The prefix of that address is automatically advertised to hosts using ICMPv6 protocol. The option is set by default for addresses with prefix length 64.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "eui64": {
                    "type": "boolean",
                    "description": "Whether to calculate EUI-64 address and use it as last 64 bits of the IPv6 address.\n"
                },
                "fromPool": {
                    "type": "string",
                    "description": "Name of the pool from which prefix will be taken to construct IPv6 address taking last part of the address from address property.\n"
                },
                "interface": {
                    "type": "string",
                    "description": "Name of the interface.\n"
                },
                "noDad": {
                    "type": "boolean",
                    "description": "If set indicates that address is anycast address and Duplicate Address Detection should not be performed.\n"
                }
            },
            "requiredInputs": [
                "interface"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering V6Address resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "actualInterface": {
                        "type": "string",
                        "description": "Name of the actual interface the logical one is bound to.\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "IPv6 address. Using the eui*64 and from*pool options can transform the original address! [See docs](https://wiki.mikrotik.com/wiki/Manual:IPv6/Address#Properties)\n"
                    },
                    "advertise": {
                        "type": "boolean",
                        "description": "Whether to enable stateless address configuration. The prefix of that address is automatically advertised to hosts using ICMPv6 protocol. The option is set by default for addresses with prefix length 64.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                    },
                    "eui64": {
                        "type": "boolean",
                        "description": "Whether to calculate EUI-64 address and use it as last 64 bits of the IPv6 address.\n"
                    },
                    "fromPool": {
                        "type": "string",
                        "description": "Name of the pool from which prefix will be taken to construct IPv6 address taking last part of the address from address property.\n"
                    },
                    "global": {
                        "type": "boolean",
                        "description": "Whether address is global.\n"
                    },
                    "interface": {
                        "type": "string",
                        "description": "Name of the interface.\n"
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "linkLocal": {
                        "type": "boolean",
                        "description": "Whether address is link local.\n"
                    },
                    "noDad": {
                        "type": "boolean",
                        "description": "If set indicates that address is anycast address and Duplicate Address Detection should not be performed.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:OpenVpn/server:Server": {
            "description": "## # routeros.OpenVpn.Server (Resource)\n\n##### *\u003cspan style=\"color:red\"\u003eThis resource requires a minimum version of RouterOS 7.8!\u003c/span\u003e*\n\n{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst ovpn_pool = new routeros.ip.Pool(\"ovpn-pool\", {ranges: [\"192.168.77.2-192.168.77.254\"]});\nconst ovpnCa = new routeros.system.Certificate(\"ovpnCa\", {\n    commonName: \"OpenVPN Root CA\",\n    keySize: \"prime256v1\",\n    keyUsages: [\n        \"key-cert-sign\",\n        \"crl-sign\",\n    ],\n    trusted: true,\n    signs: [{}],\n});\nconst ovpnServerCrt = new routeros.system.Certificate(\"ovpnServerCrt\", {\n    commonName: \"Mikrotik OpenVPN\",\n    keySize: \"prime256v1\",\n    keyUsages: [\n        \"digital-signature\",\n        \"key-encipherment\",\n        \"tls-server\",\n    ],\n    signs: [{\n        ca: ovpnCa.name,\n    }],\n});\nconst testProfile = new routeros.ppp.Profile(\"testProfile\", {\n    localAddress: \"192.168.77.1\",\n    remoteAddress: \"ovpn-pool\",\n    useUpnp: \"no\",\n});\nconst testSecret = new routeros.ppp.Secret(\"testSecret\", {\n    password: \"123\",\n    profile: testProfile.name,\n});\nconst server = new routeros.openvpn.Server(\"server\", {\n    enabled: true,\n    certificate: ovpnServerCrt.name,\n    auth: \"sha256,sha512\",\n    tlsVersion: \"only-1.2\",\n    defaultProfile: testProfile.name,\n});\n// The resource should be created only after the OpenVPN server is enabled!\nconst user1 = new routeros.iface.OpenVpnServer(\"user1\", {user: \"user1\"}, {\n    dependsOn: [server],\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\novpn_pool = routeros.ip.Pool(\"ovpn-pool\", ranges=[\"192.168.77.2-192.168.77.254\"])\novpn_ca = routeros.system.Certificate(\"ovpnCa\",\n    common_name=\"OpenVPN Root CA\",\n    key_size=\"prime256v1\",\n    key_usages=[\n        \"key-cert-sign\",\n        \"crl-sign\",\n    ],\n    trusted=True,\n    signs=[routeros.system.CertificateSignArgs()])\novpn_server_crt = routeros.system.Certificate(\"ovpnServerCrt\",\n    common_name=\"Mikrotik OpenVPN\",\n    key_size=\"prime256v1\",\n    key_usages=[\n        \"digital-signature\",\n        \"key-encipherment\",\n        \"tls-server\",\n    ],\n    signs=[routeros.system.CertificateSignArgs(\n        ca=ovpn_ca.name,\n    )])\ntest_profile = routeros.ppp.Profile(\"testProfile\",\n    local_address=\"192.168.77.1\",\n    remote_address=\"ovpn-pool\",\n    use_upnp=\"no\")\ntest_secret = routeros.ppp.Secret(\"testSecret\",\n    password=\"123\",\n    profile=test_profile.name)\nserver = routeros.open_vpn.Server(\"server\",\n    enabled=True,\n    certificate=ovpn_server_crt.name,\n    auth=\"sha256,sha512\",\n    tls_version=\"only-1.2\",\n    default_profile=test_profile.name)\n# The resource should be created only after the OpenVPN server is enabled!\nuser1 = routeros.iface.OpenVpnServer(\"user1\", user=\"user1\",\nopts=pulumi.ResourceOptions(depends_on=[server]))\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var ovpn_pool = new Routeros.Ip.Pool(\"ovpn-pool\", new()\n    {\n        Ranges = new[]\n        {\n            \"192.168.77.2-192.168.77.254\",\n        },\n    });\n\n    var ovpnCa = new Routeros.System.Certificate(\"ovpnCa\", new()\n    {\n        CommonName = \"OpenVPN Root CA\",\n        KeySize = \"prime256v1\",\n        KeyUsages = new[]\n        {\n            \"key-cert-sign\",\n            \"crl-sign\",\n        },\n        Trusted = true,\n        Signs = new[]\n        {\n            null,\n        },\n    });\n\n    var ovpnServerCrt = new Routeros.System.Certificate(\"ovpnServerCrt\", new()\n    {\n        CommonName = \"Mikrotik OpenVPN\",\n        KeySize = \"prime256v1\",\n        KeyUsages = new[]\n        {\n            \"digital-signature\",\n            \"key-encipherment\",\n            \"tls-server\",\n        },\n        Signs = new[]\n        {\n            new Routeros.System.Inputs.CertificateSignArgs\n            {\n                Ca = ovpnCa.Name,\n            },\n        },\n    });\n\n    var testProfile = new Routeros.Ppp.Profile(\"testProfile\", new()\n    {\n        LocalAddress = \"192.168.77.1\",\n        RemoteAddress = \"ovpn-pool\",\n        UseUpnp = \"no\",\n    });\n\n    var testSecret = new Routeros.Ppp.Secret(\"testSecret\", new()\n    {\n        Password = \"123\",\n        Profile = testProfile.Name,\n    });\n\n    var server = new Routeros.OpenVpn.Server(\"server\", new()\n    {\n        Enabled = true,\n        Certificate = ovpnServerCrt.Name,\n        Auth = \"sha256,sha512\",\n        TlsVersion = \"only-1.2\",\n        DefaultProfile = testProfile.Name,\n    });\n\n    // The resource should be created only after the OpenVPN server is enabled!\n    var user1 = new Routeros.Iface.OpenVpnServer(\"user1\", new()\n    {\n        User = \"user1\",\n    }, new CustomResourceOptions\n    {\n        DependsOn = new[]\n        {\n            server,\n        },\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Iface\"\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ip\"\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/OpenVpn\"\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ppp\"\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/System\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ip.NewPool(ctx, \"ovpn-pool\", \u0026Ip.PoolArgs{\n\t\t\tRanges: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"192.168.77.2-192.168.77.254\"),\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tovpnCa, err := System.NewCertificate(ctx, \"ovpnCa\", \u0026System.CertificateArgs{\n\t\t\tCommonName: pulumi.String(\"OpenVPN Root CA\"),\n\t\t\tKeySize:    pulumi.String(\"prime256v1\"),\n\t\t\tKeyUsages: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"key-cert-sign\"),\n\t\t\t\tpulumi.String(\"crl-sign\"),\n\t\t\t},\n\t\t\tTrusted: pulumi.Bool(true),\n\t\t\tSigns: system.CertificateSignArray{\n\t\t\t\tnil,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tovpnServerCrt, err := System.NewCertificate(ctx, \"ovpnServerCrt\", \u0026System.CertificateArgs{\n\t\t\tCommonName: pulumi.String(\"Mikrotik OpenVPN\"),\n\t\t\tKeySize:    pulumi.String(\"prime256v1\"),\n\t\t\tKeyUsages: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"digital-signature\"),\n\t\t\t\tpulumi.String(\"key-encipherment\"),\n\t\t\t\tpulumi.String(\"tls-server\"),\n\t\t\t},\n\t\t\tSigns: system.CertificateSignArray{\n\t\t\t\t\u0026system.CertificateSignArgs{\n\t\t\t\t\tCa: ovpnCa.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttestProfile, err := Ppp.NewProfile(ctx, \"testProfile\", \u0026Ppp.ProfileArgs{\n\t\t\tLocalAddress:  pulumi.String(\"192.168.77.1\"),\n\t\t\tRemoteAddress: pulumi.String(\"ovpn-pool\"),\n\t\t\tUseUpnp:       pulumi.String(\"no\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = Ppp.NewSecret(ctx, \"testSecret\", \u0026Ppp.SecretArgs{\n\t\t\tPassword: pulumi.String(\"123\"),\n\t\t\tProfile:  testProfile.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tserver, err := OpenVpn.NewServer(ctx, \"server\", \u0026OpenVpn.ServerArgs{\n\t\t\tEnabled:        pulumi.Bool(true),\n\t\t\tCertificate:    ovpnServerCrt.Name,\n\t\t\tAuth:           pulumi.String(\"sha256,sha512\"),\n\t\t\tTlsVersion:     pulumi.String(\"only-1.2\"),\n\t\t\tDefaultProfile: testProfile.Name,\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = Iface.NewOpenVpnServer(ctx, \"user1\", \u0026Iface.OpenVpnServerArgs{\n\t\t\tUser: pulumi.String(\"user1\"),\n\t\t}, pulumi.DependsOn([]pulumi.Resource{\n\t\t\tserver,\n\t\t}))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ip.Pool;\nimport com.pulumi.routeros.Ip.PoolArgs;\nimport com.pulumi.routeros.System.Certificate;\nimport com.pulumi.routeros.System.CertificateArgs;\nimport com.pulumi.routeros.System.inputs.CertificateSignArgs;\nimport com.pulumi.routeros.Ppp.Profile;\nimport com.pulumi.routeros.Ppp.ProfileArgs;\nimport com.pulumi.routeros.Ppp.Secret;\nimport com.pulumi.routeros.Ppp.SecretArgs;\nimport com.pulumi.routeros.OpenVpn.Server;\nimport com.pulumi.routeros.OpenVpn.ServerArgs;\nimport com.pulumi.routeros.Iface.OpenVpnServer;\nimport com.pulumi.routeros.Iface.OpenVpnServerArgs;\nimport com.pulumi.resources.CustomResourceOptions;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var ovpn_pool = new Pool(\"ovpn-pool\", PoolArgs.builder()        \n            .ranges(\"192.168.77.2-192.168.77.254\")\n            .build());\n\n        var ovpnCa = new Certificate(\"ovpnCa\", CertificateArgs.builder()        \n            .commonName(\"OpenVPN Root CA\")\n            .keySize(\"prime256v1\")\n            .keyUsages(            \n                \"key-cert-sign\",\n                \"crl-sign\")\n            .trusted(true)\n            .signs()\n            .build());\n\n        var ovpnServerCrt = new Certificate(\"ovpnServerCrt\", CertificateArgs.builder()        \n            .commonName(\"Mikrotik OpenVPN\")\n            .keySize(\"prime256v1\")\n            .keyUsages(            \n                \"digital-signature\",\n                \"key-encipherment\",\n                \"tls-server\")\n            .signs(CertificateSignArgs.builder()\n                .ca(ovpnCa.name())\n                .build())\n            .build());\n\n        var testProfile = new Profile(\"testProfile\", ProfileArgs.builder()        \n            .localAddress(\"192.168.77.1\")\n            .remoteAddress(\"ovpn-pool\")\n            .useUpnp(\"no\")\n            .build());\n\n        var testSecret = new Secret(\"testSecret\", SecretArgs.builder()        \n            .password(\"123\")\n            .profile(testProfile.name())\n            .build());\n\n        var server = new Server(\"server\", ServerArgs.builder()        \n            .enabled(true)\n            .certificate(ovpnServerCrt.name())\n            .auth(\"sha256,sha512\")\n            .tlsVersion(\"only-1.2\")\n            .defaultProfile(testProfile.name())\n            .build());\n\n        var user1 = new OpenVpnServer(\"user1\", OpenVpnServerArgs.builder()        \n            .user(\"user1\")\n            .build(), CustomResourceOptions.builder()\n                .dependsOn(server)\n                .build());\n\n    }\n}\n```\n```yaml\nresources:\n  ovpn-pool:\n    type: routeros:Ip:Pool\n    properties:\n      ranges:\n        - 192.168.77.2-192.168.77.254\n  ovpnCa:\n    type: routeros:System:Certificate\n    properties:\n      commonName: OpenVPN Root CA\n      keySize: prime256v1\n      keyUsages:\n        - key-cert-sign\n        - crl-sign\n      trusted: true\n      signs:\n        - {}\n  ovpnServerCrt:\n    type: routeros:System:Certificate\n    properties:\n      commonName: Mikrotik OpenVPN\n      keySize: prime256v1\n      keyUsages:\n        - digital-signature\n        - key-encipherment\n        - tls-server\n      signs:\n        - ca: ${ovpnCa.name}\n  testProfile:\n    type: routeros:Ppp:Profile\n    properties:\n      localAddress: 192.168.77.1\n      remoteAddress: ovpn-pool\n      useUpnp: no\n  testSecret:\n    type: routeros:Ppp:Secret\n    properties:\n      password: '123'\n      profile: ${testProfile.name}\n  server:\n    type: routeros:OpenVpn:Server\n    properties:\n      enabled: true\n      certificate: ${ovpnServerCrt.name}\n      auth: sha256,sha512\n      tlsVersion: only-1.2\n      defaultProfile: ${testProfile.name}\n  # The resource should be created only after the OpenVPN server is enabled!\n  user1:\n    type: routeros:Iface:OpenVpnServer\n    properties:\n      user: user1\n    options:\n      dependson:\n        - ${server}\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import routeros:OpenVpn/server:Server server .\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "auth": {
                    "type": "string",
                    "description": "Authentication methods that the server will accept.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Name of the certificate that the OVPN server will use.\n"
                },
                "cipher": {
                    "type": "string",
                    "description": "Allowed ciphers.\n"
                },
                "defaultProfile": {
                    "type": "string",
                    "description": "Default profile to use.\n"
                },
                "enableTunIpv6": {
                    "type": "boolean",
                    "description": "Specifies if IPv6 IP tunneling mode should be possible with this OVPN server.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines whether the OVPN server is enabled or not.\n"
                },
                "ipv6PrefixLen": {
                    "type": "integer",
                    "description": "Length of IPv6 prefix for IPv6 address which will be used when generating OVPN interface on the server side.\n"
                },
                "keepaliveTimeout": {
                    "type": "string",
                    "description": "Defines  the time period (in seconds) after which the router is starting to send  keepalive packets every second. If no traffic and no keepalive  responses have come for that period of time (i.e. 2 *  keepalive-timeout), not responding client is proclaimed disconnected\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "Automatically generated MAC address of the server.\n"
                },
                "maxMtu": {
                    "type": "integer",
                    "description": "Maximum Transmission Unit. Max packet size that the OVPN interface will be able to send without packet fragmentation.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Layer3 or layer2 tunnel mode (alternatively tun, tap)\n"
                },
                "netmask": {
                    "type": "integer",
                    "description": "Subnet mask to be applied to the client.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port to run the server on.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "indicates the protocol to use when connecting with the remote endpoint.\n"
                },
                "redirectGateway": {
                    "type": "string",
                    "description": "Specifies what kind of routes the OVPN client must add to the routing table. def1  Use this flag to override the default gateway by using 0.0.0.0/1 and  128.0.0.0/1 rather than 0.0.0.0/0. This has the benefit of overriding  but not wiping out the original default gateway. disabled - Do not send redirect-gateway flags to the OVPN client. ipv6 - Redirect IPv6 routing into the tunnel on the client side. This works  similarly to the def1 flag, that is, more specific IPv6 routes are added  (2000::/4 and 3000::/4), covering the whole IPv6 unicast space.\n"
                },
                "renegSec": {
                    "type": "integer",
                    "description": "Renegotiate data channel key after n seconds (default=3600).\n"
                },
                "requireClientCertificate": {
                    "type": "boolean",
                    "description": "If set to yes, then the server checks whether the client's certificate belongs to the same certificate chain.\n"
                },
                "tlsVersion": {
                    "type": "string",
                    "description": "Specifies which TLS versions to allow.\n"
                },
                "tunServerIpv6": {
                    "type": "string",
                    "description": "IPv6 prefix address which will be used when generating the OVPN interface on the server side.\n"
                }
            },
            "required": [
                "certificate",
                "macAddress"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "auth": {
                    "type": "string",
                    "description": "Authentication methods that the server will accept.\n"
                },
                "certificate": {
                    "type": "string",
                    "description": "Name of the certificate that the OVPN server will use.\n"
                },
                "cipher": {
                    "type": "string",
                    "description": "Allowed ciphers.\n"
                },
                "defaultProfile": {
                    "type": "string",
                    "description": "Default profile to use.\n"
                },
                "enableTunIpv6": {
                    "type": "boolean",
                    "description": "Specifies if IPv6 IP tunneling mode should be possible with this OVPN server.\n"
                },
                "enabled": {
                    "type": "boolean",
                    "description": "Defines whether the OVPN server is enabled or not.\n"
                },
                "ipv6PrefixLen": {
                    "type": "integer",
                    "description": "Length of IPv6 prefix for IPv6 address which will be used when generating OVPN interface on the server side.\n"
                },
                "keepaliveTimeout": {
                    "type": "string",
                    "description": "Defines  the time period (in seconds) after which the router is starting to send  keepalive packets every second. If no traffic and no keepalive  responses have come for that period of time (i.e. 2 *  keepalive-timeout), not responding client is proclaimed disconnected\n"
                },
                "macAddress": {
                    "type": "string",
                    "description": "Automatically generated MAC address of the server.\n"
                },
                "maxMtu": {
                    "type": "integer",
                    "description": "Maximum Transmission Unit. Max packet size that the OVPN interface will be able to send without packet fragmentation.\n"
                },
                "mode": {
                    "type": "string",
                    "description": "Layer3 or layer2 tunnel mode (alternatively tun, tap)\n"
                },
                "netmask": {
                    "type": "integer",
                    "description": "Subnet mask to be applied to the client.\n"
                },
                "port": {
                    "type": "integer",
                    "description": "Port to run the server on.\n"
                },
                "protocol": {
                    "type": "string",
                    "description": "indicates the protocol to use when connecting with the remote endpoint.\n"
                },
                "redirectGateway": {
                    "type": "string",
                    "description": "Specifies what kind of routes the OVPN client must add to the routing table. def1  Use this flag to override the default gateway by using 0.0.0.0/1 and  128.0.0.0/1 rather than 0.0.0.0/0. This has the benefit of overriding  but not wiping out the original default gateway. disabled - Do not send redirect-gateway flags to the OVPN client. ipv6 - Redirect IPv6 routing into the tunnel on the client side. This works  similarly to the def1 flag, that is, more specific IPv6 routes are added  (2000::/4 and 3000::/4), covering the whole IPv6 unicast space.\n"
                },
                "renegSec": {
                    "type": "integer",
                    "description": "Renegotiate data channel key after n seconds (default=3600).\n"
                },
                "requireClientCertificate": {
                    "type": "boolean",
                    "description": "If set to yes, then the server checks whether the client's certificate belongs to the same certificate chain.\n"
                },
                "tlsVersion": {
                    "type": "string",
                    "description": "Specifies which TLS versions to allow.\n"
                },
                "tunServerIpv6": {
                    "type": "string",
                    "description": "IPv6 prefix address which will be used when generating the OVPN interface on the server side.\n"
                }
            },
            "requiredInputs": [
                "certificate"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Server resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "auth": {
                        "type": "string",
                        "description": "Authentication methods that the server will accept.\n"
                    },
                    "certificate": {
                        "type": "string",
                        "description": "Name of the certificate that the OVPN server will use.\n"
                    },
                    "cipher": {
                        "type": "string",
                        "description": "Allowed ciphers.\n"
                    },
                    "defaultProfile": {
                        "type": "string",
                        "description": "Default profile to use.\n"
                    },
                    "enableTunIpv6": {
                        "type": "boolean",
                        "description": "Specifies if IPv6 IP tunneling mode should be possible with this OVPN server.\n"
                    },
                    "enabled": {
                        "type": "boolean",
                        "description": "Defines whether the OVPN server is enabled or not.\n"
                    },
                    "ipv6PrefixLen": {
                        "type": "integer",
                        "description": "Length of IPv6 prefix for IPv6 address which will be used when generating OVPN interface on the server side.\n"
                    },
                    "keepaliveTimeout": {
                        "type": "string",
                        "description": "Defines  the time period (in seconds) after which the router is starting to send  keepalive packets every second. If no traffic and no keepalive  responses have come for that period of time (i.e. 2 *  keepalive-timeout), not responding client is proclaimed disconnected\n"
                    },
                    "macAddress": {
                        "type": "string",
                        "description": "Automatically generated MAC address of the server.\n"
                    },
                    "maxMtu": {
                        "type": "integer",
                        "description": "Maximum Transmission Unit. Max packet size that the OVPN interface will be able to send without packet fragmentation.\n"
                    },
                    "mode": {
                        "type": "string",
                        "description": "Layer3 or layer2 tunnel mode (alternatively tun, tap)\n"
                    },
                    "netmask": {
                        "type": "integer",
                        "description": "Subnet mask to be applied to the client.\n"
                    },
                    "port": {
                        "type": "integer",
                        "description": "Port to run the server on.\n"
                    },
                    "protocol": {
                        "type": "string",
                        "description": "indicates the protocol to use when connecting with the remote endpoint.\n"
                    },
                    "redirectGateway": {
                        "type": "string",
                        "description": "Specifies what kind of routes the OVPN client must add to the routing table. def1  Use this flag to override the default gateway by using 0.0.0.0/1 and  128.0.0.0/1 rather than 0.0.0.0/0. This has the benefit of overriding  but not wiping out the original default gateway. disabled - Do not send redirect-gateway flags to the OVPN client. ipv6 - Redirect IPv6 routing into the tunnel on the client side. This works  similarly to the def1 flag, that is, more specific IPv6 routes are added  (2000::/4 and 3000::/4), covering the whole IPv6 unicast space.\n"
                    },
                    "renegSec": {
                        "type": "integer",
                        "description": "Renegotiate data channel key after n seconds (default=3600).\n"
                    },
                    "requireClientCertificate": {
                        "type": "boolean",
                        "description": "If set to yes, then the server checks whether the client's certificate belongs to the same certificate chain.\n"
                    },
                    "tlsVersion": {
                        "type": "string",
                        "description": "Specifies which TLS versions to allow.\n"
                    },
                    "tunServerIpv6": {
                        "type": "string",
                        "description": "IPv6 prefix address which will be used when generating the OVPN interface on the server side.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ppp/profile:Profile": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst test = new routeros.ppp.Profile(\"test\", {\n    localAddress: \"192.168.77.1\",\n    remoteAddress: \"ovpn-pool\",\n    useUpnp: \"no\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest = routeros.ppp.Profile(\"test\",\n    local_address=\"192.168.77.1\",\n    remote_address=\"ovpn-pool\",\n    use_upnp=\"no\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Routeros.Ppp.Profile(\"test\", new()\n    {\n        LocalAddress = \"192.168.77.1\",\n        RemoteAddress = \"ovpn-pool\",\n        UseUpnp = \"no\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ppp\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ppp.NewProfile(ctx, \"test\", \u0026Ppp.ProfileArgs{\n\t\t\tLocalAddress:  pulumi.String(\"192.168.77.1\"),\n\t\t\tRemoteAddress: pulumi.String(\"ovpn-pool\"),\n\t\t\tUseUpnp:       pulumi.String(\"no\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ppp.Profile;\nimport com.pulumi.routeros.Ppp.ProfileArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Profile(\"test\", ProfileArgs.builder()        \n            .localAddress(\"192.168.77.1\")\n            .remoteAddress(\"ovpn-pool\")\n            .useUpnp(\"no\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: routeros:Ppp:Profile\n    properties:\n      localAddress: 192.168.77.1\n      remoteAddress: ovpn-pool\n      useUpnp: no\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ppp/profile get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ppp/profile:Profile test *6\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Address list name to which ppp assigned (on server) or received (on client) address will be added.\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "Name of the bridge interface to which ppp interface will be added as a slave port. Both  tunnel endpoints (server and client) must be in bridge in order to make  this work, see more details on the BCP bridging manual.\n"
                },
                "bridgeHorizon": {
                    "type": "integer",
                    "description": "Used  split-horizon value for the dynamically created bridge port. Can be  used to prevent bridging loops and isolate traffic. Set the same value  for a group of ports, to prevent them from sending data to ports with  the same horizon value.\n"
                },
                "bridgeLearning": {
                    "type": "string",
                    "description": "Changes MAC learning behavior on the dynamically created bridge port: yes - enables MAC learning no - disables MAC learning default - derive this value from the interface default profile; same as yes if this is the interface default profile.\n"
                },
                "bridgePathCost": {
                    "type": "integer",
                    "description": "Used  path cost for the dynamically created bridge port, used by STP/RSTP to  determine the best path, used by MSTP to determine the best path between  regions. This property has no effect when a bridge protocol-mode is set to none.\n"
                },
                "bridgePortPriority": {
                    "type": "integer",
                    "description": "Used  priority for the dynamically created bridge port, used by STP/RSTP to  determine the root port, used by MSTP to determine root port between  regions. This property has no effect when a bridge protocol-mode is set  to none.\n"
                },
                "changeTcpMss": {
                    "type": "string",
                    "description": "Modifies connection MSS settings (applies only for IPv4): yes - adjust connection MSS value no - do not adjust connection MSS value default - derive this value from the interface default profile; same as no if this is the interface default profile.\n"
                },
                "comment": {
                    "type": "string"
                },
                "default": {
                    "type": "string",
                    "description": "Default profile sign.\n"
                },
                "dhcpv6PdPool": {
                    "type": "string",
                    "description": "Name of the IPv6 pool which will be used by dynamically created DHCPv6-PD server when client connects. [Read more \u003e\u003e](https://wiki.mikrotik.com/wiki/Manual:IPv6_PD_over_PPP)\n"
                },
                "dnsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP address of the DNS server that is supplied to ppp clients.\n"
                },
                "idleTimeout": {
                    "type": "string",
                    "description": "Specifies  the amount of time after which the link will be terminated if there are  no activity present. Timeout is not set by default.\n"
                },
                "incomingFilter": {
                    "type": "string",
                    "description": "Firewall  chain name for incoming packets. Specified chain gets control for each  packet coming from the client. The ppp chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the examples section.\n"
                },
                "insertQueueBefore": {
                    "type": "string",
                    "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                },
                "interfaceList": {
                    "type": "string",
                    "description": "Interface list name.\n"
                },
                "localAddress": {
                    "type": "string",
                    "description": "Tunnel address or name of the pool from which address is assigned to ppp interface locally.\n"
                },
                "name": {
                    "type": "string",
                    "description": "PPP profile name.\n"
                },
                "onDown": {
                    "type": "string",
                    "description": "Execute script on user logging off. See on-up for more details.\n"
                },
                "onUp": {
                    "type": "string",
                    "description": "Execute script on user login-event. These are available variables that are accessible for the event script: *user *local-address *remote-address *caller-id *called-id *interface.\n"
                },
                "onlyOne": {
                    "type": "string",
                    "description": "Defines whether a user is allowed to have more than one ppp session at a time yes - a user is not allowed to have more than one ppp session at a time no - the user is allowed to have more than one ppp session at a time default - derive this value from the interface default profile; same as no if this is the interface default profile.\n"
                },
                "outgoingFilter": {
                    "type": "string",
                    "description": "Firewall  chain name for outgoing packets. The specified chain gets control for  each packet going to the client. The PPP chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the Examples section.\n"
                },
                "parentQueue": {
                    "type": "string",
                    "description": "Name of parent simple queue.\n"
                },
                "queueType": {
                    "type": "string",
                    "description": "Queue types.\n"
                },
                "rateLimit": {
                    "type": "string",
                    "description": "Rate limitation in form of rx-rate[/tx-rate]  [rx-burst-rate[/tx-burst-rate] [rx-burst-threshold[/tx-burst-threshold]  [rx-burst-time[/tx-burst-time] [priority] [rx-rate-min[/tx-rate-min]]]] from the point of view of the router (so 'rx' is client upload, and  'tx' is client download). All rates are measured in bits per second,  unless followed by optional 'k' suffix (kilobits per second) or 'M'  suffix (megabits per second). If tx-rate is not specified, rx-rate  serves as tx-rate too. The same applies for tx-burst-rate,  tx-burst-threshold and tx-burst-time. If both rx-burst-threshold and  tx-burst-threshold are not specified (but burst-rate is specified),  rx-rate and tx-rate are used as burst thresholds. If both rx-burst-time  and tx-burst-time are not specified, 1s is used as default. Priority  takes values 1..8, where 1 implies the highest priority, but 8 - the  lowest. If rx-rate-min and tx-rate-min are not specified rx-rate and  tx-rate values are used. The rx-rate-min and tx-rate-min values can not  exceed rx-rate and tx-rate values.\n"
                },
                "remoteAddress": {
                    "type": "string",
                    "description": "Tunnel address or name of the pool from which address is assigned to remote ppp interface.\n"
                },
                "remoteIpv6PrefixPool": {
                    "type": "string",
                    "description": "Assign prefix from IPv6 pool to the client and install corresponding IPv6 route.\n"
                },
                "sessionTimeout": {
                    "type": "string",
                    "description": "Maximum time the connection can stay up. By default no time limit is set.\n"
                },
                "useCompression": {
                    "type": "string",
                    "description": "Specifies whether to use data compression or not. yes - enable data compression no - disable data compression default - derive this value from the interface default profile; same as no if this is the interface default profile This setting does not affect OVPN tunnels.\n"
                },
                "useEncryption": {
                    "type": "string",
                    "description": "Specifies whether to use data encryption or not. yes - enable data encryption no - disable data encryption default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires encryption This setting does not work on OVPN and SSTP tunnels.\n"
                },
                "useIpv6": {
                    "type": "string",
                    "description": "Specifies whether to allow IPv6. By default is enabled if IPv6 package is installed. yes - enable IPv6 support no - disable IPv6 support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires IPv6 support.\n"
                },
                "useMpls": {
                    "type": "string",
                    "description": "Specifies whether to allow MPLS over PPP. yes - enable MPLS support no - disable MPLS support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires MPLS support\n"
                },
                "useUpnp": {
                    "type": "string",
                    "description": "Specifies whether to allow UPnP.\n"
                },
                "winsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP address of the WINS server to supply to Windows clients.\n"
                }
            },
            "required": [
                "default",
                "name"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "addressList": {
                    "type": "string",
                    "description": "Address list name to which ppp assigned (on server) or received (on client) address will be added.\n"
                },
                "bridge": {
                    "type": "string",
                    "description": "Name of the bridge interface to which ppp interface will be added as a slave port. Both  tunnel endpoints (server and client) must be in bridge in order to make  this work, see more details on the BCP bridging manual.\n"
                },
                "bridgeHorizon": {
                    "type": "integer",
                    "description": "Used  split-horizon value for the dynamically created bridge port. Can be  used to prevent bridging loops and isolate traffic. Set the same value  for a group of ports, to prevent them from sending data to ports with  the same horizon value.\n"
                },
                "bridgeLearning": {
                    "type": "string",
                    "description": "Changes MAC learning behavior on the dynamically created bridge port: yes - enables MAC learning no - disables MAC learning default - derive this value from the interface default profile; same as yes if this is the interface default profile.\n"
                },
                "bridgePathCost": {
                    "type": "integer",
                    "description": "Used  path cost for the dynamically created bridge port, used by STP/RSTP to  determine the best path, used by MSTP to determine the best path between  regions. This property has no effect when a bridge protocol-mode is set to none.\n"
                },
                "bridgePortPriority": {
                    "type": "integer",
                    "description": "Used  priority for the dynamically created bridge port, used by STP/RSTP to  determine the root port, used by MSTP to determine root port between  regions. This property has no effect when a bridge protocol-mode is set  to none.\n"
                },
                "changeTcpMss": {
                    "type": "string",
                    "description": "Modifies connection MSS settings (applies only for IPv4): yes - adjust connection MSS value no - do not adjust connection MSS value default - derive this value from the interface default profile; same as no if this is the interface default profile.\n"
                },
                "comment": {
                    "type": "string"
                },
                "dhcpv6PdPool": {
                    "type": "string",
                    "description": "Name of the IPv6 pool which will be used by dynamically created DHCPv6-PD server when client connects. [Read more \u003e\u003e](https://wiki.mikrotik.com/wiki/Manual:IPv6_PD_over_PPP)\n"
                },
                "dnsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP address of the DNS server that is supplied to ppp clients.\n"
                },
                "idleTimeout": {
                    "type": "string",
                    "description": "Specifies  the amount of time after which the link will be terminated if there are  no activity present. Timeout is not set by default.\n"
                },
                "incomingFilter": {
                    "type": "string",
                    "description": "Firewall  chain name for incoming packets. Specified chain gets control for each  packet coming from the client. The ppp chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the examples section.\n"
                },
                "insertQueueBefore": {
                    "type": "string",
                    "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                },
                "interfaceList": {
                    "type": "string",
                    "description": "Interface list name.\n"
                },
                "localAddress": {
                    "type": "string",
                    "description": "Tunnel address or name of the pool from which address is assigned to ppp interface locally.\n"
                },
                "name": {
                    "type": "string",
                    "description": "PPP profile name.\n"
                },
                "onDown": {
                    "type": "string",
                    "description": "Execute script on user logging off. See on-up for more details.\n"
                },
                "onUp": {
                    "type": "string",
                    "description": "Execute script on user login-event. These are available variables that are accessible for the event script: *user *local-address *remote-address *caller-id *called-id *interface.\n"
                },
                "onlyOne": {
                    "type": "string",
                    "description": "Defines whether a user is allowed to have more than one ppp session at a time yes - a user is not allowed to have more than one ppp session at a time no - the user is allowed to have more than one ppp session at a time default - derive this value from the interface default profile; same as no if this is the interface default profile.\n"
                },
                "outgoingFilter": {
                    "type": "string",
                    "description": "Firewall  chain name for outgoing packets. The specified chain gets control for  each packet going to the client. The PPP chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the Examples section.\n"
                },
                "parentQueue": {
                    "type": "string",
                    "description": "Name of parent simple queue.\n"
                },
                "queueType": {
                    "type": "string",
                    "description": "Queue types.\n"
                },
                "rateLimit": {
                    "type": "string",
                    "description": "Rate limitation in form of rx-rate[/tx-rate]  [rx-burst-rate[/tx-burst-rate] [rx-burst-threshold[/tx-burst-threshold]  [rx-burst-time[/tx-burst-time] [priority] [rx-rate-min[/tx-rate-min]]]] from the point of view of the router (so 'rx' is client upload, and  'tx' is client download). All rates are measured in bits per second,  unless followed by optional 'k' suffix (kilobits per second) or 'M'  suffix (megabits per second). If tx-rate is not specified, rx-rate  serves as tx-rate too. The same applies for tx-burst-rate,  tx-burst-threshold and tx-burst-time. If both rx-burst-threshold and  tx-burst-threshold are not specified (but burst-rate is specified),  rx-rate and tx-rate are used as burst thresholds. If both rx-burst-time  and tx-burst-time are not specified, 1s is used as default. Priority  takes values 1..8, where 1 implies the highest priority, but 8 - the  lowest. If rx-rate-min and tx-rate-min are not specified rx-rate and  tx-rate values are used. The rx-rate-min and tx-rate-min values can not  exceed rx-rate and tx-rate values.\n"
                },
                "remoteAddress": {
                    "type": "string",
                    "description": "Tunnel address or name of the pool from which address is assigned to remote ppp interface.\n"
                },
                "remoteIpv6PrefixPool": {
                    "type": "string",
                    "description": "Assign prefix from IPv6 pool to the client and install corresponding IPv6 route.\n"
                },
                "sessionTimeout": {
                    "type": "string",
                    "description": "Maximum time the connection can stay up. By default no time limit is set.\n"
                },
                "useCompression": {
                    "type": "string",
                    "description": "Specifies whether to use data compression or not. yes - enable data compression no - disable data compression default - derive this value from the interface default profile; same as no if this is the interface default profile This setting does not affect OVPN tunnels.\n"
                },
                "useEncryption": {
                    "type": "string",
                    "description": "Specifies whether to use data encryption or not. yes - enable data encryption no - disable data encryption default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires encryption This setting does not work on OVPN and SSTP tunnels.\n"
                },
                "useIpv6": {
                    "type": "string",
                    "description": "Specifies whether to allow IPv6. By default is enabled if IPv6 package is installed. yes - enable IPv6 support no - disable IPv6 support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires IPv6 support.\n"
                },
                "useMpls": {
                    "type": "string",
                    "description": "Specifies whether to allow MPLS over PPP. yes - enable MPLS support no - disable MPLS support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires MPLS support\n"
                },
                "useUpnp": {
                    "type": "string",
                    "description": "Specifies whether to allow UPnP.\n"
                },
                "winsServers": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IP address of the WINS server to supply to Windows clients.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Profile resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "addressList": {
                        "type": "string",
                        "description": "Address list name to which ppp assigned (on server) or received (on client) address will be added.\n"
                    },
                    "bridge": {
                        "type": "string",
                        "description": "Name of the bridge interface to which ppp interface will be added as a slave port. Both  tunnel endpoints (server and client) must be in bridge in order to make  this work, see more details on the BCP bridging manual.\n"
                    },
                    "bridgeHorizon": {
                        "type": "integer",
                        "description": "Used  split-horizon value for the dynamically created bridge port. Can be  used to prevent bridging loops and isolate traffic. Set the same value  for a group of ports, to prevent them from sending data to ports with  the same horizon value.\n"
                    },
                    "bridgeLearning": {
                        "type": "string",
                        "description": "Changes MAC learning behavior on the dynamically created bridge port: yes - enables MAC learning no - disables MAC learning default - derive this value from the interface default profile; same as yes if this is the interface default profile.\n"
                    },
                    "bridgePathCost": {
                        "type": "integer",
                        "description": "Used  path cost for the dynamically created bridge port, used by STP/RSTP to  determine the best path, used by MSTP to determine the best path between  regions. This property has no effect when a bridge protocol-mode is set to none.\n"
                    },
                    "bridgePortPriority": {
                        "type": "integer",
                        "description": "Used  priority for the dynamically created bridge port, used by STP/RSTP to  determine the root port, used by MSTP to determine root port between  regions. This property has no effect when a bridge protocol-mode is set  to none.\n"
                    },
                    "changeTcpMss": {
                        "type": "string",
                        "description": "Modifies connection MSS settings (applies only for IPv4): yes - adjust connection MSS value no - do not adjust connection MSS value default - derive this value from the interface default profile; same as no if this is the interface default profile.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "default": {
                        "type": "string",
                        "description": "Default profile sign.\n"
                    },
                    "dhcpv6PdPool": {
                        "type": "string",
                        "description": "Name of the IPv6 pool which will be used by dynamically created DHCPv6-PD server when client connects. [Read more \u003e\u003e](https://wiki.mikrotik.com/wiki/Manual:IPv6_PD_over_PPP)\n"
                    },
                    "dnsServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "IP address of the DNS server that is supplied to ppp clients.\n"
                    },
                    "idleTimeout": {
                        "type": "string",
                        "description": "Specifies  the amount of time after which the link will be terminated if there are  no activity present. Timeout is not set by default.\n"
                    },
                    "incomingFilter": {
                        "type": "string",
                        "description": "Firewall  chain name for incoming packets. Specified chain gets control for each  packet coming from the client. The ppp chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the examples section.\n"
                    },
                    "insertQueueBefore": {
                        "type": "string",
                        "description": "Specify where to place dynamic simple queue entries for static DCHP leases with rate-limit parameter set.\n"
                    },
                    "interfaceList": {
                        "type": "string",
                        "description": "Interface list name.\n"
                    },
                    "localAddress": {
                        "type": "string",
                        "description": "Tunnel address or name of the pool from which address is assigned to ppp interface locally.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "PPP profile name.\n"
                    },
                    "onDown": {
                        "type": "string",
                        "description": "Execute script on user logging off. See on-up for more details.\n"
                    },
                    "onUp": {
                        "type": "string",
                        "description": "Execute script on user login-event. These are available variables that are accessible for the event script: *user *local-address *remote-address *caller-id *called-id *interface.\n"
                    },
                    "onlyOne": {
                        "type": "string",
                        "description": "Defines whether a user is allowed to have more than one ppp session at a time yes - a user is not allowed to have more than one ppp session at a time no - the user is allowed to have more than one ppp session at a time default - derive this value from the interface default profile; same as no if this is the interface default profile.\n"
                    },
                    "outgoingFilter": {
                        "type": "string",
                        "description": "Firewall  chain name for outgoing packets. The specified chain gets control for  each packet going to the client. The PPP chain should be manually added  and rules with action=jump jump-target=ppp should be added to other  relevant chains in order for this feature to work. For more information  look at the Examples section.\n"
                    },
                    "parentQueue": {
                        "type": "string",
                        "description": "Name of parent simple queue.\n"
                    },
                    "queueType": {
                        "type": "string",
                        "description": "Queue types.\n"
                    },
                    "rateLimit": {
                        "type": "string",
                        "description": "Rate limitation in form of rx-rate[/tx-rate]  [rx-burst-rate[/tx-burst-rate] [rx-burst-threshold[/tx-burst-threshold]  [rx-burst-time[/tx-burst-time] [priority] [rx-rate-min[/tx-rate-min]]]] from the point of view of the router (so 'rx' is client upload, and  'tx' is client download). All rates are measured in bits per second,  unless followed by optional 'k' suffix (kilobits per second) or 'M'  suffix (megabits per second). If tx-rate is not specified, rx-rate  serves as tx-rate too. The same applies for tx-burst-rate,  tx-burst-threshold and tx-burst-time. If both rx-burst-threshold and  tx-burst-threshold are not specified (but burst-rate is specified),  rx-rate and tx-rate are used as burst thresholds. If both rx-burst-time  and tx-burst-time are not specified, 1s is used as default. Priority  takes values 1..8, where 1 implies the highest priority, but 8 - the  lowest. If rx-rate-min and tx-rate-min are not specified rx-rate and  tx-rate values are used. The rx-rate-min and tx-rate-min values can not  exceed rx-rate and tx-rate values.\n"
                    },
                    "remoteAddress": {
                        "type": "string",
                        "description": "Tunnel address or name of the pool from which address is assigned to remote ppp interface.\n"
                    },
                    "remoteIpv6PrefixPool": {
                        "type": "string",
                        "description": "Assign prefix from IPv6 pool to the client and install corresponding IPv6 route.\n"
                    },
                    "sessionTimeout": {
                        "type": "string",
                        "description": "Maximum time the connection can stay up. By default no time limit is set.\n"
                    },
                    "useCompression": {
                        "type": "string",
                        "description": "Specifies whether to use data compression or not. yes - enable data compression no - disable data compression default - derive this value from the interface default profile; same as no if this is the interface default profile This setting does not affect OVPN tunnels.\n"
                    },
                    "useEncryption": {
                        "type": "string",
                        "description": "Specifies whether to use data encryption or not. yes - enable data encryption no - disable data encryption default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires encryption This setting does not work on OVPN and SSTP tunnels.\n"
                    },
                    "useIpv6": {
                        "type": "string",
                        "description": "Specifies whether to allow IPv6. By default is enabled if IPv6 package is installed. yes - enable IPv6 support no - disable IPv6 support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires IPv6 support.\n"
                    },
                    "useMpls": {
                        "type": "string",
                        "description": "Specifies whether to allow MPLS over PPP. yes - enable MPLS support no - disable MPLS support default - derive this value from the interface default profile; same as no if this is the interface default profile require - explicitly requires MPLS support\n"
                    },
                    "useUpnp": {
                        "type": "string",
                        "description": "Specifies whether to allow UPnP.\n"
                    },
                    "winsServers": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "IP address of the WINS server to supply to Windows clients.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Ppp/secret:Secret": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst test = new routeros.ppp.Secret(\"test\", {\n    password: \"123\",\n    profile: \"default\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest = routeros.ppp.Secret(\"test\",\n    password=\"123\",\n    profile=\"default\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Routeros.Ppp.Secret(\"test\", new()\n    {\n        Password = \"123\",\n        Profile = \"default\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Ppp\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Ppp.NewSecret(ctx, \"test\", \u0026Ppp.SecretArgs{\n\t\t\tPassword: pulumi.String(\"123\"),\n\t\t\tProfile:  pulumi.String(\"default\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Ppp.Secret;\nimport com.pulumi.routeros.Ppp.SecretArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new Secret(\"test\", SecretArgs.builder()        \n            .password(\"123\")\n            .profile(\"default\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: routeros:Ppp:Secret\n    properties:\n      password: '123'\n      profile: default\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/ppp/secret get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Ppp/secret:Secret test *6\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "callerId": {
                    "type": "string",
                    "description": "For PPTP and L2TP it is the IP address a client must connect from. For PPPoE it is the MAC address (written in CAPITAL letters) a client must  connect from. For ISDN it is the caller's number (that may or may not be  provided by the operator) the client may dial-in from.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "ipv6Routes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IPv6 routes.\n"
                },
                "lastCallerId": {
                    "type": "string"
                },
                "lastDisconnectReason": {
                    "type": "string"
                },
                "lastLoggedOut": {
                    "type": "string"
                },
                "limitBytesIn": {
                    "type": "integer",
                    "description": "Maximal amount of bytes for a session that client can upload.\n"
                },
                "limitBytesOut": {
                    "type": "integer",
                    "description": "Maximal amount of bytes for a session that client can download.\n"
                },
                "localAddress": {
                    "type": "string",
                    "description": "IP address that will be set locally on ppp interface.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name used for authentication.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password used for authentication.\n",
                    "secret": true
                },
                "profile": {
                    "type": "string",
                    "description": "Which user profile to use.\n"
                },
                "remoteAddress": {
                    "type": "string",
                    "description": "IP address that will be assigned to remote ppp interface.\n"
                },
                "remoteIpv6Prefix": {
                    "type": "string",
                    "description": "IPv6 prefix assigned to ppp client. Prefix is added to ND prefix list enabling stateless address auto-configuration on ppp interface.Available starting from v5.0.\n"
                },
                "routes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Routes  that appear on the server when the client is connected. The route  format is: dst-address gateway metric (for example, 10.1.0.0/ 24  10.0.0.1 1). Other syntax is not acceptable since it can be represented  in incorrect way. Several routes may be specified separated with commas.  This parameter will be ignored for OpenVPN.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Specifies the services that particular user will be able to use.\n"
                }
            },
            "required": [
                "lastCallerId",
                "lastDisconnectReason",
                "lastLoggedOut",
                "name"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "callerId": {
                    "type": "string",
                    "description": "For PPTP and L2TP it is the IP address a client must connect from. For PPPoE it is the MAC address (written in CAPITAL letters) a client must  connect from. For ISDN it is the caller's number (that may or may not be  provided by the operator) the client may dial-in from.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "ipv6Routes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "IPv6 routes.\n"
                },
                "limitBytesIn": {
                    "type": "integer",
                    "description": "Maximal amount of bytes for a session that client can upload.\n"
                },
                "limitBytesOut": {
                    "type": "integer",
                    "description": "Maximal amount of bytes for a session that client can download.\n"
                },
                "localAddress": {
                    "type": "string",
                    "description": "IP address that will be set locally on ppp interface.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name used for authentication.\n"
                },
                "password": {
                    "type": "string",
                    "description": "Password used for authentication.\n",
                    "secret": true
                },
                "profile": {
                    "type": "string",
                    "description": "Which user profile to use.\n"
                },
                "remoteAddress": {
                    "type": "string",
                    "description": "IP address that will be assigned to remote ppp interface.\n"
                },
                "remoteIpv6Prefix": {
                    "type": "string",
                    "description": "IPv6 prefix assigned to ppp client. Prefix is added to ND prefix list enabling stateless address auto-configuration on ppp interface.Available starting from v5.0.\n"
                },
                "routes": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Routes  that appear on the server when the client is connected. The route  format is: dst-address gateway metric (for example, 10.1.0.0/ 24  10.0.0.1 1). Other syntax is not acceptable since it can be represented  in incorrect way. Several routes may be specified separated with commas.  This parameter will be ignored for OpenVPN.\n"
                },
                "service": {
                    "type": "string",
                    "description": "Specifies the services that particular user will be able to use.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Secret resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "callerId": {
                        "type": "string",
                        "description": "For PPTP and L2TP it is the IP address a client must connect from. For PPPoE it is the MAC address (written in CAPITAL letters) a client must  connect from. For ISDN it is the caller's number (that may or may not be  provided by the operator) the client may dial-in from.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "ipv6Routes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "IPv6 routes.\n"
                    },
                    "lastCallerId": {
                        "type": "string"
                    },
                    "lastDisconnectReason": {
                        "type": "string"
                    },
                    "lastLoggedOut": {
                        "type": "string"
                    },
                    "limitBytesIn": {
                        "type": "integer",
                        "description": "Maximal amount of bytes for a session that client can upload.\n"
                    },
                    "limitBytesOut": {
                        "type": "integer",
                        "description": "Maximal amount of bytes for a session that client can download.\n"
                    },
                    "localAddress": {
                        "type": "string",
                        "description": "IP address that will be set locally on ppp interface.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Name used for authentication.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "Password used for authentication.\n",
                        "secret": true
                    },
                    "profile": {
                        "type": "string",
                        "description": "Which user profile to use.\n"
                    },
                    "remoteAddress": {
                        "type": "string",
                        "description": "IP address that will be assigned to remote ppp interface.\n"
                    },
                    "remoteIpv6Prefix": {
                        "type": "string",
                        "description": "IPv6 prefix assigned to ppp client. Prefix is added to ND prefix list enabling stateless address auto-configuration on ppp interface.Available starting from v5.0.\n"
                    },
                    "routes": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Routes  that appear on the server when the client is connected. The route  format is: dst-address gateway metric (for example, 10.1.0.0/ 24  10.0.0.1 1). Other syntax is not acceptable since it can be represented  in incorrect way. Several routes may be specified separated with commas.  This parameter will be ignored for OpenVPN.\n"
                    },
                    "service": {
                        "type": "string",
                        "description": "Specifies the services that particular user will be able to use.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:Routing/routing:Routing": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst testTable = new routeros.routing.Routing(\"testTable\", {fib: false});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest_table = routeros.routing.Routing(\"testTable\", fib=False)\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var testTable = new Routeros.Routing.Routing(\"testTable\", new()\n    {\n        Fib = false,\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/Routing\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := Routing.NewRouting(ctx, \"testTable\", \u0026Routing.RoutingArgs{\n\t\t\tFib: pulumi.Bool(false),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.Routing.Routing;\nimport com.pulumi.routeros.Routing.RoutingArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var testTable = new Routing(\"testTable\", RoutingArgs.builder()        \n            .fib(false)\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  testTable:\n    type: routeros:Routing:Routing\n    properties:\n      fib: false\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/routing/table get [print show-ids]]\n\n```sh\n $ pulumi import routeros:Routing/routing:Routing test_table \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "dynamic": {
                    "type": "boolean",
                    "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                },
                "fib": {
                    "type": "boolean",
                    "description": "fib parameter should be specified if the routing table is intended to push routes to the FIB.\n"
                },
                "invalid": {
                    "type": "boolean"
                },
                "name": {
                    "type": "string",
                    "description": "Routing table name.\n"
                }
            },
            "required": [
                "dynamic",
                "invalid",
                "name"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "fib": {
                    "type": "boolean",
                    "description": "fib parameter should be specified if the routing table is intended to push routes to the FIB.\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Routing table name.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Routing resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "dynamic": {
                        "type": "boolean",
                        "description": "Configuration item created by software, not by management interface. It is not exported, and cannot be directly modified.\n"
                    },
                    "fib": {
                        "type": "boolean",
                        "description": "fib parameter should be specified if the routing table is intended to push routes to the FIB.\n",
                        "willReplaceOnChanges": true
                    },
                    "invalid": {
                        "type": "boolean"
                    },
                    "name": {
                        "type": "string",
                        "description": "Routing table name.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:System/certificate:Certificate": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst rootCa = new routeros.system.Certificate(\"rootCa\", {\n    commonName: \"RootCA\",\n    keyUsages: [\n        \"key-cert-sign\",\n        \"crl-sign\",\n    ],\n    trusted: true,\n    signs: [{}],\n});\n// digitalSignature: Used for entity and data origin authentication with integrity.\n// keyEncipherment:  Used to encrypt symmetric key, which is then transferred to target.\n// keyAgreement:     Enables use of key agreement to establish symmetric key with target. \nconst serverCrt = new routeros.system.Certificate(\"serverCrt\", {\n    commonName: \"server.crt\",\n    keyUsages: [\n        \"digital-signature\",\n        \"key-encipherment\",\n        \"tls-server\",\n    ],\n    signs: [{\n        ca: rootCa.name,\n    }],\n});\nconst clientCrt = new routeros.system.Certificate(\"clientCrt\", {\n    commonName: \"client.crt\",\n    keySize: \"prime256v1\",\n    keyUsages: [\n        \"digital-signature\",\n        \"key-agreement\",\n        \"tls-client\",\n    ],\n    signs: [{\n        ca: rootCa.name,\n    }],\n});\nconst unsignedCrt = new routeros.system.Certificate(\"unsignedCrt\", {\n    commonName: \"unsigned.crt\",\n    keySize: \"1024\",\n    subjectAltName: \"DNS:router.lan,DNS:myrouter.lan,IP:192.168.88.1\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nroot_ca = routeros.system.Certificate(\"rootCa\",\n    common_name=\"RootCA\",\n    key_usages=[\n        \"key-cert-sign\",\n        \"crl-sign\",\n    ],\n    trusted=True,\n    signs=[routeros.system.CertificateSignArgs()])\n# digitalSignature: Used for entity and data origin authentication with integrity.\n# keyEncipherment:  Used to encrypt symmetric key, which is then transferred to target.\n# keyAgreement:     Enables use of key agreement to establish symmetric key with target. \nserver_crt = routeros.system.Certificate(\"serverCrt\",\n    common_name=\"server.crt\",\n    key_usages=[\n        \"digital-signature\",\n        \"key-encipherment\",\n        \"tls-server\",\n    ],\n    signs=[routeros.system.CertificateSignArgs(\n        ca=root_ca.name,\n    )])\nclient_crt = routeros.system.Certificate(\"clientCrt\",\n    common_name=\"client.crt\",\n    key_size=\"prime256v1\",\n    key_usages=[\n        \"digital-signature\",\n        \"key-agreement\",\n        \"tls-client\",\n    ],\n    signs=[routeros.system.CertificateSignArgs(\n        ca=root_ca.name,\n    )])\nunsigned_crt = routeros.system.Certificate(\"unsignedCrt\",\n    common_name=\"unsigned.crt\",\n    key_size=\"1024\",\n    subject_alt_name=\"DNS:router.lan,DNS:myrouter.lan,IP:192.168.88.1\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var rootCa = new Routeros.System.Certificate(\"rootCa\", new()\n    {\n        CommonName = \"RootCA\",\n        KeyUsages = new[]\n        {\n            \"key-cert-sign\",\n            \"crl-sign\",\n        },\n        Trusted = true,\n        Signs = new[]\n        {\n            null,\n        },\n    });\n\n    // digitalSignature: Used for entity and data origin authentication with integrity.\n    // keyEncipherment:  Used to encrypt symmetric key, which is then transferred to target.\n    // keyAgreement:     Enables use of key agreement to establish symmetric key with target. \n    var serverCrt = new Routeros.System.Certificate(\"serverCrt\", new()\n    {\n        CommonName = \"server.crt\",\n        KeyUsages = new[]\n        {\n            \"digital-signature\",\n            \"key-encipherment\",\n            \"tls-server\",\n        },\n        Signs = new[]\n        {\n            new Routeros.System.Inputs.CertificateSignArgs\n            {\n                Ca = rootCa.Name,\n            },\n        },\n    });\n\n    var clientCrt = new Routeros.System.Certificate(\"clientCrt\", new()\n    {\n        CommonName = \"client.crt\",\n        KeySize = \"prime256v1\",\n        KeyUsages = new[]\n        {\n            \"digital-signature\",\n            \"key-agreement\",\n            \"tls-client\",\n        },\n        Signs = new[]\n        {\n            new Routeros.System.Inputs.CertificateSignArgs\n            {\n                Ca = rootCa.Name,\n            },\n        },\n    });\n\n    var unsignedCrt = new Routeros.System.Certificate(\"unsignedCrt\", new()\n    {\n        CommonName = \"unsigned.crt\",\n        KeySize = \"1024\",\n        SubjectAltName = \"DNS:router.lan,DNS:myrouter.lan,IP:192.168.88.1\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/System\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\trootCa, err := System.NewCertificate(ctx, \"rootCa\", \u0026System.CertificateArgs{\n\t\t\tCommonName: pulumi.String(\"RootCA\"),\n\t\t\tKeyUsages: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"key-cert-sign\"),\n\t\t\t\tpulumi.String(\"crl-sign\"),\n\t\t\t},\n\t\t\tTrusted: pulumi.Bool(true),\n\t\t\tSigns: system.CertificateSignArray{\n\t\t\t\tnil,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = System.NewCertificate(ctx, \"serverCrt\", \u0026System.CertificateArgs{\n\t\t\tCommonName: pulumi.String(\"server.crt\"),\n\t\t\tKeyUsages: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"digital-signature\"),\n\t\t\t\tpulumi.String(\"key-encipherment\"),\n\t\t\t\tpulumi.String(\"tls-server\"),\n\t\t\t},\n\t\t\tSigns: system.CertificateSignArray{\n\t\t\t\t\u0026system.CertificateSignArgs{\n\t\t\t\t\tCa: rootCa.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = System.NewCertificate(ctx, \"clientCrt\", \u0026System.CertificateArgs{\n\t\t\tCommonName: pulumi.String(\"client.crt\"),\n\t\t\tKeySize:    pulumi.String(\"prime256v1\"),\n\t\t\tKeyUsages: pulumi.StringArray{\n\t\t\t\tpulumi.String(\"digital-signature\"),\n\t\t\t\tpulumi.String(\"key-agreement\"),\n\t\t\t\tpulumi.String(\"tls-client\"),\n\t\t\t},\n\t\t\tSigns: system.CertificateSignArray{\n\t\t\t\t\u0026system.CertificateSignArgs{\n\t\t\t\t\tCa: rootCa.Name,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t_, err = System.NewCertificate(ctx, \"unsignedCrt\", \u0026System.CertificateArgs{\n\t\t\tCommonName:     pulumi.String(\"unsigned.crt\"),\n\t\t\tKeySize:        pulumi.String(\"1024\"),\n\t\t\tSubjectAltName: pulumi.String(\"DNS:router.lan,DNS:myrouter.lan,IP:192.168.88.1\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.System.Certificate;\nimport com.pulumi.routeros.System.CertificateArgs;\nimport com.pulumi.routeros.System.inputs.CertificateSignArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var rootCa = new Certificate(\"rootCa\", CertificateArgs.builder()        \n            .commonName(\"RootCA\")\n            .keyUsages(            \n                \"key-cert-sign\",\n                \"crl-sign\")\n            .trusted(true)\n            .signs()\n            .build());\n\n        var serverCrt = new Certificate(\"serverCrt\", CertificateArgs.builder()        \n            .commonName(\"server.crt\")\n            .keyUsages(            \n                \"digital-signature\",\n                \"key-encipherment\",\n                \"tls-server\")\n            .signs(CertificateSignArgs.builder()\n                .ca(rootCa.name())\n                .build())\n            .build());\n\n        var clientCrt = new Certificate(\"clientCrt\", CertificateArgs.builder()        \n            .commonName(\"client.crt\")\n            .keySize(\"prime256v1\")\n            .keyUsages(            \n                \"digital-signature\",\n                \"key-agreement\",\n                \"tls-client\")\n            .signs(CertificateSignArgs.builder()\n                .ca(rootCa.name())\n                .build())\n            .build());\n\n        var unsignedCrt = new Certificate(\"unsignedCrt\", CertificateArgs.builder()        \n            .commonName(\"unsigned.crt\")\n            .keySize(\"1024\")\n            .subjectAltName(\"DNS:router.lan,DNS:myrouter.lan,IP:192.168.88.1\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  rootCa: # digitalSignature: Used for entity and data origin authentication with integrity.\n  # // keyEncipherment:  Used to encrypt symmetric key, which is then transferred to target.\n  # // keyAgreement:     Enables use of key agreement to establish symmetric key with target.\n    type: routeros:System:Certificate\n    properties:\n      commonName: RootCA\n      keyUsages:\n        - key-cert-sign\n        - crl-sign\n      trusted: true\n      # Sign Root CA.\n      signs:\n        - {}\n  serverCrt:\n    type: routeros:System:Certificate\n    properties:\n      commonName: server.crt\n      # KUs: igitalSignature, keyEncipherment or keyAgreement\n      keyUsages:\n        - digital-signature\n        - key-encipherment\n        - tls-server\n      signs:\n        - ca: ${rootCa.name}\n  clientCrt:\n    type: routeros:System:Certificate\n    properties:\n      commonName: client.crt\n      keySize: prime256v1\n      # KUs: digitalSignature and/or keyAgreement\n      keyUsages:\n        - digital-signature\n        - key-agreement\n        - tls-client\n      signs:\n        - ca: ${rootCa.name}\n  unsignedCrt:\n    type: routeros:System:Certificate\n    properties:\n      commonName: unsigned.crt\n      keySize: '1024'\n      subjectAltName: DNS:router.lan,DNS:myrouter.lan,IP:192.168.88.1\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/certificate get [print show-ids]] #If you plan to manipulate the certificate requiring signing, you need to correctly fill in the sign{} section. #Changes in the sign{} section will not cause changes in the certificate. It's not a bug, it's a feature!\n\n```sh\n $ pulumi import routeros:System/certificate:Certificate client *9D\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___skip_": {
                    "type": "string",
                    "description": "\u003cem\u003eA set of transformations for field names. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "akid": {
                    "type": "string",
                    "description": "Authority Key Identifier.\n"
                },
                "authority": {
                    "type": "string"
                },
                "ca": {
                    "type": "string"
                },
                "caCrlHost": {
                    "type": "string"
                },
                "caFingerprint": {
                    "type": "string"
                },
                "commonName": {
                    "type": "string",
                    "description": "Common Name (e.g. server FQDN or YOUR name).\n"
                },
                "copyFrom": {
                    "type": "string"
                },
                "country": {
                    "type": "string",
                    "description": "Country Name (2 letter code).\n"
                },
                "crl": {
                    "type": "string"
                },
                "daysValid": {
                    "type": "integer",
                    "description": "Certificate lifetime.\n"
                },
                "digestAlgorithm": {
                    "type": "boolean"
                },
                "dsa": {
                    "type": "boolean"
                },
                "expired": {
                    "type": "boolean",
                    "description": "Set to true if certificate is expired.\n"
                },
                "expiresAfter": {
                    "type": "string"
                },
                "fingerprint": {
                    "type": "string"
                },
                "invalidAfter": {
                    "type": "string",
                    "description": "The date after which certificate wil be invalid.\n"
                },
                "invalidBefore": {
                    "type": "string",
                    "description": "The date before which certificate is invalid.\n"
                },
                "issued": {
                    "type": "string"
                },
                "issuer": {
                    "type": "string"
                },
                "keySize": {
                    "type": "string"
                },
                "keyType": {
                    "type": "string"
                },
                "keyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Detailed key usage descriptions can be found in RFC 5280.\n"
                },
                "locality": {
                    "type": "string",
                    "description": "Locality Name (eg, city).\n"
                },
                "name": {
                    "type": "string",
                    "description": "Name of the certificate. Name can be edited.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "Organizational Unit Name (eg, section)\n"
                },
                "privateKey": {
                    "type": "boolean"
                },
                "reqFingerprint": {
                    "type": "string"
                },
                "revoked": {
                    "type": "string"
                },
                "scepUrl": {
                    "type": "string"
                },
                "serialNumber": {
                    "type": "string"
                },
                "signs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/routeros:System/CertificateSign:CertificateSign"
                    }
                },
                "skid": {
                    "type": "string",
                    "description": "Subject Key Identifier.\n"
                },
                "smartCardKey": {
                    "type": "string"
                },
                "state": {
                    "type": "string",
                    "description": "State or Province Name (full name).\n"
                },
                "status": {
                    "type": "string",
                    "description": "Shows current status of scep client.\n"
                },
                "subjectAltName": {
                    "type": "string",
                    "description": "SANs (subject alternative names).\n"
                },
                "trusted": {
                    "type": "boolean",
                    "description": "If set to yes certificate is included 'in trusted certificate chain'.\n"
                },
                "unit": {
                    "type": "string",
                    "description": "Organizational Unit Name (eg, section).\n"
                }
            },
            "required": [
                "akid",
                "authority",
                "ca",
                "caCrlHost",
                "caFingerprint",
                "commonName",
                "crl",
                "daysValid",
                "digestAlgorithm",
                "dsa",
                "expired",
                "expiresAfter",
                "fingerprint",
                "invalidAfter",
                "invalidBefore",
                "issued",
                "issuer",
                "keySize",
                "keyType",
                "keyUsages",
                "name",
                "privateKey",
                "reqFingerprint",
                "revoked",
                "scepUrl",
                "serialNumber",
                "skid",
                "smartCardKey",
                "status"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___skip_": {
                    "type": "string",
                    "description": "\u003cem\u003eA set of transformations for field names. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "commonName": {
                    "type": "string",
                    "description": "Common Name (e.g. server FQDN or YOUR name).\n",
                    "willReplaceOnChanges": true
                },
                "copyFrom": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "country": {
                    "type": "string",
                    "description": "Country Name (2 letter code).\n",
                    "willReplaceOnChanges": true
                },
                "daysValid": {
                    "type": "integer",
                    "description": "Certificate lifetime.\n",
                    "willReplaceOnChanges": true
                },
                "keySize": {
                    "type": "string",
                    "willReplaceOnChanges": true
                },
                "keyUsages": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "Detailed key usage descriptions can be found in RFC 5280.\n",
                    "willReplaceOnChanges": true
                },
                "locality": {
                    "type": "string",
                    "description": "Locality Name (eg, city).\n",
                    "willReplaceOnChanges": true
                },
                "name": {
                    "type": "string",
                    "description": "Name of the certificate. Name can be edited.\n"
                },
                "organization": {
                    "type": "string",
                    "description": "Organizational Unit Name (eg, section)\n",
                    "willReplaceOnChanges": true
                },
                "signs": {
                    "type": "array",
                    "items": {
                        "$ref": "#/types/routeros:System/CertificateSign:CertificateSign"
                    },
                    "willReplaceOnChanges": true
                },
                "state": {
                    "type": "string",
                    "description": "State or Province Name (full name).\n",
                    "willReplaceOnChanges": true
                },
                "subjectAltName": {
                    "type": "string",
                    "description": "SANs (subject alternative names).\n",
                    "willReplaceOnChanges": true
                },
                "trusted": {
                    "type": "boolean",
                    "description": "If set to yes certificate is included 'in trusted certificate chain'.\n"
                },
                "unit": {
                    "type": "string",
                    "description": "Organizational Unit Name (eg, section).\n",
                    "willReplaceOnChanges": true
                }
            },
            "requiredInputs": [
                "commonName"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Certificate resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___skip_": {
                        "type": "string",
                        "description": "\u003cem\u003eA set of transformations for field names. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "akid": {
                        "type": "string",
                        "description": "Authority Key Identifier.\n"
                    },
                    "authority": {
                        "type": "string"
                    },
                    "ca": {
                        "type": "string"
                    },
                    "caCrlHost": {
                        "type": "string"
                    },
                    "caFingerprint": {
                        "type": "string"
                    },
                    "commonName": {
                        "type": "string",
                        "description": "Common Name (e.g. server FQDN or YOUR name).\n",
                        "willReplaceOnChanges": true
                    },
                    "copyFrom": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "country": {
                        "type": "string",
                        "description": "Country Name (2 letter code).\n",
                        "willReplaceOnChanges": true
                    },
                    "crl": {
                        "type": "string"
                    },
                    "daysValid": {
                        "type": "integer",
                        "description": "Certificate lifetime.\n",
                        "willReplaceOnChanges": true
                    },
                    "digestAlgorithm": {
                        "type": "boolean"
                    },
                    "dsa": {
                        "type": "boolean"
                    },
                    "expired": {
                        "type": "boolean",
                        "description": "Set to true if certificate is expired.\n"
                    },
                    "expiresAfter": {
                        "type": "string"
                    },
                    "fingerprint": {
                        "type": "string"
                    },
                    "invalidAfter": {
                        "type": "string",
                        "description": "The date after which certificate wil be invalid.\n"
                    },
                    "invalidBefore": {
                        "type": "string",
                        "description": "The date before which certificate is invalid.\n"
                    },
                    "issued": {
                        "type": "string"
                    },
                    "issuer": {
                        "type": "string"
                    },
                    "keySize": {
                        "type": "string",
                        "willReplaceOnChanges": true
                    },
                    "keyType": {
                        "type": "string"
                    },
                    "keyUsages": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "Detailed key usage descriptions can be found in RFC 5280.\n",
                        "willReplaceOnChanges": true
                    },
                    "locality": {
                        "type": "string",
                        "description": "Locality Name (eg, city).\n",
                        "willReplaceOnChanges": true
                    },
                    "name": {
                        "type": "string",
                        "description": "Name of the certificate. Name can be edited.\n"
                    },
                    "organization": {
                        "type": "string",
                        "description": "Organizational Unit Name (eg, section)\n",
                        "willReplaceOnChanges": true
                    },
                    "privateKey": {
                        "type": "boolean"
                    },
                    "reqFingerprint": {
                        "type": "string"
                    },
                    "revoked": {
                        "type": "string"
                    },
                    "scepUrl": {
                        "type": "string"
                    },
                    "serialNumber": {
                        "type": "string"
                    },
                    "signs": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/routeros:System/CertificateSign:CertificateSign"
                        },
                        "willReplaceOnChanges": true
                    },
                    "skid": {
                        "type": "string",
                        "description": "Subject Key Identifier.\n"
                    },
                    "smartCardKey": {
                        "type": "string"
                    },
                    "state": {
                        "type": "string",
                        "description": "State or Province Name (full name).\n",
                        "willReplaceOnChanges": true
                    },
                    "status": {
                        "type": "string",
                        "description": "Shows current status of scep client.\n"
                    },
                    "subjectAltName": {
                        "type": "string",
                        "description": "SANs (subject alternative names).\n",
                        "willReplaceOnChanges": true
                    },
                    "trusted": {
                        "type": "boolean",
                        "description": "If set to yes certificate is included 'in trusted certificate chain'.\n"
                    },
                    "unit": {
                        "type": "string",
                        "description": "Organizational Unit Name (eg, section).\n",
                        "willReplaceOnChanges": true
                    }
                },
                "type": "object"
            }
        },
        "routeros:System/identity:Identity": {
            "description": "## # routeros.System.Identity (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.System.SystemIdentity\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "Device name.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "Device name.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Identity resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Device name.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:System/scheduler:Scheduler": {
            "description": "## # routeros.System.Scheduler (Resource)\n\n---\n\n#### This is an alias for backwards compatibility between plugin versions. \nPlease see documentation for routeros.System.SystemScheduler\n",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "interval": {
                    "type": "string",
                    "description": "Interval between two script executions, if time interval is set to zero, the script is only executed at its start time,\notherwise it is executed repeatedly at the time interval is specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "nextRun": {
                    "type": "string"
                },
                "onEvent": {
                    "type": "string",
                    "description": "Name of the script to execute. It must be presented at /system script.\n"
                },
                "owner": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of applicable policies: * dude - Policy that grants rights to log in to dude server. * ftp - Policy that grants\nfull rights to log in remotely via FTP, to read/write/erase files and to transfer files from/to the router. Should be\nused together with read/write policies. * password - Policy that grants rights to change the password. * policy - Policy\nthat grants user management rights. Should be used together with the write policy. Allows also to see global variables\ncreated by other users (requires also 'test' policy). * read - Policy that grants read access to the router's\nconfiguration. All console commands that do not alter router's configuration are allowed. Doesn't affect FTP. * reboot -\nPolicy that allows rebooting the router. * romon - Policy that grants rights to connect to RoMon server. * sensitive -\nPolicy that grants rights to change \"hide sensitive\" option, if this policy is disabled sensitive information is not\ndisplayed. * sniff - Policy that grants rights to use packet sniffer tool. * test - Policy that grants rights to run\nping, traceroute, bandwidth-test, wireless scan, snooper, and other test commands. * write - Policy that grants write\naccess to the router's configuration, except for user management. This policy does not allow to read the configuration,\nso make sure to enable read policy as well. policy = [\"ftp\", \"read\", \"write\"]\n"
                },
                "runCount": {
                    "type": "string",
                    "description": "This counter is incremented each time the script is executed.\n"
                },
                "startDate": {
                    "type": "string",
                    "description": "Date of the first script execution.\n"
                },
                "startTime": {
                    "type": "string",
                    "description": "Time of the first script execution. If scheduler item has start-time set to startup, it behaves as if start-time and\nstart-date were set to time 3 seconds after console starts up. It means that all scripts having start-time is startup\nand interval is 0 will be executed once each time router boots. If the interval is set to value other than 0 scheduler\nwill not run at startup.\n"
                }
            },
            "required": [
                "interval",
                "name",
                "nextRun",
                "onEvent",
                "owner",
                "policies",
                "runCount",
                "startDate",
                "startTime"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "interval": {
                    "type": "string",
                    "description": "Interval between two script executions, if time interval is set to zero, the script is only executed at its start time,\notherwise it is executed repeatedly at the time interval is specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "onEvent": {
                    "type": "string",
                    "description": "Name of the script to execute. It must be presented at /system script.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of applicable policies: * dude - Policy that grants rights to log in to dude server. * ftp - Policy that grants\nfull rights to log in remotely via FTP, to read/write/erase files and to transfer files from/to the router. Should be\nused together with read/write policies. * password - Policy that grants rights to change the password. * policy - Policy\nthat grants user management rights. Should be used together with the write policy. Allows also to see global variables\ncreated by other users (requires also 'test' policy). * read - Policy that grants read access to the router's\nconfiguration. All console commands that do not alter router's configuration are allowed. Doesn't affect FTP. * reboot -\nPolicy that allows rebooting the router. * romon - Policy that grants rights to connect to RoMon server. * sensitive -\nPolicy that grants rights to change \"hide sensitive\" option, if this policy is disabled sensitive information is not\ndisplayed. * sniff - Policy that grants rights to use packet sniffer tool. * test - Policy that grants rights to run\nping, traceroute, bandwidth-test, wireless scan, snooper, and other test commands. * write - Policy that grants write\naccess to the router's configuration, except for user management. This policy does not allow to read the configuration,\nso make sure to enable read policy as well. policy = [\"ftp\", \"read\", \"write\"]\n"
                },
                "startDate": {
                    "type": "string",
                    "description": "Date of the first script execution.\n"
                },
                "startTime": {
                    "type": "string",
                    "description": "Time of the first script execution. If scheduler item has start-time set to startup, it behaves as if start-time and\nstart-date were set to time 3 seconds after console starts up. It means that all scripts having start-time is startup\nand interval is 0 will be executed once each time router boots. If the interval is set to value other than 0 scheduler\nwill not run at startup.\n"
                }
            },
            "requiredInputs": [
                "onEvent"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering Scheduler resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "interval": {
                        "type": "string",
                        "description": "Interval between two script executions, if time interval is set to zero, the script is only executed at its start time,\notherwise it is executed repeatedly at the time interval is specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "nextRun": {
                        "type": "string"
                    },
                    "onEvent": {
                        "type": "string",
                        "description": "Name of the script to execute. It must be presented at /system script.\n"
                    },
                    "owner": {
                        "type": "string"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of applicable policies: * dude - Policy that grants rights to log in to dude server. * ftp - Policy that grants\nfull rights to log in remotely via FTP, to read/write/erase files and to transfer files from/to the router. Should be\nused together with read/write policies. * password - Policy that grants rights to change the password. * policy - Policy\nthat grants user management rights. Should be used together with the write policy. Allows also to see global variables\ncreated by other users (requires also 'test' policy). * read - Policy that grants read access to the router's\nconfiguration. All console commands that do not alter router's configuration are allowed. Doesn't affect FTP. * reboot -\nPolicy that allows rebooting the router. * romon - Policy that grants rights to connect to RoMon server. * sensitive -\nPolicy that grants rights to change \"hide sensitive\" option, if this policy is disabled sensitive information is not\ndisplayed. * sniff - Policy that grants rights to use packet sniffer tool. * test - Policy that grants rights to run\nping, traceroute, bandwidth-test, wireless scan, snooper, and other test commands. * write - Policy that grants write\naccess to the router's configuration, except for user management. This policy does not allow to read the configuration,\nso make sure to enable read policy as well. policy = [\"ftp\", \"read\", \"write\"]\n"
                    },
                    "runCount": {
                        "type": "string",
                        "description": "This counter is incremented each time the script is executed.\n"
                    },
                    "startDate": {
                        "type": "string",
                        "description": "Date of the first script execution.\n"
                    },
                    "startTime": {
                        "type": "string",
                        "description": "Time of the first script execution. If scheduler item has start-time set to startup, it behaves as if start-time and\nstart-date were set to time 3 seconds after console starts up. It means that all scripts having start-time is startup\nand interval is 0 will be executed once each time router boots. If the interval is set to value other than 0 scheduler\nwill not run at startup.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:System/systemIdentity:SystemIdentity": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst identity = new routeros.system.SystemIdentity(\"identity\", {});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nidentity = routeros.system.SystemIdentity(\"identity\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var identity = new Routeros.System.SystemIdentity(\"identity\");\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/System\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := System.NewSystemIdentity(ctx, \"identity\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.System.SystemIdentity;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var identity = new SystemIdentity(\"identity\");\n\n    }\n}\n```\n```yaml\nresources:\n  identity:\n    type: routeros:System:SystemIdentity\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n\n\n```sh\n $ pulumi import routeros:System/systemIdentity:SystemIdentity identity .\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "Device name.\n"
                }
            },
            "required": [
                "name"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "name": {
                    "type": "string",
                    "description": "Device name.\n"
                }
            },
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SystemIdentity resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Device name.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:System/systemScheduler:SystemScheduler": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst schedule1 = new routeros.system.SystemScheduler(\"schedule1\", {onEvent: \"script name\"});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\nschedule1 = routeros.system.SystemScheduler(\"schedule1\", on_event=\"script name\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var schedule1 = new Routeros.System.SystemScheduler(\"schedule1\", new()\n    {\n        OnEvent = \"script name\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/System\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := System.NewSystemScheduler(ctx, \"schedule1\", \u0026System.SystemSchedulerArgs{\n\t\t\tOnEvent: pulumi.String(\"script name\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.System.SystemScheduler;\nimport com.pulumi.routeros.System.SystemSchedulerArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var schedule1 = new SystemScheduler(\"schedule1\", SystemSchedulerArgs.builder()        \n            .onEvent(\"script name\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  schedule1:\n    type: routeros:System:SystemScheduler\n    properties:\n      onEvent: script name\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/system/scheduler get [print show-ids]]\n\n```sh\n $ pulumi import routeros:System/systemScheduler:SystemScheduler schedule1 \"*0\"\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "interval": {
                    "type": "string",
                    "description": "Interval between two script executions, if time interval is set to zero, the script is only executed at its start time,\notherwise it is executed repeatedly at the time interval is specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n"
                },
                "nextRun": {
                    "type": "string"
                },
                "onEvent": {
                    "type": "string",
                    "description": "Name of the script to execute. It must be presented at /system script.\n"
                },
                "owner": {
                    "type": "string"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of applicable policies: * dude - Policy that grants rights to log in to dude server. * ftp - Policy that grants\nfull rights to log in remotely via FTP, to read/write/erase files and to transfer files from/to the router. Should be\nused together with read/write policies. * password - Policy that grants rights to change the password. * policy - Policy\nthat grants user management rights. Should be used together with the write policy. Allows also to see global variables\ncreated by other users (requires also 'test' policy). * read - Policy that grants read access to the router's\nconfiguration. All console commands that do not alter router's configuration are allowed. Doesn't affect FTP. * reboot -\nPolicy that allows rebooting the router. * romon - Policy that grants rights to connect to RoMon server. * sensitive -\nPolicy that grants rights to change \"hide sensitive\" option, if this policy is disabled sensitive information is not\ndisplayed. * sniff - Policy that grants rights to use packet sniffer tool. * test - Policy that grants rights to run\nping, traceroute, bandwidth-test, wireless scan, snooper, and other test commands. * write - Policy that grants write\naccess to the router's configuration, except for user management. This policy does not allow to read the configuration,\nso make sure to enable read policy as well. policy = [\"ftp\", \"read\", \"write\"]\n"
                },
                "runCount": {
                    "type": "string",
                    "description": "This counter is incremented each time the script is executed.\n"
                },
                "startDate": {
                    "type": "string",
                    "description": "Date of the first script execution.\n"
                },
                "startTime": {
                    "type": "string",
                    "description": "Time of the first script execution. If scheduler item has start-time set to startup, it behaves as if start-time and\nstart-date were set to time 3 seconds after console starts up. It means that all scripts having start-time is startup\nand interval is 0 will be executed once each time router boots. If the interval is set to value other than 0 scheduler\nwill not run at startup.\n"
                }
            },
            "required": [
                "interval",
                "name",
                "nextRun",
                "onEvent",
                "owner",
                "policies",
                "runCount",
                "startDate",
                "startTime"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "interval": {
                    "type": "string",
                    "description": "Interval between two script executions, if time interval is set to zero, the script is only executed at its start time,\notherwise it is executed repeatedly at the time interval is specified.\n"
                },
                "name": {
                    "type": "string",
                    "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                    "willReplaceOnChanges": true
                },
                "onEvent": {
                    "type": "string",
                    "description": "Name of the script to execute. It must be presented at /system script.\n"
                },
                "policies": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "description": "List of applicable policies: * dude - Policy that grants rights to log in to dude server. * ftp - Policy that grants\nfull rights to log in remotely via FTP, to read/write/erase files and to transfer files from/to the router. Should be\nused together with read/write policies. * password - Policy that grants rights to change the password. * policy - Policy\nthat grants user management rights. Should be used together with the write policy. Allows also to see global variables\ncreated by other users (requires also 'test' policy). * read - Policy that grants read access to the router's\nconfiguration. All console commands that do not alter router's configuration are allowed. Doesn't affect FTP. * reboot -\nPolicy that allows rebooting the router. * romon - Policy that grants rights to connect to RoMon server. * sensitive -\nPolicy that grants rights to change \"hide sensitive\" option, if this policy is disabled sensitive information is not\ndisplayed. * sniff - Policy that grants rights to use packet sniffer tool. * test - Policy that grants rights to run\nping, traceroute, bandwidth-test, wireless scan, snooper, and other test commands. * write - Policy that grants write\naccess to the router's configuration, except for user management. This policy does not allow to read the configuration,\nso make sure to enable read policy as well. policy = [\"ftp\", \"read\", \"write\"]\n"
                },
                "startDate": {
                    "type": "string",
                    "description": "Date of the first script execution.\n"
                },
                "startTime": {
                    "type": "string",
                    "description": "Time of the first script execution. If scheduler item has start-time set to startup, it behaves as if start-time and\nstart-date were set to time 3 seconds after console starts up. It means that all scripts having start-time is startup\nand interval is 0 will be executed once each time router boots. If the interval is set to value other than 0 scheduler\nwill not run at startup.\n"
                }
            },
            "requiredInputs": [
                "onEvent"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering SystemScheduler resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "interval": {
                        "type": "string",
                        "description": "Interval between two script executions, if time interval is set to zero, the script is only executed at its start time,\notherwise it is executed repeatedly at the time interval is specified.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "Changing the name of this resource will force it to be recreated. \u003e The links of other configuration properties to this\nresource may be lost! \u003e Changing the name of the resource outside of a Terraform will result in a loss of control\nintegrity for that resource!\n",
                        "willReplaceOnChanges": true
                    },
                    "nextRun": {
                        "type": "string"
                    },
                    "onEvent": {
                        "type": "string",
                        "description": "Name of the script to execute. It must be presented at /system script.\n"
                    },
                    "owner": {
                        "type": "string"
                    },
                    "policies": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        },
                        "description": "List of applicable policies: * dude - Policy that grants rights to log in to dude server. * ftp - Policy that grants\nfull rights to log in remotely via FTP, to read/write/erase files and to transfer files from/to the router. Should be\nused together with read/write policies. * password - Policy that grants rights to change the password. * policy - Policy\nthat grants user management rights. Should be used together with the write policy. Allows also to see global variables\ncreated by other users (requires also 'test' policy). * read - Policy that grants read access to the router's\nconfiguration. All console commands that do not alter router's configuration are allowed. Doesn't affect FTP. * reboot -\nPolicy that allows rebooting the router. * romon - Policy that grants rights to connect to RoMon server. * sensitive -\nPolicy that grants rights to change \"hide sensitive\" option, if this policy is disabled sensitive information is not\ndisplayed. * sniff - Policy that grants rights to use packet sniffer tool. * test - Policy that grants rights to run\nping, traceroute, bandwidth-test, wireless scan, snooper, and other test commands. * write - Policy that grants write\naccess to the router's configuration, except for user management. This policy does not allow to read the configuration,\nso make sure to enable read policy as well. policy = [\"ftp\", \"read\", \"write\"]\n"
                    },
                    "runCount": {
                        "type": "string",
                        "description": "This counter is incremented each time the script is executed.\n"
                    },
                    "startDate": {
                        "type": "string",
                        "description": "Date of the first script execution.\n"
                    },
                    "startTime": {
                        "type": "string",
                        "description": "Time of the first script execution. If scheduler item has start-time set to startup, it behaves as if start-time and\nstart-date were set to time 3 seconds after console starts up. It means that all scripts having start-time is startup\nand interval is 0 will be executed once each time router boots. If the interval is set to value other than 0 scheduler\nwill not run at startup.\n"
                    }
                },
                "type": "object"
            }
        },
        "routeros:System/user:User": {
            "description": "{{% examples %}}\n## Example Usage\n{{% example %}}\n\n```typescript\nimport * as pulumi from \"@pulumi/pulumi\";\nimport * as routeros from \"@pulumi/routeros\";\n\nconst test = new routeros.system.User(\"test\", {\n    address: \"0.0.0.0/0\",\n    comment: \"Test User\",\n    group: \"read\",\n    password: \"secret\",\n});\n```\n```python\nimport pulumi\nimport pulumi_routeros as routeros\n\ntest = routeros.system.User(\"test\",\n    address=\"0.0.0.0/0\",\n    comment=\"Test User\",\n    group=\"read\",\n    password=\"secret\")\n```\n```csharp\nusing System.Collections.Generic;\nusing System.Linq;\nusing Pulumi;\nusing Routeros = Pulumi.Routeros;\n\nreturn await Deployment.RunAsync(() =\u003e \n{\n    var test = new Routeros.System.User(\"test\", new()\n    {\n        Address = \"0.0.0.0/0\",\n        Comment = \"Test User\",\n        Group = \"read\",\n        Password = \"secret\",\n    });\n\n});\n```\n```go\npackage main\n\nimport (\n\t\"github.com/pulumi/pulumi-routeros/sdk/go/routeros/System\"\n\t\"github.com/pulumi/pulumi/sdk/v3/go/pulumi\"\n)\n\nfunc main() {\n\tpulumi.Run(func(ctx *pulumi.Context) error {\n\t\t_, err := System.NewUser(ctx, \"test\", \u0026System.UserArgs{\n\t\t\tAddress:  pulumi.String(\"0.0.0.0/0\"),\n\t\t\tComment:  pulumi.String(\"Test User\"),\n\t\t\tGroup:    pulumi.String(\"read\"),\n\t\t\tPassword: pulumi.String(\"secret\"),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n```\n```java\npackage generated_program;\n\nimport com.pulumi.Context;\nimport com.pulumi.Pulumi;\nimport com.pulumi.core.Output;\nimport com.pulumi.routeros.System.User;\nimport com.pulumi.routeros.System.UserArgs;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.io.File;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class App {\n    public static void main(String[] args) {\n        Pulumi.run(App::stack);\n    }\n\n    public static void stack(Context ctx) {\n        var test = new User(\"test\", UserArgs.builder()        \n            .address(\"0.0.0.0/0\")\n            .comment(\"Test User\")\n            .group(\"read\")\n            .password(\"secret\")\n            .build());\n\n    }\n}\n```\n```yaml\nresources:\n  test:\n    type: routeros:System:User\n    properties:\n      address: 0.0.0.0/0\n      comment: Test User\n      group: read\n      password: secret\n```\n{{% /example %}}\n{{% /examples %}}\n\n## Import\n\n#The ID can be found via API or the terminal #The command for the terminal is -\u003e :put [/user get [print show-ids]]\n\n```sh\n $ pulumi import routeros:System/user:User test *1\n```\n\n ",
            "properties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "Host or network address from which the user is allowed to log in.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "expired": {
                    "type": "boolean",
                    "description": "Password expired.\n"
                },
                "group": {
                    "type": "string",
                    "description": "Name of the group the user belongs to.\n"
                },
                "lastLoggedIn": {
                    "type": "string",
                    "description": "Read-only field. Last time and date when a user logged in.\n"
                },
                "name": {
                    "type": "string",
                    "description": "User name. Although it must start with an alphanumeric character, it may contain '*', '_', '.' and '@' symbols.\n"
                },
                "password": {
                    "type": "string",
                    "description": "User  password. If not specified, it is left blank (hit [Enter] when logging  in). It conforms to standard Unix characteristics of passwords and may  contain letters, digits, '*' and '_' symbols.\n",
                    "secret": true
                }
            },
            "required": [
                "expired",
                "group",
                "lastLoggedIn",
                "name"
            ],
            "inputProperties": {
                "___id_": {
                    "type": "integer",
                    "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "___path_": {
                    "type": "string",
                    "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                },
                "address": {
                    "type": "string",
                    "description": "Host or network address from which the user is allowed to log in.\n"
                },
                "comment": {
                    "type": "string"
                },
                "disabled": {
                    "type": "boolean"
                },
                "group": {
                    "type": "string",
                    "description": "Name of the group the user belongs to.\n"
                },
                "name": {
                    "type": "string",
                    "description": "User name. Although it must start with an alphanumeric character, it may contain '*', '_', '.' and '@' symbols.\n"
                },
                "password": {
                    "type": "string",
                    "description": "User  password. If not specified, it is left blank (hit [Enter] when logging  in). It conforms to standard Unix characteristics of passwords and may  contain letters, digits, '*' and '_' symbols.\n",
                    "secret": true
                }
            },
            "requiredInputs": [
                "group"
            ],
            "stateInputs": {
                "description": "Input properties used for looking up and filtering User resources.\n",
                "properties": {
                    "___id_": {
                        "type": "integer",
                        "description": "\u003cem\u003eResource ID type (.id / name). This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "___path_": {
                        "type": "string",
                        "description": "\u003cem\u003eResource path for CRUD operations. This is an internal service field, setting a value is not required.\u003c/em\u003e\n"
                    },
                    "address": {
                        "type": "string",
                        "description": "Host or network address from which the user is allowed to log in.\n"
                    },
                    "comment": {
                        "type": "string"
                    },
                    "disabled": {
                        "type": "boolean"
                    },
                    "expired": {
                        "type": "boolean",
                        "description": "Password expired.\n"
                    },
                    "group": {
                        "type": "string",
                        "description": "Name of the group the user belongs to.\n"
                    },
                    "lastLoggedIn": {
                        "type": "string",
                        "description": "Read-only field. Last time and date when a user logged in.\n"
                    },
                    "name": {
                        "type": "string",
                        "description": "User name. Although it must start with an alphanumeric character, it may contain '*', '_', '.' and '@' symbols.\n"
                    },
                    "password": {
                        "type": "string",
                        "description": "User  password. If not specified, it is left blank (hit [Enter] when logging  in). It conforms to standard Unix characteristics of passwords and may  contain letters, digits, '*' and '_' symbols.\n",
                        "secret": true
                    }
                },
                "type": "object"
            }
        }
    },
    "functions": {
        "routeros:Iface/getInterfaces:getInterfaces": {
            "inputs": {
                "description": "A collection of arguments for invoking getInterfaces.\n",
                "properties": {
                    "___id_": {
                        "type": "integer"
                    },
                    "___path_": {
                        "type": "string"
                    },
                    "filter": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Additional request filtering options.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getInterfaces.\n",
                "properties": {
                    "___id_": {
                        "type": "integer"
                    },
                    "___path_": {
                        "type": "string"
                    },
                    "filter": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Additional request filtering options.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "interfaces": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/routeros:Iface/getInterfacesInterface:getInterfacesInterface"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "interfaces",
                    "id"
                ]
            }
        },
        "routeros:Ip/getAddresses:getAddresses": {
            "inputs": {
                "description": "A collection of arguments for invoking getAddresses.\n",
                "properties": {
                    "___id_": {
                        "type": "integer"
                    },
                    "___path_": {
                        "type": "string"
                    },
                    "filter": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Additional request filtering options.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getAddresses.\n",
                "properties": {
                    "___id_": {
                        "type": "integer"
                    },
                    "___path_": {
                        "type": "string"
                    },
                    "addresses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/routeros:Ip/getAddressesAddress:getAddressesAddress"
                        }
                    },
                    "filter": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Additional request filtering options.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "addresses",
                    "id"
                ]
            }
        },
        "routeros:Ip/getFirewall:getFirewall": {
            "description": "## # routeros.Ip.getFirewall (Data Source)\n\nThis datasource contains all supported firewall resources:\n- address_list\n- nat\n- mangle\n- rules (aka filter)\n",
            "inputs": {
                "description": "A collection of arguments for invoking getFirewall.\n",
                "properties": {
                    "addressLists": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/routeros:Ip/getFirewallAddressList:getFirewallAddressList"
                        }
                    },
                    "mangles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/routeros:Ip/getFirewallMangle:getFirewallMangle"
                        }
                    },
                    "nats": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/routeros:Ip/getFirewallNat:getFirewallNat"
                        }
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/routeros:Ip/getFirewallRule:getFirewallRule"
                        }
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getFirewall.\n",
                "properties": {
                    "addressLists": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/routeros:Ip/getFirewallAddressList:getFirewallAddressList"
                        }
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "mangles": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/routeros:Ip/getFirewallMangle:getFirewallMangle"
                        }
                    },
                    "nats": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/routeros:Ip/getFirewallNat:getFirewallNat"
                        }
                    },
                    "rules": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/routeros:Ip/getFirewallRule:getFirewallRule"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "addressLists",
                    "mangles",
                    "nats",
                    "rules",
                    "id"
                ]
            }
        },
        "routeros:Ip/getRoutes:getRoutes": {
            "inputs": {
                "description": "A collection of arguments for invoking getRoutes.\n",
                "properties": {
                    "___id_": {
                        "type": "integer"
                    },
                    "___path_": {
                        "type": "string"
                    },
                    "filter": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Additional request filtering options.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getRoutes.\n",
                "properties": {
                    "___id_": {
                        "type": "integer"
                    },
                    "___path_": {
                        "type": "string"
                    },
                    "filter": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Additional request filtering options.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    },
                    "routes": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/routeros:Ip/getRoutesRoute:getRoutesRoute"
                        }
                    }
                },
                "type": "object",
                "required": [
                    "routes",
                    "id"
                ]
            }
        },
        "routeros:Ipv6/getIpv6Addresses:getIpv6Addresses": {
            "inputs": {
                "description": "A collection of arguments for invoking getIpv6Addresses.\n",
                "properties": {
                    "___id_": {
                        "type": "integer"
                    },
                    "___path_": {
                        "type": "string"
                    },
                    "filter": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Additional request filtering options.\n"
                    }
                },
                "type": "object"
            },
            "outputs": {
                "description": "A collection of values returned by getIpv6Addresses.\n",
                "properties": {
                    "___id_": {
                        "type": "integer"
                    },
                    "___path_": {
                        "type": "string"
                    },
                    "addresses": {
                        "type": "array",
                        "items": {
                            "$ref": "#/types/routeros:Ipv6/getIpv6AddressesAddress:getIpv6AddressesAddress"
                        }
                    },
                    "filter": {
                        "type": "object",
                        "additionalProperties": {
                            "$ref": "pulumi.json#/Any"
                        },
                        "description": "Additional request filtering options.\n"
                    },
                    "id": {
                        "type": "string",
                        "description": "The provider-assigned unique ID for this managed resource.\n"
                    }
                },
                "type": "object",
                "required": [
                    "addresses",
                    "id"
                ]
            }
        }
    }
}